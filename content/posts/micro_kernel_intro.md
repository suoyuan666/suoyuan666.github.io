---
title: "微内核架构讲解: 1. 概述"
author: suo yuan
date: 2025-11-22T03:19:01Z
draft: false
tags:
- micro_kernel
categories:
- 微内核架构讲解
description: "这是我学习微内核架构时的总结感悟，首先是对微内核架构的介绍"
summary: "这是我学习微内核架构时的总结感悟，首先是对微内核架构的介绍"
---

# 微内核架构讲解: 1. 概述

## 微内核介绍

在介绍微内核之前，就需要介绍与之相对应的宏内核架构。

宏内核的特点在于内核提供的服务是互相紧密联结在一起，也可以认为是都处于特权态。

宏内核这样设计有很多好处，首先是内核服务都在一起，那么内核既可以知道硬盘事件，又可以知道内存使用情况等等，这些符号都可以是内部可见的，内核想要做任何事情都可以轻松地调用其他内核服务，因为它们捆绑在了一起。另一点，从直觉上来讲，大家先入为主的可能认为内核就应该这样 —— 将硬件接口简单封装并提供给上层应用，同时监控各种应用方便后续管理。

但是一个内核真的就应该有这些服务吗，换一个角度来想，有这么多服务运行运行在特权态，看起来运作是很高效的，那么代价是什么呢？

首先，第一个坏处就是存在安全隐患，那么多服务都运行在特权态，这是一个很严重的安全问题。因为目前主流的操作系统并不是完全由内存安全语言编写，并且内存安全并不意味着绝对安全。现在操作系统内核并不牢固，某个内核组件出现了问题，就有可能导致整个内核都被劫持。

第二，内核服务的增多不仅仅是导致攻击面的增加，同时也导致了维护成本的上升。这里其实有点软件工程问题的味道了，就是如果各个服务之间并不是完美的执行着模块化的思想，那么后期的维护可能是一个问题。

从这些缺点中，就引出了微内核的概念，即尽可能将内核服务拆出内核态，将它们放到用户态单独运行。

![micro_kernel_cmp](./images/micro_kernel_intro/micro_kernel_cmp.png)

微内核主张使用进程间通信 (IPC) 替代原有的内核服务之间的通信方式。微内核可以只实现好进程的抽象和进程间通信，其他的全都写在用户程序中。

微内核首先解决的就是内核代码量过大导致的攻击面过多的问题，这也是 seL4 这个著名的微内核被形式化验证为安全的主要原因。同时，将内核服务放到用户态单独运行的好处在于它变成了可替代的组件，并且不会因为 crash 导致内核崩溃。

> 这里的说的 seL4 被形式化验证为安全指的是 seL4 内核不会存在：死锁、缓冲区溢出、内存未初始化等之类的问题。它在数学上验证了这一点。
>
> 验证细节可以去看 2009 年发表在 SOSP 上的 [seL4: formal verification of an OS kernel](https://dl.acm.org/doi/10.1145/1629575.1629596) 这篇论文

微内核的缺陷在于过度依赖于 IPC，以前在宏内核中一个函数调用可以解决的事情，在这里可能变成一个 IPC，这导致了性能下降。这也是宏内核能够大行其道的原因，那就是宏内核保证了性能。

关于宏内核和微内核的讨论，最为著名的就是 1992 年时 Andrew S. Tanenbaum 和 Linus Torvalds 的讨论了。

Linus Torvalds 作为 Linux 的作者，而 Andrew S. Tanenbaum 则是 Minix 这个 Linux 创意来源的作者，我印象中 Linus 提出了 Linux 的原因之一就是 Minix 作为一个教学性质的项目并不考虑过多用户使用的需求。

Tanenbaum 认为微内核是优于宏内核设计的，而 Linus 回应认为微内核虽然理论上更优，但是微内核的开发困难并且性能也不好。两个人的讨论引起了多方注意，很多人也参与了讨论。Tanenbaum 一开始甚至认为 Linux 因为宏内核且可移植性差，最终不会有什么起色，现实告诉我们并非如此，BSD 当时因为和 AT&T 的官司问题导致开发进度停患，并且大家对 BSD 的法律问题存有疑虑，而 Linux 没有法律问题，凭借着互联网的快车，Linux 也得到了迅速发展。

从这里就可以看出微内核在当时的学术界还是存在认可度的，但是工业界选择了宏内核。

## seL4

L4 微内核是微内核中很出名的一类微内核，比如刚刚提到的 seL4 就属于 L4 微内核。L4 认为对于真正可用的微内核来说，就应该在一开始以高性能为高优先级来设计。L4 在内核态的部分有：地址空间、进程间通信、线程和调度。L4 秉承着微内核的设计思想，认为只有某个概念移出内核后会妨碍系统真正的运转时，才将其挪进内核。

### IPC

现在我们来介绍一下 L4 的 IPC

微内核架构的核心功能就是 IPC，进程间的通信会通过 kernel。L4 选择了同步的 `send` 和 `recv` 而不是异步的，这是为了减少上下文切换和用户态与内核态切换导致的性能开销问题。

如果 `send` 和 `recv` 是异步的，那么两个进程想要通信，他们都需要调用一次 `send` 和一次 `recv`，这里就涉及到了四次系统调用。为了减缓过多的系统调用产生的性能影响，L4 选择了同步的方式。

在 seL4 中，如果一个进程想要向另一个进程发送数据，这时的 `send` 不会立即被 kernel 发送，而是需要等到对方的 `recv` 也到了内核。

这么做的好处是为了避免数据的拷贝，这样 kernel 可以直接将 `send` 的数据拷贝给 `recv`，而不需要提前拷贝到 kernel 中。并且在此时，由于一个进程的 `send` 和对应进程的 `recv` 都在 kernel 中，那么 kernel 可以在恢复上下文的时候直接恢复到 `recv` 对应的进程。对于比较短的消息来说，这里会做寄存器上的传递，如果是信息比较大，那么就给 `recv` 的进程映射一个页。

也就是说，对于发送短信息的时候直接复制寄存器，长信息使用共享内存。

### Capability

L4 引入了 capability 作权限管理。关于 capability，我计划再花一章好好介绍它，不过在这里我也会先说一下。

在 Linux 中其实也有 capability，这里的 capability 的目的是通过细粒度的拆分 root 用户的权限保证安全性。

在 seL4 中，每个进程都有自己的 capability 集合，seL4 需要 capability 的另一点当然是内核服务的下放。父进程可以通过 IPC 将自己的 capability 复制一份弱化级别的传递给子进程，同时支持收回权限。

seL4 的 capability 有三种类型：

1. 控制内核对象（如 tcb）
2. 控制抽象对象（如 irq）
3. 控制内存分配

seL4 的 root task 有所有资源的 capability，之后的每个进程拥有的 capability 都不相同。

可以认为 capability 就是那个 seL4 中 syscall 的 syscall id，kernel 会根据 capability 找到对应的处理程序。capability 全部位于内核态，用户程序只能得到对应的引用。

capability 同样也有权限管理，比如对 endpoint 的 capability 就会有读和写。endpoint 是 seL4 中 IPC 的一个抽象，一对发送和接受将会对应一个 endpoint。

### 内存管理

seL4 的内存管理是在用户态做的，root task 启动时拥有所有的未初始化内存的 capability，这里的 memory 叫做 untyped memory，意思就是没有初始化，这块内存也没有实际表示什么类型。

进程创建时，root task 会 "retype" 一块 untyped memory 用来给即将分配的进程使用，同时，"retype" 操作会产生对新对象的 capability。
