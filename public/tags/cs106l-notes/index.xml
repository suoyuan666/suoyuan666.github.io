<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>CS106L Notes - Tag - 索元的博客</title>
        <link>http://localhost:1313/tags/cs106l-notes/</link>
        <description>CS106L Notes - Tag - 索元的博客</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>s5n666@outlook.com (suo yuan)</managingEditor>
            <webMaster>s5n666@outlook.com (suo yuan)</webMaster><lastBuildDate>Mon, 05 Feb 2024 03:42:51 &#43;0000</lastBuildDate><atom:link href="http://localhost:1313/tags/cs106l-notes/" rel="self" type="application/rss+xml" /><item>
    <title>CS106L: Type &amp; RAII</title>
    <link>http://localhost:1313/posts/cs106l_type_raii/</link>
    <pubDate>Mon, 05 Feb 2024 03:42:51 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cs106l_type_raii/</guid>
    <description><![CDATA[<p>CS106L 中关于 Type 和 RAII 的部分</p>
<h1 id="type--raii">Type &amp; RAII</h1>
<h2 id="type--stdoptional">Type &amp; <code>std::optional</code></h2>
<h3 id="type-conversion">Type Conversion</h3>
<p>C++提供了更好的类型转换（相比于 C 那样直接写括号的强制类型转换）</p>
<p><a href="https://en.cppreference.com/w/cpp/language/static_cast" target="_blank" rel="noopener noreffer ">static_cast</a> 和 <a href="https://en.cppreference.com/w/cpp/language/dynamic_cast" target="_blank" rel="noopener noreffer ">dynamic_cast</a></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Derived</span> <span class="n">derivedObj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Base</span><span class="o">*</span> <span class="n">basePtr</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">derivedObj</span><span class="p">);</span></span></span></code></pre></div></div>
<p>就像这个 <code>static_cast</code>，会在编译时检验转换是否合法。</p>
<h3 id="stdoptional"><code>std::optional</code></h3>
<p><code>std::optional</code> interface：</p>
<ul>
<li><code>.value()</code>
<ul>
<li>返回包含的值或抛出 <code>bad_optional_access</code> 错误。</li>
</ul>
</li>
<li><code>.value_or(valueType val)</code>
<ul>
<li>返回包含的值或默认值 val（参数）。</li>
</ul>
</li>
<li><code>.has_value()</code>
<ul>
<li>如果存在包含的值，则返回 true；否则返回 false。</li>
</ul>
</li>
</ul>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">lookupStudent</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">){</span> <span class="cm">/*something*/</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="n">lookupStudent</span><span class="p">(</span><span class="err">“</span><span class="n">Keith</span><span class="err">”</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">student</span><span class="p">.</span><span class="n">has_value</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">output</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="err">“</span> <span class="n">is</span> <span class="n">from</span> <span class="err">“</span> <span class="o">&lt;&lt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">output</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">state</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="err">“</span><span class="n">No</span> <span class="n">student</span> <span class="n">found</span><span class="err">”</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>使用 <code>std::optional</code> 返回值的优点：</p>
<ul>
<li>函数签名可以创建更具信息性的合约（contracts）。</li>
<li>类的函数调用具有保证和可用的行为。</li>
</ul>
<p>缺点：</p>
<ul>
<li>你需要在每个地方使用 <code>.value()</code>。</li>
<li>（在 C++中）仍然可能出现 bad_optional_access 错误。</li>
<li>（在 C++中）optional 也可能具有 undefined behavior（<code>*optional</code> 与 <code>.value()</code> 执行相同的操作，没有错误检查）。</li>
<li>在许多情况下，开发者希望有 <code>std::optional&lt;T&amp;&gt;</code>，但实际上并没有这个类型。</li>
</ul>
<p><code>std::optional</code> 的 monadic 接口（C++23）：</p>
<ul>
<li><code>.and_then(function f)</code>
<ul>
<li>如果存在包含的值，则返回调用 <code>f(value)</code> 的结果，否则返回 null_opt（f 必须返回 optional 类型）。</li>
</ul>
</li>
<li><code>.transform(function f)</code>
<ul>
<li>如果存在包含的值，则返回调用 <code>f(value)</code> 的结果，否则返回 null_opt（f 必须返回 optional<!-- raw HTML omitted --> 类型）。</li>
</ul>
</li>
<li><code>.or_else(function f)</code>
<ul>
<li>如果存在值，则返回该值，否则返回调用 <code>f</code> 的结果</li>
</ul>
</li>
</ul>
<p>那样代码就可以这么写：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">lookupStudent</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">){</span><span class="cm">/*something*/</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="n">lookupStudent</span><span class="p">(</span><span class="err">“</span><span class="n">Keith</span><span class="err">”</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">stu</span><span class="p">)[]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">stu</span> <span class="o">?</span> <span class="n">stu</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">name</span> <span class="o">+</span> <span class="err">“</span><span class="n">is</span> <span class="n">from</span> <span class="err">“</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">stu</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">state</span><span class="p">)</span> <span class="o">:</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">output</span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="n">func</span><span class="p">).</span><span class="n">value_or</span><span class="p">(</span><span class="err">“</span><span class="n">No</span> <span class="n">student</span> <span class="n">found</span><span class="err">”</span><span class="p">);</span></span></span></code></pre></div></div>
<h2 id="raii">RAII</h2>
<h3 id="intro">intro</h3>
<blockquote>
<p>The best example of why I shouldn&rsquo;t be in marketing. I didn&rsquo;t have a good day when I named that &ndash; Bjarne Stroustrup (daddy of C++)</p>
</blockquote>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">EvaluateSalaryAndReturnName</span><span class="p">(</span><span class="kt">int</span> <span class="n">idNumber</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Employee</span><span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Employee</span><span class="p">(</span><span class="n">idNumber</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">Title</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#34;CEO&#34;</span> <span class="o">||</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">Salary</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">100000</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">First</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span>
</span></span><span class="line"><span class="cl">                  <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">Last</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; is overpaid&#34;</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">First</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; &#34;</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">Last</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="n">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>对于这个函数，有很多地方可能导致内存泄露，即在 <code>delete</code> 之前的异常退出该函数从而导致在 heap 上的内存没有 free。所以我们需要 <code>try-catch</code>。</p>
<p><strong>关于异常安全</strong></p>
<p>不抛出异常：<code>noexcept</code> 关键字保证函数不会因为异常而导致一些 undefined behavior。这会出现在析构函数，swap，移动构造函数之类的。</p>
<p>在 <a href="https://google.github.io/styleguide/cppguide.html#Exceptions" target="_blank" rel="noopener noreffer ">Google C++ Style Guide</a> 中，Google 提到不建议使用异常。</p>
<p>理由：</p>
<blockquote>
<p>On their face, the benefits of using exceptions outweigh the costs, especially in new projects. However, for existing code, the introduction of exceptions has implications on all dependent code. If exceptions can be propagated beyond a new project, it also becomes problematic to integrate the new project into existing exception-free code. Because most existing C++ code at Google is not prepared to deal with exceptions, it is comparatively difficult to adopt new code that generates exceptions.
Given that Google&rsquo;s existing code is not exception-tolerant, the costs of using exceptions are somewhat greater than the costs in a new project. The conversion process would be slow and error-prone. We don&rsquo;t believe that the available alternatives to exceptions, such as error codes and assertions, introduce a significant burden.
Our advice against using exceptions is not predicated on philosophical or moral grounds, but practical ones. Because we&rsquo;d like to use our open-source projects at Google and it&rsquo;s difficult to do so if those projects use exceptions, we need to advise against exceptions in Google open-source projects as well. Things would probably be different if we had to do it all over again from scratch.
This prohibition also applies to exception handling related features such as <code>std::exception_ptr</code> and <code>std::nested_exception</code>.</p>
</blockquote>
<p>来自 ChatGPT@Poe 的中文翻译：</p>
<blockquote>
<p>在表面上，使用异常的好处超过了成本，尤其是在新项目中。然而，对于现有的代码来说，引入异常会对所有相关的代码产生影响。如果异常可以传播到新项目之外，将新项目整合到现有的无异常代码中也会带来问题。由于 Google 大部分现有的 C++代码都没有准备好处理异常，采用生成异常的新代码相对困难。
考虑到 Google 现有的代码不具备异常容忍性，使用异常的成本要略高于在新项目中的成本。转换过程将会缓慢且容易出错。我们认为，异常的替代方案（如错误码和断言）并不会引入重大负担。
我们反对使用异常的建议并非基于哲学或道德的立场，而是出于实际考虑。因为我们希望在 Google 使用我们的开源项目，但如果这些项目使用异常，那么在使用过程中会变得困难。如果我们从头开始重新做，情况可能会有所不同。
这个禁令也适用于与异常处理相关的特性，如 <code>std::exception_ptr</code> 和 <code>std::nested_exception</code>。</p>
</blockquote>
<h3 id="raii-1">RAII</h3>
<p><strong>RAII</strong>: <strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization</p>
<p>这个技术还有几个叫法：</p>
<p><strong>SBRM</strong>: <strong>S</strong>cope <strong>B</strong>ased Memo<strong>r</strong>y <strong>M</strong>anagement</p>
<p><strong>CADRE</strong>: <strong>C</strong>onstructor <strong>A</strong>cquires, <strong>D</strong>estructor <strong>Re</strong>leases</p>
<p>从后两个的全拼能看出来，RAII 就是利用了类在超出作用域范围的时候就自动调用析构函数这一点，将 <code>new</code> 和 <code>delete</code> 放到构造函数和析构函数中。</p>
<p>比如在 open 一个文件的时候，不应该先用 <code>ifstream</code> 创建一个变量，然后调用 <code>open</code> 函数，而是直接 <code>ifstream input(&quot;test.txt)</code>，这就是 RAII 的写法，这样也不需要在后面写 <code>input.close()</code> 了。</p>
<p>锁也有类似的：<code>lock_guard</code></p>
<p></p>
<p>在 <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines" target="_blank" rel="noopener noreffer ">C++ Core Guidelines</a> 也有相关描述:</p>
<p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-newdelete" target="_blank" rel="noopener noreffer ">R.11: Avoid calling new and delete explicitly</a></p>
<h3 id="smart-pointers">Smart Pointers</h3>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Tp</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Tp</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Tp</span><span class="o">&gt;</span><span class="p">;</span></span></span></code></pre></div></div>
<p><strong>unique_ptr</strong></p>
<p><code>unique_ptr</code>，唯一持有自己的资源并在被销毁的时候用析构函数释放。唯一持有为了防止复制后发生重复的 free。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">rawPtrFn</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">delete</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// use unique_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">rawPtrFn</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">n</span><span class="p">(</span><span class="k">new</span> <span class="n">Node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div></div>
<p><code>unique_ptr</code> 无法被复制，但可以通过 <code>std::move</code> 移动：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">u3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">u4</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">u3</span><span class="p">);</span></span></span></code></pre></div></div>
<p><strong>shared_ptr</strong></p>
<p><code>shared_ptr</code> 可以复制，当所有指向这个资源的 <code>shared_ptr</code> 都死掉后就 free 掉这块内存。<code>shared_ptr</code> 用引用计数实现了这一点。</p>
<p><strong>weak_ptr</strong></p>
<p><code>weak_ptr</code> 类似于 <code>shared_ptr</code>，但是没有引用计数。</p>]]></description>
</item>
<item>
    <title>CS106L: Class</title>
    <link>http://localhost:1313/posts/cs106l_class_op/</link>
    <pubDate>Sun, 04 Feb 2024 03:42:51 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cs106l_class_op/</guid>
    <description><![CDATA[<p>CS106L 中关于类的部分</p>
<h1 id="class">Class</h1>
<blockquote>
<p>A struct simply feels like an open pile of bits with very little in the way of encapsulation or functionality. A class feels like a living and responsible member of society with intelligent services, a strong encapsulation barrier, and a well defined interface</p>
<ul>
<li>Bjarne Stroustrup</li>
</ul>
</blockquote>
<h2 id="构造函数初始化列表">构造函数初始化列表</h2>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Student</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span><span class="p">)</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">state</span><span class="p">(</span><span class="n">state</span><span class="p">),</span> <span class="n">age</span><span class="p">(</span><span class="n">age</span><span class="p">){</span> <span class="p">}</span></span></span></code></pre></div></div>
<p>函数体内部还是可以写代码的</p>
<h2 id="关于-delete">关于 delete</h2>
<p>array 作为一个基础的类型，当开发者手动为此创建内存之后也可以之后手动释放掉：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//int * is the type of an array variable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">my_int_array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//this is how you initialize an array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">my_int_array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">//this is how you index into an array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">one_element</span> <span class="o">=</span> <span class="n">my_int_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">delete</span> <span class="p">[]</span> <span class="n">my_int_array</span><span class="p">;</span></span></span></code></pre></div></div>
<p>delete 一般在类的析构函数中出现（需要手动掉释放这块内存）</p>
<p></p>
<p>这里那个虚函数等于 0 的意义在于，让继承它的类必须实现该函数，否则编译失败。这种虚函数叫作纯虚函数（<em>pure virtual function</em></p>
<p>一个类存在一个纯虚函数就叫作抽象类，抽象类不能被实例化。</p>
<p>如何子类不想要实现自己的构造函数，可以：</p>
<p></p>
<p>如果是析构函数可能有点麻烦，如果有一个基类（这个类的析构函数不是虚函数）的指针指向派生类，并且这时候要 <code>delete</code> 这个指针就不会调用派生类的析构函数。如果基类的析构函数实现为虚函数，那么才可以正常调用派生类的析构函数释放内存。</p>
<p></p>
<p></p>
<p>如果基类的虚函数有实现了，并且派生类想要调用，可以这么写：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">t</span><span class="p">.</span><span class="n">Drink</span><span class="o">::</span><span class="n">make</span><span class="p">();</span></span></span></code></pre></div></div>
<h2 id="template-classes">Template classes</h2>
<blockquote>
<p>Fundamental Theorem of Software Engineering: Any problem can be solved by adding enough layers of indirection</p>
</blockquote>
<p>模板类之前也见到过：<code>std::vector&lt;int&gt;</code>。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//Example: Structs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">First</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Second</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">MyPair</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">First</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Second</span> <span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">First</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Second</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyPair</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">First</span> <span class="n">getFirst</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">Second</span> <span class="nf">getSecond</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="nf">setFirst</span><span class="p">(</span><span class="n">First</span> <span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="nf">setSecond</span><span class="p">(</span><span class="n">Second</span> <span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">First</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Second</span> <span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">First</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Second</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyPair</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*...*/</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">First</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Second</span> <span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div></div>
<p>而其部分函数的实现，也需要加 template：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">First</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Second</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">First</span> <span class="n">MyPair</span><span class="o">::</span><span class="n">getFirst</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>模板类的成员函数和其他函数并不一样，编写的时候最好在一起，而不是像其他普通的编写一样，分为.h 和.cpp 两个文件。因为模板类的成员函数需要编译时的实例化，需要具体的参数生成对应函数的实现。</p>
<p>模板类可以针对特定类型写一个版本：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">FooSpecial</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">FooSpecial</span><span class="p">(</span><span class="kt">float</span> <span class="n">var</span><span class="p">)</span> <span class="o">:</span> <span class="n">var_</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;hello float! &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">var_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">var_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div></div>
<h2 id="const-keyword">const keyword</h2>
<p>const 函数不可以修改类的元素后者传给它的参数。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span> <span class="k">const</span> <span class="n">p</span><span class="p">;</span></span></span></code></pre></div></div>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">++</span> <span class="c1">// ok
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">p</span><span class="o">++</span> <span class="c1">// error
</span></span></span></code></pre></div></div>
<p>const-interface：所有成员函数都可以在定义类的时候被 const 标记</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">StrVector</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">using</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">size_t</span> <span class="n">kInitialSize</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*...*/</span>
</span></span><span class="line"><span class="cl">        <span class="n">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>            <span class="c1">//here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>             <span class="c1">//here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="n">size_t</span> <span class="n">indx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">size_t</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">iterator</span> <span class="nf">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">iterator</span> <span class="nf">end</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*...*/</span></span></span></code></pre></div></div>
<p>这种标记是一种 <code>const</code> 成员函数，它保证了函数内部不会修改 <code>this</code> 实例。</p>
<h2 id="operators">Operators</h2>
<h3 id="运算符重载">运算符重载</h3>
<p></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">strvec</span><span class="p">{</span><span class="s">&#34;Hello&#34;</span><span class="p">,</span> <span class="s">&#34;World&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">strvec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">strvec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s">&#34;!&#34;</span><span class="p">;</span></span></span></code></pre></div></div>
<p>上面这段代码相当于：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">strvec</span><span class="p">{</span><span class="s">&#34;Hello&#34;</span><span class="p">,</span> <span class="s">&#34;World&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">.</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">strvec</span><span class="p">.</span><span class="k">operator</span><span class="p">[](</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">strvec</span><span class="p">.</span><span class="k">operator</span><span class="p">[](</span><span class="mi">1</span><span class="p">).</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="s">&#34;!&#34;</span><span class="p">);</span></span></span></code></pre></div></div>
<p>或者是这样：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">strvec</span><span class="p">{</span><span class="s">&#34;Hello&#34;</span><span class="p">,</span> <span class="s">&#34;World&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span> <span class="n">strvec</span><span class="p">.</span><span class="k">operator</span><span class="p">[](</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">strvec</span><span class="p">.</span><span class="k">operator</span><span class="p">[](</span><span class="mi">1</span><span class="p">),</span> <span class="s">&#34;!&#34;</span><span class="p">);</span></span></span></code></pre></div></div>
<p>每个运算符都有一个与之对应的函数</p>
<p>对于操作符重载时的返回值问题，有的虽然看起来不会有返回值其实也是有的，例如 <code>i += z</code>，返回值就应该是 <code>i</code>，所以 <code>(i += z) += y</code> 这样的操作也是可以的。</p>
<p>像 <code>+=</code> 这种都是类自己的成员函数，会被这个类型的变量所调用，所以对这种运算符重载，参数表只有一个参数，通过 <code>*this</code> 还是可以访问到那个变量。</p>
<p>假设实现 <code>+</code> 运算符的重载：</p>
<p></p>
<p>将重载的函数实现成成员函数还是非成员函数的一般规则：</p>
<ul>
<li>由于 C++的语义原因，一些操作符必须被实现为成员函数（例如<code>[]</code>, <code>()</code>, <code>-&gt;</code>, <code>=</code>）</li>
<li>还有一些必须实现为非成员函数（例如 <code>&lt;&lt;</code>，开发者不能覆盖掉 STL 库的实现，所以需要实现为非成员函数）</li>
<li>如果是一元操作符（例如 <code>++</code>）就实现为成员函数。</li>
<li>如果是二元操作符，而且对这两个变量的操作是一致的（即要么都修改，要么都不修改），就实现成非成员函数（例如 <code>+</code>, <code>&lt;</code>）。</li>
<li>如果是二元操作符，但是对这两个变量的操作不一致，就实现为成员函数（例如 <code>+=</code>）。</li>
</ul>
<p>如果非成员函数涉及到访问类的私有变量，可以考虑 <code>friends</code></p>
<p></p>
<p><strong>Principle of Least Astonishment (POLA)</strong></p>
<ul>
<li>设计一个操作符主要是为了模仿传统意义上该操作符的用法
<ul>
<li>比如之前提到的 <code>+=</code> 需要有一个返回值</li>
</ul>
</li>
<li>对称的运算符需要实现为非成员函数
<ul>
<li>这里说的对称的意思感觉就是运算符两边的表达式可以互换，举的例子是 <code>a + 1</code> 这样的，如果是成员函数的话 <code>1 + a</code> 就不能调用对应函数了。</li>
</ul>
</li>
<li>如果重载了一个运算符，它相关那一套都需要重载。
<ul>
<li>这里的一套就是上面介绍有哪些运算符中那个分类，一套说的是那里面的一类。</li>
</ul>
</li>
</ul>
<h2 id="special-member-functions">Special Member Functions</h2>
<p></p>
<p>它们特殊在如果开发者不自己实现的话，编译器会自动生成，但是编译器自动生成的有时候未必能满足开发者的需要。</p>
<p>这些函数就是：构造函数，析构函数，复制构造函数，复制运算符。其中，复制构造函数会创建一个新的变量（也是在创建新变量的时候被调用的）。</p>
<h3 id="copy-semantics">Copy Semantics</h3>
<p>编译器默认生成的复制构造函数会把很多信息都复制一遍，所以新变量和旧变量的指针会指向同一个内存，复制运算符会把要覆写的变量清空然后重新全部复制一遍。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Student</span><span class="p">(</span><span class="k">const</span> <span class="n">Student</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">name</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">name</span><span class="p">),</span> <span class="n">state</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">state</span><span class="p">),</span> <span class="n">age</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">age</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div></div>
<p>重载复制运算符的时候就不能像上面这样写初始化列表了，毕竟它不是构造函数（</p>
<p>当这个类有一些自己独有的资源时（比如指针，文件流），应该写自己的复制构造函数。</p>
<p>当要实现（删除）一个复制构造函数或者复制运算符或者析构函数的时候，你应该实现（删除）这三个所有。</p>
<h3 id="move-semantics">Move Semantics</h3>
<p>移动语义代表了 C++ 的一大哲学——尽量不要牺牲效率。</p>
<p>例如 <code>std::vector</code> 中有一个与 <code>push_back()</code> 类似的函数：<code>emplace_back()</code>。它和 <code>push_back()</code> 不同的是，它可以将参数在内部直接构造插入，而不是像 <code>push_back()</code> 需要创建一个已有的变量。<a href="https://en.cppreference.com/w/cpp/container/vector/emplace_back" target="_blank" rel="noopener noreffer ">cppreference 网站关于它的条目中</a> 有一个例子：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">President</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">country</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">year</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">President</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">p_name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">p_country</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p_year</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p_name</span><span class="p">)),</span> <span class="n">country</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p_country</span><span class="p">)),</span> <span class="n">year</span><span class="p">(</span><span class="n">p_year</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;I am being constructed.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">President</span><span class="p">(</span><span class="n">President</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">name</span><span class="p">)),</span> <span class="n">country</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">country</span><span class="p">)),</span> <span class="n">year</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">year</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;I am being moved.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">President</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">President</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">President</span><span class="o">&gt;</span> <span class="n">elections</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;emplace_back:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">elections</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">&#34;Nelson Mandela&#34;</span><span class="p">,</span> <span class="s">&#34;South Africa&#34;</span><span class="p">,</span> <span class="mi">1994</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">year</span> <span class="o">==</span> <span class="mi">1994</span> <span class="o">&amp;&amp;</span> <span class="s">&#34;uses a reference to the created object (C++17)&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">President</span><span class="o">&gt;</span> <span class="n">reElections</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">push_back:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">reElections</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">President</span><span class="p">(</span><span class="s">&#34;Franklin Delano Roosevelt&#34;</span><span class="p">,</span> <span class="s">&#34;the USA&#34;</span><span class="p">,</span> <span class="mi">1936</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">Contents:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">President</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">president</span><span class="p">:</span> <span class="n">elections</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">president</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; was elected president of &#34;</span>
</span></span><span class="line"><span class="cl">                  <span class="o">&lt;&lt;</span> <span class="n">president</span><span class="p">.</span><span class="n">country</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; in &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">president</span><span class="p">.</span><span class="n">year</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">President</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">president</span><span class="p">:</span> <span class="n">reElections</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">president</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; was re-elected president of &#34;</span>
</span></span><span class="line"><span class="cl">                  <span class="o">&lt;&lt;</span> <span class="n">president</span><span class="p">.</span><span class="n">country</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; in &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">president</span><span class="p">.</span><span class="n">year</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>可以看到：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span><span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">elections</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">&#34;Nelson Mandela&#34;</span><span class="p">,</span> <span class="s">&#34;South Africa&#34;</span><span class="p">,</span> <span class="mi">1994</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">reElections</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">President</span><span class="p">(</span><span class="s">&#34;Franklin Delano Roosevelt&#34;</span><span class="p">,</span> <span class="s">&#34;the USA&#34;</span><span class="p">,</span> <span class="mi">1936</span><span class="p">));</span></span></span></code></pre></div></div>
<p></p>
<p></p>
<p>移动构造函数和移动符号的函数原型如下：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Student</span><span class="p">(</span><span class="n">Student</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Student</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Student</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span></span></span></code></pre></div></div>
<p>但是虽然参数列表里面写的是 <code>&amp;&amp;</code> 右值引用，但是在函数体内部，这个引用本身是一个左值，常规的 <code>=</code> 不再是移动而是复制。为了让复制变成移动，需要用到 <code>std::move()</code>，它会接受一个左值并返回相应的右值。经验之谈：在类成员函数中，如果接受一个 <code>const &amp;</code> 参数并在函数内部将其赋值给其他变量，那么通常可以使用 <code>std::move</code>，除此之外不要使用它。</p>
<p>如果一个类定义了复制构造函数和复制运算符，那么应该也实现一份移动构造函数和移动运算符。</p>
<p></p>
<p></p>]]></description>
</item>
<item>
    <title>CS106L: Templates</title>
    <link>http://localhost:1313/posts/cs106l_template_algorithms/</link>
    <pubDate>Sat, 03 Feb 2024 03:42:51 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cs106l_template_algorithms/</guid>
    <description><![CDATA[<p>CS106L 中关于 Templates 的部分</p>
<h1 id="templates">Templates</h1>
<h2 id="templates-function">Templates Function</h2>
<p>template 应该算得上很自然的想法（🤔 又或者是套娃的另一次应用），我认为这就是对函数的进一层抽象，它将函数的逻辑抽象成与类型无关，比如</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">min</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="o">=</span><span class="kt">int</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">Type</span> <span class="n">myMin</span><span class="p">(</span><span class="n">Type</span> <span class="n">a</span><span class="p">,</span> <span class="n">Type</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>这里的 <code>typename</code> 没有指明类型，实际上可以写成 <code>class T</code>，这样这个函数就不会接受 int 之类的类型。那个 <code>=int</code> 表示其默认类型（虽然我还没认识到写它的意义）。</p>
<p>可以针对性的再写一个特定类型的模板函数:</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="kt">void</span> <span class="n">print_msg</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;print_msg called with float type!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">add3</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">minvar</span> <span class="o">=</span> <span class="n">min</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span></span></span></code></pre></div></div>
<p>隐式存在一个问题在于参数的类型未必能被识别出来（有些类型的定义方式差不多）。不过貌似编译器这时候会报错。</p>
<p>从一个实际的类型推广到一个模板，这个过程被称为 <em>Concept Lifting</em>。对于隐式类型的来说，这种提升可能会导致传入一些不可以工作的类型（比如函数内部使用了 <code>=</code> 赋值，但 stream 是不可以这样做的）</p>
<p>毕竟有了函数指针，其实可以把抽象做的更细一些。比如 <em>Predicate Functions</em></p>
<p></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">InputIt</span><span class="p">,</span> <span class="k">typename</span> <span class="n">UniPred</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">count_occurrences</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">begin</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">end</span><span class="p">,</span> <span class="n">UniPred</span> <span class="n">pred</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">))</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">isVowel</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">vowels</span> <span class="o">=</span> <span class="s">&#34;aeiou&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">vowels</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;Xadia&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">count_occurrences</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">isVowel</span><span class="p">);</span></span></span></code></pre></div></div>
<p>C++20 允许开发者显示指定其 template 类型的要求，具体可以参见文档：<a href="https://en.cppreference.com/w/cpp/language/constraints" target="_blank" rel="noopener noreffer ">Constraints and concepts (since C++20)</a> 和 <a href="https://en.cppreference.com/w/cpp/language/requires" target="_blank" rel="noopener noreffer ">Requires expression (since C++20)</a></p>
<h2 id="lamdba--algorithms">Lamdba &amp; Algorithms</h2>
<p>Lamda function:</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[</span><span class="n">capture</span><span class="o">-</span><span class="n">clause</span><span class="p">](</span><span class="n">parameters</span><span class="p">)</span><span class="o">-&gt;</span><span class="k">return</span><span class="o">-</span><span class="n">value</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div></div>
<p>C++14 开始，这个 <code>return-value</code> 是可选的。</p>
<p></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="p">[]</span> <span class="c1">// captures nothing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="n">limit</span><span class="p">]</span> <span class="c1">// captures lower by value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="o">&amp;</span><span class="n">limit</span><span class="p">]</span> <span class="c1">// captures lower by reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="o">&amp;</span><span class="n">limit</span><span class="p">,</span> <span class="n">upper</span><span class="p">]</span> <span class="c1">// captures lower by reference, higher by value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">limit</span><span class="p">]</span> <span class="c1">// captures everything except lower by reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="c1">// captures everything by reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="c1">// captures everything by value
</span></span></span></code></pre></div></div>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">isMoreThan</span> <span class="o">=</span> <span class="p">[</span><span class="n">limit</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">isMoreThan</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span> <span class="c1">//true
</span></span></span></code></pre></div></div>
<p>有了这个之后，也就不需要像之前那样定义<em>Predicate Functions</em>了，可以直接写 lamdba。</p>
<p>STL 的一些 algorithm 不能用于开发者自定义的类型（比如寻找最小值之类的），这时候需要用到 lambda 函数。</p>
<p>比如对于这样的 vector:</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">vecstu</span><span class="p">{{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">}};</span></span></span></code></pre></div></div>
<p>直接使用 <code>std::minmax_element()</code> 是无法通过编译的</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="p">[</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span><span class="n">vecstu</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecstu</span><span class="p">.</span><span class="n">end</span><span class="p">());</span></span></span></code></pre></div></div>
<p>额，根据我看到的录像那里，其开发环境是没有在编译前给出预警的。但是我的 vscode 在只给了两个参数的时候：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-text">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">In template: invalid operands to binary expression (&#39;Student&#39; and &#39;Student&#39;) clang(typecheck_invalid_operands)</span></span></code></pre></div></div>
<p>这时候就可以加一个 lamdba 函数，并传给 <code>minmax_element()</code></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">compareStudent</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Student</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="n">Student</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">averge</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">averge</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div></div>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="p">[</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span><span class="n">vecstu</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecstu</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">compareStudent</span><span class="p">);</span></span></span></code></pre></div></div>
<p>在 <code>std::copy</code> 这个函数中，如果传入的 iterator 指向的 container 没有足够的空间，那么就会复制到为初始化的内存中，这时候应该传入一个 iterator adaptor。这种函数可以给 iterator 加点料（比如 <code>back_inserter()</code> 会让返回的 iterator 在赋值不存在的空间时扩展 container）。</p>
<p>引用上一章一开始给出的代码：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">generate</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">rand</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>]]></description>
</item>
<item>
    <title>CS106L: Containers &amp; Iterators</title>
    <link>http://localhost:1313/posts/cs106l_container_iterator/</link>
    <pubDate>Fri, 02 Feb 2024 03:42:51 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cs106l_container_iterator/</guid>
    <description><![CDATA[<p>CS106L 中关于 container 和 iterators 的部分</p>
<h1 id="containers">Containers</h1>
<p>STL 是一个历史相较悠久并且一直在更新的一个标准库，它提供了很多算法供开发者使用</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">generate</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">rand</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>这 5 行代码，就完成了对 vector 元素的随机化赋值并排序，然后输出到 console 上这一系列的工作。</p>
<h2 id="sequence-containers">Sequence Containers</h2>
<p>这是一种数据结构，提供了对元素序列的访问</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">foraword_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></span></span></code></pre></div></div>
<p></p>
<p>如果越界访问，<code>vec.at(i)</code> 会抛出一个异常，而 <code>vec[i]</code> 会是一个 undefined behavior</p>
<p>Sequence Containers 是一种特殊的 Containers，因为它是顺序的。</p>
<p>正如关于数组和链表之间老生长谈的对比一样，在 vector 的前面添加一个元素还是很难绷的，C++提供了另一种数据结构处理这种情况：<code>std::deque&lt;T&gt;</code></p>
<p>vector 有 <code>push_back()</code> 函数添加变量，deque 除了 <code>push_back()</code> 有 <code>push_front()</code> 可以在前面插入</p>
<p>A <strong>deque</strong> is a <strong>d</strong>ouble <strong>e</strong>nded <strong>que</strong>ue</p>
<p>deque 的实现是将多个 vector 作为枝干，一个 vector 作为主干。如果你从后插入，那就将元素插入最后面枝叶里面，如果最后面那个满了就给主干多加一个，如果主干满了不能加枝叶了那就换一个更长的主干。插入前面是类似的操作。</p>
<p>有两种经典的数据结构——栈和队列，在这里它们被称为 <em>Container Adaptors</em>。它们会通过对 Container 做一些调整来适应它们自身数据结构的定义。在 C++ 文档中，它们的描述都会有这么一句：</p>
<blockquote>
<p>The std::stack class is a container adaptor that gives the programmer the functionality of a stack - specifically, a LIFO (last-in, first-out) data structure.
The std::queue class is a container adaptor that gives the functionality of a queue - specifically, a FIFO (first-in, first-out) data structure.</p>
</blockquote>
<p>正如 C++ 设计哲学所说的那句赋予开发者完全的掌控权，所以 stack 虽然是默认用 deque 实现的，但开发者可以自己选择使用什么 container（比如 vector）实现的 stack。（在文档中也有叙述：<a href="https://en.cppreference.com/w/cpp/container/stack" target="_blank" rel="noopener noreffer ">std::stack</a></p>
<p>额，按照我的理解，这句话所说的代码应该是这么写：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">st</span><span class="p">;</span></span></span></code></pre></div></div>
<p>查找 vector 可以使用<code>std::find</code></p>
<h2 id="associative-containers">Associative Containers</h2>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></span></span></code></pre></div></div>
<p>正如前面所说，Sequence Containers 是顺序的，可以通过索引来访问，而 Associative Containers 是不能通过索引来访问的。</p>
<p>虽然是不能通过索引访问，但是 <code>std::map&lt;T1, T2&gt;</code> 和 <code>std::set&lt;T&gt;</code> 会按照大小顺序排列。如果这里存储的是开发者自定义的类型，可以定义用于比较两个实例的大小的小于号帮助它按照顺序排列。vector 会有 sort 函数用于排序，这里面也是会存在这个问题，如果 vector 存储的是开发者自定义的类型，要么是实现这个类型的小于号，要么使用 lamdba 函数</p>
<p></p>
<p></p>
<p><code>map.at(key)</code> 和 <code>may[key]</code> 区别类似之前提到的，前者不存在的话会抛出异常，后者默认创建它。</p>
<p>可以通过<code>map.count(key)</code> 来查看是否存在。C++20 也支持了<code>var.contains()</code> 来查找：<a href="https://en.cppreference.com/w/cpp/container/set/contains" target="_blank" rel="noopener noreffer ">std::set&lt;Key,Compare,Allocator&gt;::contains</a>，<a href="https://en.cppreference.com/w/cpp/container/map/contains" target="_blank" rel="noopener noreffer ">std::map&lt;Key,T,Compare,Allocator&gt;::contains</a>。</p>
<p>map 的 key 重复出现的话被称为 <em>multimap</em></p>
<h2 id="iterators">Iterators</h2>
<p>它允许开发者迭代访问任何 containers</p>
<p>比如 <code>map.begin()</code>，它会返回一个 iterator，这个 iterator 指向第一个元素。就像这样：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">mymap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span></span></span></code></pre></div></div>
<p><code>++it</code> 会让这个 iterator 指向下一个元素。<code>*it</code> 可以访问这个 iterator 实际指向的值，这里也可以发现 iterator 和指针是差不多玩意。</p>
<p>map 的 iterator 和其他的 container 有些不同——因为 map 有两个值，它的 iterator 实际上是 <code>std::pair&lt;string, int&gt;</code></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">mymap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">mymap</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">thing</span> <span class="p">:</span> <span class="n">mymap</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">thing</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>在 vector 中，iterator 可以通过 <code>begin() + 3</code> 这样的方式挪动，但 <code>std::list</code> 等就不可以这么做，这是因为 container 的实现略有不同，但是 iterators 的实现就为了消除 containers 的区别从而用一种通用的方式调用 container。所以存在 5 种 iterator。</p>
<ol>
<li>Input</li>
<li>Output</li>
<li>Forward</li>
<li>Bidirectional</li>
<li>Random Access</li>
</ol>
<p>上述的这几种 iterator 都有上面所介绍的那些功能（<code>++it</code>什么的）</p>
<p>第一种 input iterator 只能被读，只能向前走，而且只能+1，比如 <code>find()</code> 或者 <code>count()</code> 这样的只需要遍历的地方中就会用到它，C++文档中也有描述：</p>
<p></p>
<p>Output iterator 和 input iterator 类似，只不过是只写的。<code>copy</code>这个函数会用到这个</p>
<p></p>
<p>Forward iterator 同时具有 output iterator 和 input iterator 的特点，即 RW 它都拿到了。<code>replace()</code> 函数会用到这个，还有就是之前 Sequence Containers 上提到的<code>std::foraword_list&lt;T&gt;</code></p>
<p></p>
<p>Bidirectional iterator 具有 Forward iterator 的功能，并且这个可以 <code>--</code>。在 <code>std::map</code>，<code>std::set</code>，<code>std::list</code>，或者<code>reverse()</code> 中会看到</p>
<p></p>
<p>Random access iterator 具有 Bidirectional iterator 的功能并且不受递增递减的约束，而是可以随意访问。在<code>std::vertor</code>，<code>std::string</code>，pointer 中都会使用它，所以这个是最常用的。</p>]]></description>
</item>
<item>
    <title>CS106L: Streams &amp; Type</title>
    <link>http://localhost:1313/posts/cs106l_stream_type/</link>
    <pubDate>Thu, 01 Feb 2024 03:42:51 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cs106l_stream_type/</guid>
    <description><![CDATA[<p>CS106L 中关于 Streams 和 type 的部分</p>
<h1 id="streams">Streams</h1>
<h2 id="string-stream">String Stream</h2>
<p>使用 Stream 缘于程序需要与外部资源交互。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ostringstream</span> <span class="n">oss</span><span class="p">(</span><span class="s">&#34;Ito En Green Tea&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="mf">16.9</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; Ounce &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>使用 g++ 编译并运行：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ g++ -std<span class="o">=</span>c++17 test.cpp -o <span class="nb">test</span>
</span></span><span class="line"><span class="cl">$ ./test
</span></span><span class="line"><span class="cl">Ito En Green Tea
</span></span><span class="line"><span class="cl">16.9 Ounce n Tea</span></span></code></pre></div></div>
<p>因为 stream 创建后，指针处于头部，所以写入的时候会从头部开始覆盖写入，如果给 <code>oss()</code> 传入其他参数可以控制这个模式，比如改成 <code>ostringstream oss(&quot;Ito En Green Tea&quot;, stringstream::ate);</code> 之后，指针会指向尾端。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-c">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">istringstream</span> <span class="nf">iss</span><span class="p">(</span><span class="n">oss</span><span class="p">.</span><span class="nf">str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">ammount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">struint</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">ammount</span> <span class="o">&gt;&gt;</span> <span class="n">struint</span><span class="p">;</span></span></span></code></pre></div></div>
<p><code>iss</code> 在输出的时候会根据空格分隔这个 stream。</p>
<p>对于移动 stream 指针的需求，可以使用下边这份代码：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-c">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ostringstream</span> <span class="nf">oss</span><span class="p">(</span><span class="s">&#34;Ito En Green Tea &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="mf">16.9</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">fpos</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">oss</span><span class="p">.</span><span class="nf">tellp</span><span class="p">()</span> <span class="o">+</span> <span class="nf">streamoff</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">oss</span><span class="p">.</span><span class="nf">seekp</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Black&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">oss</span><span class="p">.</span><span class="nf">good</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p><code>i/ostringstream</code> 都有快速的错误检查，分别为<code>good()</code>、<code>fail()</code>、<code>eof()</code>、<code>bad</code>。</p>
<ul>
<li>good: ready for read/write.</li>
<li>fail: previous operation failed, all future operation frozen.</li>
<li>eof: previous operation reached the end of buffer content.</li>
<li>bad: external error, likely irrecoverable.</li>
</ul>
<p><code>iss.good()</code> 就会返回一个 bool 表示该 stream 是否出错。类似：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">iss</span><span class="p">.</span><span class="n">fail</span><span class="p">())</span>  <span class="k">throw</span> <span class="n">domain_error</span><span class="p">(...);</span></span></span></code></pre></div></div>
<p>还有一种隐式转换成 bool 的写法会更简短，二者是等价的：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-c">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">ch</span><span class="p">))</span>  <span class="n">throw</span> <span class="nf">domain_error</span><span class="p">(...);</span></span></span></code></pre></div></div>
<p>比如一个将 string 转为 int 的函数可以这么写：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">stringToInteger</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">istringstream</span> <span class="n">iss</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">result</span><span class="p">;</span> <span class="kt">char</span> <span class="n">remain</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">)</span> <span class="o">||</span> <span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">remain</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="n">domain_error</span><span class="p">(...);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>什么时候应该使用 string stream</p>
<ul>
<li>处理字符串的时候</li>
<li>格式化输出或输入（一些 stream manipulators，比如 endl, hex, uppercase 之类的）</li>
<li>解析成不同的类型</li>
</ul>
<h2 id="input-stream--output-steam">Input stream &amp; Output steam</h2>
<ul>
<li>cin, standard input stream</li>
<li>cout, standard output stream (buffered)</li>
<li>cerr, standard error stream (unbuffered)</li>
<li>clog, standard error stream (buffered)</li>
</ul>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">home</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;What is your name?&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;What is your age?&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Where are you from?&#34;</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">home</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello, &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; (age &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; from &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">home</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;)&#34;</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></div></div>
<p>对于上面这段代码，如果你输入 Avery Wang，程序会直接走到终点：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ g++ -std<span class="o">=</span>c++17 -Wall test.cpp -o <span class="nb">test</span>
</span></span><span class="line"><span class="cl">$ ./test
</span></span><span class="line"><span class="cl">What is your name ?
</span></span><span class="line"><span class="cl">Avery Wang
</span></span><span class="line"><span class="cl">What is your age ?
</span></span><span class="line"><span class="cl">Where are you from ?
</span></span><span class="line"><span class="cl">Hello, Avery <span class="o">(</span>age <span class="m">0</span> from <span class="o">)</span></span></span></code></pre></div></div>
<p><code>cin</code> 会读到下一个空白符，所以第一个 <code>cin</code> 只会把 <code>Avery</code> 读进去，并且指针更新到了那个空白符的位置，之后 <code>cin &gt;&gt; age</code> 的时候，由于 buffer 不为空，所以会直接尝试把 <code>Wang</code> 读成 int，但是失败了，这时候 fail bit 打开，之后的 <code>cin</code> 也不会进行了。</p>
<p>这就是<code>cin</code>带来的问题了：</p>
<ol>
<li><code>cin</code> 会读一整行到 buufer 中，但是会用空格符分隔开递出。</li>
<li>buffer 中可能会有残余的数据导致用户无法及时地被提示应该输入</li>
<li><code>cin</code> fail 了之后就再也不会执行 <code>cin</code> 了</li>
</ol>
<p>如果使用<code>getline()</code>，就可以避免这个问题。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span></span></span></code></pre></div></div>
<p>第三个参数就是一个标记，<code>getline()</code> 会读到这个字符之前（也就是不包括这个字符），并把指针更新到这个字符之后。但如果你把第三个 <code>home</code> 变量的读取也改成了 <code>getline()</code> 读取，程序运行的时候会跳过它，因为 <code>cin &gt;&gt; age</code> 把指针更新到了 <code>\n</code> 之前，而 <code>getline()</code> 会直接读到 <code>\n</code> 之前（也就是空数据）。就像这样：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">A</td>
          <td style="text-align: center">v</td>
          <td style="text-align: center">e</td>
          <td style="text-align: center">r</td>
          <td style="text-align: center">y</td>
          <td style="text-align: center">_</td>
          <td style="text-align: center">W</td>
          <td style="text-align: center">a</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">g</td>
          <td style="text-align: center">\n</td>
          <td style="text-align: center">2</td>
          <td style="text-align: center">0</td>
          <td style="text-align: center">\n</td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>这里的<code>_</code>指的是空格符。</p>
<p>可以在第二个 <code>getline()</code> 之前加上一句 <code>cin.ignore()</code> 跳过一个字符（也就是<code>\n</code>）来解决这个问题。</p>
<p><code>std::cout</code> 是 <code>std::ostream</code> 定义的全局的 constant 对象，<code>std::ostream</code> 会将输入的数据类型都转成 string 并发送到 stream，而 <code>std::cout</code> 是会将这个 output stream 发送到 console 上。</p>
<p><code>std::cin</code> 是 <code>std::istream</code> 定义的全局 constant 对象。这里的 <code>&gt;&gt;</code> 会一直读取用户的输入直到 <em>whitespace</em>，这里的 whitespace 是指 Tab, space, newline。</p>
<h2 id="file-stream">File Stream</h2>
<p><code>std::ofstream</code>，只能用 <code>&lt;&lt;</code> 操作符传递数据，它会将数据类型转成 string 并发送到 file stream 上。</p>
<p><code>std::ifstream</code>，只能用 <code>&gt;&gt;</code> 操作符传递数据。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">out</span><span class="p">(</span><span class="s">&#34;out.txt&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// out is now an ofstream that outputs to out.txt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// out.txt contains 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">in</span><span class="p">(</span><span class="s">&#34;out.txt&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// in is now an ifstream that reads from out.txt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">in</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">;</span> <span class="c1">// first word in out.txt goes into str
</span></span></span></code></pre></div></div>
<hr>
<p>Uniform initialization: 使用大括号来初始化变量，适用于所有类型</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">numSuffix1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="s">&#34;st&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Student</span> <span class="n">s</span><span class="p">{</span><span class="s">&#34;Frankie&#34;</span><span class="p">,</span> <span class="s">&#34;MN&#34;</span><span class="p">,</span> <span class="mi">21</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">possible</span><span class="o">!</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span><span class="p">{</span><span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">f</span><span class="p">{</span><span class="s">&#34;Frankie&#34;</span><span class="p">};</span></span></span></code></pre></div></div>
<p>但要注意对 vector 大括号和括号之间的区别：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec1</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// makes {5, 5, 5}, not {3, 5}!
</span></span></span><span class="line"><span class="cl"><span class="c1">//uses a std::initializer_list (more later)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec2</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// makes {3, 5}
</span></span></span></code></pre></div></div>
<hr>
<h1 id="type">Type</h1>
<h2 id="type-alias">Type alias</h2>
<p>类型别名是一个很有用的东西，比如对于下边这样的代码：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">forward_list</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">unordered_set</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">studentMap</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">forward_list</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">unordered_set</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">end</span> <span class="o">=</span> <span class="n">studentMap</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span></span></span></code></pre></div></div>
<p>可以使用别名简化</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">map_iterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">forward_list</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">unordered_set</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">map_iterator</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">studentMap</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">map_iterator</span> <span class="n">end</span> <span class="o">=</span> <span class="n">studentMap</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span></span></span></code></pre></div></div>
<p>C++引入了 <code>auto</code> 关键字，<code>auto</code> 的本质是要让编译器找出这个类型。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">studentMap</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">studentMap</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span></span></span></code></pre></div></div>
<p>又比如这样：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">};</span></span></span></code></pre></div></div>
<p>这是一个 lamdba 函数，你并不知道这是什么类型，编译器会自动为此创建一个类的实例，由于开发者不知道编译器会为这个类起什么名字，所以需要用 <code>auto</code>。</p>
<h2 id="when-auto-should-be-used">When <code>auto</code> should be used</h2>
<p>AAA 原则： almost always auto</p>
<ul>
<li>在代码上下文清晰的时候使用<code>auto</code></li>
<li>当用确切的类型定义不重要的时候使用<code>auto</code></li>
<li>当严重破坏了可读性的时候不要使用<code>auto</code></li>
</ul>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">findPriceRange</span><span class="p">(</span><span class="kt">int</span> <span class="n">dist</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dist</span> <span class="o">*</span> <span class="mf">0.08</span> <span class="o">+</span> <span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dist</span> <span class="o">*</span> <span class="mf">0.36</span> <span class="o">+</span> <span class="mi">750</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">make_pair</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="mi">6452</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="p">[</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">]</span> <span class="o">=</span> <span class="n">findPriceRange</span><span class="p">(</span><span class="n">dist</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;You can find price between: &#34;</span>
</span></span><span class="line"><span class="cl">         <span class="o">&lt;&lt;</span> <span class="n">min</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; and &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">max</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>这样的代码更加的现代一些，<code>findPriceRange()</code> 函数只需要传一个参数<code>dist</code>，返回 <code>min</code> 和 <code>max</code> 的 pair，这样也更加自然（对比传入三个参数：dist, min, max）。</p>
<p>像上面这个代码寻找区间的代码写成库函数给开发者调用的话是很不友好的，因为返回值没有做出更好的区分表明到底谁是 min，谁是 max，这时候可以使用结构体来对返回值进行一层抽象。不过在 C++中，结构体定义变量的时候 <code>struct</code> 关键字是可选的，比如：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Student</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Student</span> <span class="n">st</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;age: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, number: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></div></div>
<p>在 C 中，这需要<code>typedef</code>才能实现</p>
<p>Structured binding：一次性将复合类型变量的元素取值操作完成</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="err">“</span><span class="n">s</span><span class="err">”</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">;</span></span></span></code></pre></div></div>
<p>使用了 Structured binding 就可以写成下边这样：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="err">“</span><span class="n">s</span><span class="err">”</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span></span></span></code></pre></div></div>
<p>C++ 默认赋值是 copy 的，如果函数传参涉及修改原数据应该用 <code>&amp;</code> 引用，如果在其函数内部会出现对这种参数的赋值，也需要加 <code>&amp;</code> ：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">shift</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">num1</span><span class="p">,</span> <span class="n">num2</span><span class="p">]</span><span class="o">:</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">num1</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">num2</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>]]></description>
</item>
</channel>
</rss>
