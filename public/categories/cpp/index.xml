<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Cpp - Category - 索元的博客</title>
        <link>http://localhost:1313/categories/cpp/</link>
        <description>Cpp - Category - 索元的博客</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>s5n666@outlook.com (suo yuan)</managingEditor>
            <webMaster>s5n666@outlook.com (suo yuan)</webMaster><lastBuildDate>Thu, 24 Oct 2024 01:49:02 &#43;0000</lastBuildDate><atom:link href="http://localhost:1313/categories/cpp/" rel="self" type="application/rss+xml" /><item>
    <title>译文: C&#43;&#43; 对象的生命周期</title>
    <link>http://localhost:1313/posts/cpp_object_life/</link>
    <pubDate>Thu, 24 Oct 2024 01:49:02 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cpp_object_life/</guid>
    <description><![CDATA[<h1 id="译文-c-对象的生命周期">译文: C++ 对象的生命周期</h1>
<hr>
<p>本篇为 <a href="https://basit.pro/cpp-object-lifecycle/" target="_blank" rel="noopener noreffer ">https://basit.pro/cpp-object-lifecycle/</a> 的译文</p>
<p>如果文章作者介意翻译转载，需要删除掉，可以选择以一些我能看到的方式（如评论）告知我</p>
<hr>
<p>关于 RAII/C++ 的大多数讨论都没涉及到维持对象存在所需的隐含条件。在实现自定义的容器，以及内存分配器和 &ldquo;tag discriminated unions&rdquo; 的时候就需要这些隐含条件(如 <a href="https://github.com/lamarrr/ashura/blob/ec183d8cb6109c263e5b6b0f070079bf3db65230/ashura/std/result.h#L29" target="_blank" rel="noopener noreffer "><code>Result&lt;T, E&gt;</code></a>, <a href="https://github.com/lamarrr/ashura/blob/ec183d8cb6109c263e5b6b0f070079bf3db65230/ashura/std/option.h#L25" target="_blank" rel="noopener noreffer "><code>Option&lt;T&gt;</code></a>, <a href="https://en.cppreference.com/w/cpp/utility/variant" target="_blank" rel="noopener noreffer "><code>std::variant&lt;T...&gt;</code></a>)</p>
<hr>
<p>译者注:</p>
<p>tag discriminated unions 指的是使用一个 tag 区分联合体中的类型。<code>std::variant</code> 就是一个类型安全的联合体</p>
<blockquote>
<p>一个 std::variant 的实例在任意时刻要么保有它的可选类型之一的值，要么在错误情况下无值</p>
</blockquote>
<hr>
<p>这些通常被称为“不安全”操作，因为它们确实需要了解对象生命周期不变量或生命周期。我假设您对汇编有一定的了解，因为如果没有它们，就很难理解本文中的一些操作</p>
<p><strong>NOTE</strong>: 我们不会讨论异常，也不会讨论极端情况、不必要的复杂性、code path explosions 以及它们引入的限制</p>
<p>C++对象的生命周期如下所示:</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-txt">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">  allocate placement memory
</span></span><span class="line"><span class="cl">             ||
</span></span><span class="line"><span class="cl">             ||                     ============
</span></span><span class="line"><span class="cl">             \/                     ||        ||
</span></span><span class="line"><span class="cl">====&gt;  construct object  ===&gt; assign object &lt;===
</span></span><span class="line"><span class="cl">||           ||                     ||
</span></span><span class="line"><span class="cl">||           \/                     ||
</span></span><span class="line"><span class="cl">====== destruct object  &lt;=============
</span></span><span class="line"><span class="cl">             ||
</span></span><span class="line"><span class="cl">             \/
</span></span><span class="line"><span class="cl"> deallocate placement memory</span></span></code></pre></div></div>
<p>违反此生命周期将导致 <strong>未定义的行为</strong> ，通常是: 内存泄漏、double-free、未初始化的内存上的读/写、未对齐的读/写、nullptr 取消引用、越界读/写等</p>
<p>我用于测试容器中生命周期违规的经验法则是确保构造数量等于破坏数量。我们将用于演示其中一些概念的类型定义如下:</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Counter</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">num_constructs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">num_destructs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">log</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;num_constructs = %&#34;</span> <span class="n">PRIu32</span> <span class="s">&#34; </span><span class="se">\n</span><span class="s">num_destructs =  %&#34;</span> <span class="n">PRIu32</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">               <span class="n">num_constructs</span><span class="p">,</span> <span class="n">num_destructs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">counter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Obj</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// default-construction
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Obj</span><span class="p">()</span> <span class="p">{</span> <span class="n">counter</span><span class="p">.</span><span class="n">num_constructs</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// copy-construction
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Obj</span><span class="p">(</span><span class="n">Obj</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">{</span><span class="n">t</span><span class="p">.</span><span class="n">data</span><span class="p">}</span> <span class="p">{</span> <span class="n">counter</span><span class="p">.</span><span class="n">num_constructs</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// move-construction
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Obj</span><span class="p">(</span><span class="n">Obj</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">{</span><span class="n">t</span><span class="p">.</span><span class="n">data</span><span class="p">}</span> <span class="p">{</span> <span class="n">counter</span><span class="p">.</span><span class="n">num_constructs</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// copy-assignment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Obj</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Obj</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// move-assignment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Obj</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Obj</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// destruction
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">~</span><span class="n">Obj</span><span class="p">()</span> <span class="p">{</span> <span class="n">counter</span><span class="p">.</span><span class="n">num_destructs</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div></div>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Animal</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">react</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Cat</span> <span class="o">:</span> <span class="n">Animal</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">react</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&#34;purr...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Dog</span> <span class="o">:</span> <span class="n">Animal</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">react</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&#34;woof!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div></div>
<p><strong>内存分配</strong></p>
<p>一个对象的内存可能来自于栈(例如 <code>alloca</code>, <code>malloca</code>)或者堆(例如 <code>sbrk</code>, <code>malloc</code>, <code>kalloc</code>)。对于放在这里的对象存在一些基本要求:</p>
<ul>
<li>成功分配后，分配器返回的内存必须是有效且尚未被使用过的。否则会存在 double-free 问题。</li>
</ul>
<p><strong>SEE</strong>: GCC 的 <a href="https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html" target="_blank" rel="noopener noreffer "><code>__attribute__((malloc(...)))</code></a> 和 MSVC 的 <a href="https://learn.microsoft.com/en-us/cpp/cpp/restrict?view=msvc-170" target="_blank" rel="noopener noreffer "><code>__restrict</code></a> 可以为编译器的可达性分析启用全局 aliasing 优化。</p>
<hr>
<p>译者注:</p>
<p>这二位都是用于表明该对象指向一个单独的内存，当编译器知道指针不会指向相同的区域时，可以做一些更加激进的优化，也就是所谓的 aliasing 优化。</p>
<p>对于 aliasing 优化来说，GCC 的 <code>O2</code> 优化就会默认启用一些。</p>
<p>aliasing 后续会被译为别名</p>
<hr>
<p><strong>NOTE</strong>: <code>malloc(0)</code> 和 <code>realloc(ptr, 0, 0)</code> 不需要返回 <code>nullptr</code>，并且是实现定义行为。实现可能会决定为 0 大小的分配返回相同或不同的非空（可能是 sentinel）内存地址。</p>
<ul>
<li>通用分配器 <strong>应该</strong> 至少支持 <code>alignof(max_align_t)</code> 的对齐，其中 <a href="https://en.cppreference.com/w/c/types/max_align_t" target="_blank" rel="noopener noreffer "><code>max_align_t</code></a> 大多是 <code>double</code>（8字节）或 <code>long double</code>（16字节），就像 <code>malloc</code> 的情况一样。 <code>max_align_t</code> 是最大对齐整型标量类型。</li>
</ul>
<p><strong>NOTE</strong>: C11 引入了<code>aligned_alloc</code> 用于 over-aligned allocations (超出 <code>alignof(max_align_t)</code> )，这通常是 <code>SIMD</code> 向量操作 (<code>SSE/AVX</code> 的128 位、256 位和 512 位扩展)所必需的，因为 <code>SIMD</code> 的宽寄存器运行于 over-aligned memory addresses。 MSVC 的 C 运行时尚不支持 <code>aligned_alloc</code> ，但提供 <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/aligned-malloc?view=msvc-170" target="_blank" rel="noopener noreffer "><code>_aligned_malloc</code></a> 和 <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/aligned-free?view=msvc-170" target="_blank" rel="noopener noreffer "><code>_aligned_free</code></a>。</p>
<h2 id="构造对象">构造对象</h2>
<p>这是对象生命周期开始的地方。对于 non-trivially 可构造类型，这意味着在放置内存上放置新对象；对于 trivially 可构造类型，这意味着在对象放置内存上进行任何内存写入操作</p>
<p>对象的放置内存地址的大小 <strong>必须</strong> 至少为对象的大小，并且内存中的对象放置地址 <strong>必须</strong> 与对象对齐的倍数对齐。如果在大小不合适的内存位置构造对象，则可能导致未定义的行为(越界读取)。不适当对齐的放置内存可能会导致未对齐的读写(未定义的行为，在某些 CPU 架构上可能会因 <code>SIGILL</code> 导致应用程序崩溃或导致性能下降)。读取未初始化/未构造的对象是未定义的行为并且是灾难性的</p>
<p>Placement-new 有一些重要的目的：</p>
<ul>
<li>初始化虚拟(基类和继承的)类的虚函数调度表(简单的构造，即 <code>memset</code> 或 <code>memcpy</code> 是不够的)</li>
<li>初始化类/结构、其基类及其成员</li>
</ul>
<p>让我们看看实际案例:</p>
<p><a href="https://godbolt.org/z/fq9KdP1eo" target="_blank" rel="noopener noreffer ">Godbolt</a></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">++</span><span class="p">;</span> <span class="c1">// undefined behavior
</span></span></span></code></pre></div></div>
<p>上面的代码由于未初始化地读取内存 x 处的 <code>int</code> 而引发了未定义的行为。启用优化后，编译器可以主动决定忽略增量操作</p>
<p>fix:</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">++</span><span class="p">;</span></span></span></code></pre></div></div>
<p>因为 <code>int</code> 是一个 trivially 的可构造类型(即没有特殊的构造语义)，没有不变量，所以它可以通过写入内存地址来简单地构造，并且 <code>int</code> “对象”将隐式存在于内存地址 x 处。要在地址 x 构造一个 <code>int</code> 或普通可构造对象，您还可以使用：</p>
<ul>
<li>placement new</li>
<li>memcpy/memmove</li>
<li>memset/memset_explicit</li>
</ul>
<p>现在，让我们看一下具有更复杂构造语义 (non-trivially-constructible) 的类型:</p>
<p><a href="https://godbolt.org/z/Kn3bccore" target="_blank" rel="noopener noreffer ">Godbolt</a></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Obj</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">Obj</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Obj</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">obj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">++</span><span class="p">;</span> <span class="c1">// undefined behavior, data is random value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;data: %&#34;</span> <span class="n">PRIu32</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">counter</span><span class="p">.</span><span class="n">log</span><span class="p">();</span> <span class="c1">// num_constructs = 0, num_destructs = 0
</span></span></span></code></pre></div></div>
<p>从上面的日志中，您可以看到对象从未在地址 obj 处构造，因此，obj 处尚不存在 Obj 类型的对象，并且在该状态下使用/销毁该对象是未定义的行为。这可能会导致许多违反合同/未定义的行为，例如双重释放、越界读/写。</p>
<p>fix:</p>
<p><a href="https://godbolt.org/z/1M58e85Mh" target="_blank" rel="noopener noreffer ">Godbolt</a></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Obj</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">Obj</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Obj</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="n">Obj</span><span class="p">{};</span>  <span class="c1">// constructs object of type Obj at the address
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// ok: data is increased from default value of 1 to 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;data: %&#34;</span> <span class="n">PRIu32</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">counter</span><span class="p">.</span><span class="n">log</span><span class="p">();</span>  <span class="c1">// num_constructs = 1, num_destructs = 0
</span></span></span></code></pre></div></div>
<p>placement new 在地址 obj 处构造了 Obj 类型的对象，现在包含有效的成员数据</p>
<p>Placement-new 还用于初始化虚函数表指针，使对象可在 virtual dispatch 中使用。如果某个对象不是使用 Placement-new 构造的，则编译器的可达性分析<strong>可能</strong>会判定该对象在内存地址中不存在，从而调用未定义的行为。举例说明：</p>
<p><a href="https://godbolt.org/z/aMMGe1n8o" target="_blank" rel="noopener noreffer ">Godbolt</a></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Cat</span> <span class="o">*</span> <span class="n">cat</span> <span class="o">=</span> <span class="p">(</span><span class="n">Cat</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Cat</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">memset</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Cat</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">cat</span><span class="o">-&gt;</span><span class="n">react</span><span class="p">();</span> <span class="c1">// static dispatches to Cat::react()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Animal</span> <span class="o">*</span> <span class="n">animal</span> <span class="o">=</span> <span class="n">cat</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">animal</span><span class="o">-&gt;</span><span class="n">react</span><span class="p">();</span> <span class="c1">// undefined behavior
</span></span></span></code></pre></div></div>
<p>调用 <code>cat-&gt;react()</code>，通过静态调度正确调用 <code>Cat::react</code>。然而，通过类型擦除的调用 <code>Animal-&gt;react()</code> 从其基类方法 <code>Animal::react</code> dynamic dispatch，编译器<strong>可以</strong>决定简单地删除/忽略它，因为它是未定义的行为(调用空函数指针)，如果在调试模式下或编译器的可达性分析无法看到 <code>memset</code>，则可能会导致 segmentation fault</p>
<p>为了检查为什么会发生这种情况，让我们看一下使用自定义 dynamic dispatch/v-table 来实现虚类:</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Animal</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">react</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Cat</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Animal</span> <span class="n">animal</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">react</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">react</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"> <span class="k">static</span> <span class="kt">void</span> <span class="nf">react</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div></div>
<p>为了发生 virtual dispatchl，需要调用函数指针 <code>Animal::react</code>，但在前面的示例中，<code>Animal::react</code> 会被 <code>memset</code> 调用初始化为 0，当 <code>Animal-&gt;react()</code> 时，这是未定义的行为调用</p>
<p>为了修复前面的示例，我们需要通过 Placement-new 调用正确初始化实现定义的虚函数调度表，即：</p>
<p><a href="https://godbolt.org/z/z3rds6hPc" target="_blank" rel="noopener noreffer ">Godbolt</a></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Cat</span> <span class="o">*</span> <span class="n">cat</span> <span class="o">=</span> <span class="p">(</span><span class="n">Cat</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Cat</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="p">(</span><span class="n">cat</span><span class="p">)</span> <span class="n">Cat</span><span class="p">{};</span> <span class="c1">// initializes v-table
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cat</span><span class="o">-&gt;</span><span class="n">react</span><span class="p">();</span> <span class="c1">// static dispatches to Cat::react()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Animal</span> <span class="o">*</span> <span class="n">animal</span> <span class="o">=</span> <span class="n">cat</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">animal</span><span class="o">-&gt;</span><span class="n">react</span><span class="p">();</span> <span class="c1">// OK
</span></span></span></code></pre></div></div>
<p>虚函数调用 <code>animal-&gt;react()</code> 现在可以正确分派到 <code>Cat::react</code></p>
<p><strong>NOTE</strong>: C++ 标准没有指定如何实现 virtual dispatch/虚函数表，因此没有可移植的方法来可靠地操作运行时的虚函数表。</p>
<p>复制和移动构造意味着源地址已经用对象构造，并且目标地址是包含需要初始化的未初始化对象/内存的暂存存储器。请注意，复制和移动构造<strong>不应</strong>调用源对象或目标对象的析构函数</p>
<p>对象构造也分为几类，即：</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/types/is_constructible" target="_blank" rel="noopener noreffer ">non-trivial construction</a></li>
<li><a href="https://en.cppreference.com/w/cpp/types/is_copy_constructible" target="_blank" rel="noopener noreffer ">non-trivial copy construction</a></li>
<li><a href="https://en.cppreference.com/w/cpp/types/is_move_constructible" target="_blank" rel="noopener noreffer ">non-trivial move construction</a></li>
<li><a href="https://en.cppreference.com/w/cpp/types/is_constructible" target="_blank" rel="noopener noreffer ">trivial construction</a></li>
<li><a href="https://en.cppreference.com/w/cpp/types/is_copy_constructible" target="_blank" rel="noopener noreffer ">trivial copy construction</a></li>
<li><a href="https://en.cppreference.com/w/cpp/types/is_move_constructible" target="_blank" rel="noopener noreffer ">trivial move construction</a></li>
</ul>
<h2 id="分配对象">分配对象</h2>
<p>复制和移动分配要求内存地址处已经存在一个对象，并且我们想为其分配另一个对象。这意味着源地址和目标地址都包含有效的初始化对象。对象分配分为几类，即：</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/types/is_copy_assignable" target="_blank" rel="noopener noreffer ">copy assignment (T&amp; operator=(U const&amp;))</a></li>
<li><a href="https://en.cppreference.com/w/cpp/types/is_move_assignable" target="_blank" rel="noopener noreffer ">move assignment (T&amp; operator=(U &amp;&amp;))</a></li>
<li><a href="https://en.cppreference.com/w/cpp/types/is_copy_assignable" target="_blank" rel="noopener noreffer ">trivial copy assignment</a></li>
<li><a href="https://en.cppreference.com/w/cpp/types/is_move_assignable" target="_blank" rel="noopener noreffer ">trivial move assignment</a></li>
</ul>
<p>trivial 赋值意味着可以将对象分配给另一个对象而无需特殊操作，这意味着它可以按字节复制，即通过 <code>memcpy</code> 或 <code>memmove</code></p>
<h2 id="销毁对象">销毁对象</h2>
<p>销毁要求内存位置存在有效的对象。销毁内存地址处的对象意味着该内存地址处将不存在任何对象，并且内存处于未初始化状态</p>
<p>不同于 trivial 对象的构造和分配，trivial 的销毁没什么操作</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/types/is_destructible" target="_blank" rel="noopener noreffer ">non-trivial destruction (~T())</a></li>
<li><a href="https://en.cppreference.com/w/cpp/types/is_destructible" target="_blank" rel="noopener noreffer ">trivial destruction</a></li>
</ul>
<h2 id="释放内存">释放内存</h2>
<p>释放内存要求放置内存上的任何对象都已被销毁。内存返回到其分配器，并且<strong>不应</strong>再被引用或使用</p>
<h2 id="应用">应用</h2>
<h3 id="strict-aliasing-dead-store-and-dead-load-optimizations">Strict Aliasing, Dead-store, and Dead-load Optimizations</h3>
<p>Strict aliasing 是一个很重要的假设，它可以启用被称为 dead-load 和 dead-store 的编译器优化</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="n">get_A</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span> <span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">get_B</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span></span></span></code></pre></div></div>
<p>在这里，我们首先写入 <code>a</code>，然后写入 <code>b</code>，考虑到 <code>a</code> 可能是 <code>b</code> 的 <code>reinterpret_cast</code>，那么我们就不能假设 <code>a</code> 的值仍然是 <code>6</code>，因为有可能两者都指向相同或不同的对象。虽然这种规模的影响并不明显，但当编译器的可达性分析无法证明它们是不同的对象时，它就会变得难绷</p>
<p>按照规则来说，类型 A 不能别名（reinterpret_cast）类型 B，那么我们总是可以执行优化并假设两个对象不同，因此无法从类型 A 观察到类型 B 的突变</p>
<p>然而，我们仍然需要一个后门，以防我们需要按字节从 <code>a</code> 复制到 <code>b</code>，规则的例外是 <code>char</code>、<code>unsigned char</code> 和 <code>signed char</code> 可以别名任何对象，否则由 <a href="https://en.cppreference.com/w/cpp/numeric/bit_cast" target="_blank" rel="noopener noreffer "><code>std::bit_cast</code></a> 封装，这意味着我们可以为 <code>char</code>、<code>unsigned char</code> 或<code>signed char</code> 中的任何类型的任何对象设置别名，这称为 <a href="https://gist.github.com/shafik/848ae25ee209f698763cffee272a58f8" target="_blank" rel="noopener noreffer ">strict aliasing 规则</a></p>
<p>为了说明 strict aliasing 规则，让我们看看生成的汇编代码:</p>
<p><a href="https://godbolt.org/z/M18z53b35" target="_blank" rel="noopener noreffer ">Godbolt</a></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">A</span> <span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="n">get_A</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span> <span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">get_B</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span></span></span></code></pre></div></div>
<p>从上面的示例中我们可以看到，编译器能够对表达式 <code>a-&gt;value</code> 执行 dead-load 优化，并且只假设该值保持为 6，如果 <code>a</code> 可以别名 <code>b</code>，那这就是不可能的</p>
<p>然而，如果我们真的需要为这两种类型起别名，我们可以使用名称奇怪的函数 <a href="https://en.cppreference.com/w/cpp/utility/launder" target="_blank" rel="noopener noreffer "><code>std::launder</code></a> ，这会干扰编译器的可达性分析</p>
<p><a href="https://godbolt.org/z/8rM6YbM75" target="_blank" rel="noopener noreffer ">Godbolt</a></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">A</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="n">get_A</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">get_B</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="o">*</span> <span class="n">a_b</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">launder</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">((</span><span class="n">B</span><span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">a_b</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span></span></span></code></pre></div></div>
<p>从生成的汇编代码中，编译器被迫从 <code>a_b</code> 执行冗余加载，因为它可能是 <code>b</code> 的别名，因为它的起源已被 <code>std::launder</code> 隐藏。这就像洗钱一样，因此得名:)</p>
<p><strong>NOTE</strong>: 这里使用 <code>std::launder</code> 是未定义的行为，因为不存在类型 B 的对象，也没有在地址 <code>a</code> 处构造该对象</p>
<p>一些语言/方言在可变性和别名方面有一种更激进的别名优化/规则，即 Rust 的可变引用 (&amp; mut) 和 <a href="https://github.com/seanbaxter/circle" target="_blank" rel="noopener noreffer "><code>Circle</code></a> 的可变引用，它只需要一次将一个可变引用绑定到一个对象，这允许即使在一个范围内的相同类型的对象之间，也存在更具争议性和激进的优化。这与非标准限制限定符 (GCC/Clang：<code>__restrict__</code> 和 MSVC：<code>__restrict</code>)相当</p>
<p>举例说明:</p>
<p><a href="https://godbolt.org/z/ahd6xT8Gx" target="_blank" rel="noopener noreffer ">Godbolt</a></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">fn</span><span class="p">(</span><span class="n">A</span><span class="o">*</span> <span class="n">a1</span><span class="p">,</span> <span class="n">A</span><span class="o">*</span> <span class="n">a2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a1</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">a2</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a1</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>正如我们之前所说，<code>a1</code> 可以与 <code>a2</code> 别名/重叠，因为它们是相同的类型，并且即使在相同类型内，也没有关于可变性的限制，因此读取表达式 <code>a1-&gt;value</code> 不会被优化，我们仍然需要加载值，如果我们可以确定对象实际上没有别名/重叠，那么这将是多余的。虽然这种影响在小对象上可能不会被注意到，但由于数据依赖性，它在多个元素的数组上会很明显，并导致性能急剧下降</p>
<p>为了优化这一点，我们将使用 restrict 属性，这意味着具有 attribute/qualifier 的对象不会为该范围内的其他对象别名。</p>
<p><a href="https://godbolt.org/z/TK94KjTjx" target="_blank" rel="noopener noreffer ">Godbolt</a></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">fn</span><span class="p">(</span><span class="n">A</span><span class="o">*</span> <span class="n">RESTRICT</span> <span class="n">a1</span><span class="p">,</span> <span class="n">A</span><span class="o">*</span> <span class="n">RESTRICT</span> <span class="n">a2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a1</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">a2</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a1</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<h2 id="union">Union</h2>
<p>虽然大多数“modern C++”代码库会由于联合体的约束困难或使用它们很容易产生错误而完全禁止联合体，但它们仍然是许多数据结构(如 <code>Option&lt;T&gt;</code>、<code>Result&lt;T, E&gt;</code>) 的重要组成部分</p>
<p>联合用于多个对象之一可以存在于一个位置的情况。有效地为受约束的对象动态性/多态性提供空间</p>
<p>鉴于联合地址中只能存在一个对象，对象生命周期规则仍然适用，违反该规则将导致未定义的行为:</p>
<ul>
<li>union 中必须至少存在一个指定的变体</li>
<li>任何访问的对象都必须已被构造</li>
<li>在某个时间点，union 中只能存在或构造一个对象，要在 union 中构造另一个对象，必须先销毁先前构造的对象。</li>
</ul>
<p>尽管 Union 中的变体类型可能存在别名，但 strict aliasing 规则仍然适用于它们，即变体类型 A 不能为不同的变体类型 B 起别名</p>
<p><a href="https://godbolt.org/z/jYMozMnTx" target="_blank" rel="noopener noreffer ">Godbolt</a></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">union</span> <span class="nc">Which</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Cat</span> <span class="n">cat</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">react</span><span class="p">(</span><span class="n">Animal</span><span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">react</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Which</span> <span class="n">w</span><span class="p">;</span>  <span class="c1">// only c is initialized
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">react</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="p">.</span><span class="n">cat</span><span class="p">);</span>  <span class="c1">// SISGSEGV because we accessed `cat` without initializing it
</span></span></span></code></pre></div></div>
<p>fix:</p>
<p><a href="https://godbolt.org/z/7G8s7vTP9" target="_blank" rel="noopener noreffer ">Godbolt</a></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Which</span> <span class="n">w</span><span class="p">;</span>  <span class="c1">// only c is initialized
</span></span></span><span class="line"><span class="cl"><span class="c1">// w.c.~char() - trivial, but char doesn&#39;t have a destructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="p">.</span><span class="n">cat</span><span class="p">)</span> <span class="n">Cat</span><span class="p">{};</span>  <span class="c1">// now cat is initialized, we can access it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">react</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="p">.</span><span class="n">cat</span><span class="p">);</span>       <span class="c1">// purr...
</span></span></span></code></pre></div></div>
<p>正如您在上面的示例中看到的，我们不能简单地假装使用 union 的其他变体，我们需要维护对象生命周期，首先删除 <code>c</code> (在本例中很简单，因此无操作)，然后使用构造 <code>cat</code> 放置 <code>new</code> (重要)，它将通过初始化 Cat 对象的 v-table 来解决 UB</p>
<p>对于认为 C++ 联合体功能与 C 类似的 C 开发人员来说，这是一种常见的做法。另请注意，如果联合包含 non-trivial 类型，则需要手动且显式地实现构造、销毁、赋值和移动操作</p>
<h2 id="stdaligned_storage-c-23-已弃用"><code>std::aligned_storage</code> (C++ 23 已弃用)</h2>
<p>对齐存储意味着对象的按字节表示，对象的生命周期上下文在外部管理或由外部事实源确定，因此仍然需要用户显式且正确地管理所表示对象的生命周期，它们可以工作与 <code>union</code> 类似，但需要注意的是它们是非类型化的</p>
<p>对齐存储通常用于实现容器类型，特别是在包含已初始化和未初始化对象时，例如: Open-Addressing (Linear-Probing Hashmaps), (ECS) Sparse Sets, Static-Capacity Vectors, Stack-allocated vectors, pre-allocated/bump/arena allocators</p>
<p><strong>NOTE</strong>: <code>std::aligned_storage</code> 在 <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1413r3.pdf" target="_blank" rel="noopener noreffer ">C++ 23 (P1413R3)</a> 被删除</p>
<h2 id="optiont-stdoptionalt"><code>Option&lt;T&gt;</code> (<code>std::optional&lt;T&gt;</code>)</h2>
<p><code>Option&lt;T&gt;</code> 意味着类型 <code>T</code> 的对象可能存在也可能不存在，这意味着该对象可能初始化或者未初始化，并且其存在由有区别的枚举/布尔值识别。实现 <code>Option&lt;T&gt;</code> 需要正确维护值类型 <code>T</code> 的生命周期。即构造次数与销毁次数相同，对象的构造函数在被视为存在于选项中之前被调用</p>
<h2 id="resultt-e-stdexpectedt-e"><code>Result&lt;T, E&gt;</code> (<code>std::expected&lt;T, E&gt;</code>)</h2>
<p><code>Result&lt;T, E&gt;</code> 暗示 <code>Result</code> 的放置地址处存在类型 <code>T</code> 或类型 <code>E</code> 的对象，它通过枚举或布尔值进行区分。就像 <code>Option&lt;T&gt;</code> 一样，<code>Result&lt;T, E&gt;</code> 维护值类型 <code>T</code> 和 <code>E</code> 的生命周期</p>
<h2 id="trivial-relocation">Trivial Relocation</h2>
<p>Trivial 重定位是即将推出的 C++ 26 功能，我最兴奋的是它进一步扩展了 C++ 对象生命周期，并为进一步优化提供了空间</p>
<p>重定位是从源对象移动到未初始化目标以及破坏源中留下的对象表示的组合(破坏性 move)</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">relocate</span><span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="n">A</span> <span class="o">*</span> <span class="n">dst</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">new</span> <span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="n">A</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">src</span><span class="o">-&gt;~</span><span class="n">A</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>Trivial 重定位意味着可以将对象安全地从一个内存地址移动到另一个未初始化的内存地址，而无需调用对象的移动构造函数和析构函数，本质上捕获“移动到目标并销毁源”操作。这意味着我们可以使用逐位复制，通常通过 <code>memcpy</code> 或 <code>memmove</code>，本质上是“微不足道的”，只要我们在重定位后不将源内存地址视为包含有效对象即可</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">trivial_relocate</span><span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="n">A</span> <span class="o">*</span> <span class="n">dst</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">A</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>请注意，trivial 重定位并不总是意味着移动构造函数和析构函数是 trivial</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">MyStr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span><span class="o">*</span> <span class="n">data_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="n">size_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyStr</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyStr</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">num</span><span class="p">)</span> <span class="o">:</span> <span class="n">data_</span><span class="p">{(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">num</span><span class="p">)},</span> <span class="n">size_</span><span class="p">{</span><span class="n">num</span><span class="p">}</span> <span class="p">{</span> <span class="n">memcpy</span><span class="p">(</span><span class="n">data_</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyStr</span><span class="p">(</span><span class="n">MyStr</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyStr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MyStr</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyStr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MyStr</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyStr</span><span class="p">(</span><span class="n">MyStr</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">data_</span><span class="p">{</span><span class="n">a</span><span class="p">.</span><span class="n">data_</span><span class="p">},</span> <span class="n">size_</span><span class="p">{</span><span class="n">a</span><span class="p">.</span><span class="n">size_</span><span class="p">}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span><span class="p">.</span><span class="n">data_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span><span class="p">.</span><span class="n">size_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">MyStr</span><span class="p">()</span> <span class="p">{</span> <span class="n">free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div></div>
<p><code>MyStr</code> 与许多容器类型一样，没有 trivial 的移动构造函数和析构函数，但它们的对象表示可以轻松地重新定位</p>
<p>对于本地包含的小型对象，non-trivial 重定位可能不会对性能产生太大影响，因为编译器通常能够优化移动构造函数和析构函数生成的代码，但对于实现像 <code>std::vector</code> 这样的通用容器类型，其中这些对象中的一些经常被移动(即在 <code>push_back</code>、<code>insert</code>、将元素从一个容器移动到另一个容器期间)，trivial 重定位 (<code>memcpy</code>/<code>memmove</code>) 会比执行会产生冗余操作的 non-trivial 的移动构造函数和析构函数执行得更好，就像将 <code>MyStr::num_</code> 设置为 <code>nullptr</code> 并将 <code>MyStr::size_</code> 设置为 <code>0</code> (如 <code>MyStr::MyStr(Mystr &amp;&amp;)</code>的 <code>std::vector&lt;MyStr&gt;</code> 中所示)。这是 C++ 对象模型要求移动构造函数将源对象保留在 valid 但未指定状态以便析构函数仍然正确运行的结果</p>
<p>另请注意，如果您的分配器支持 <code>realloc</code>，则 trivial 的重定位意味着增加向量类型的容量可能会分解为 zero-cost <code>realloc</code>(如果页面内有足够的空间，操作系统通常只需要扩展分配的条目)而不是分配一个新的单独内存，将对象移动到该内存，销毁源内存中的残留对象，然后释放源内存</p>
<p>Trivial 的重定位会将我们的 C++ 对象生命周期模型扩展到:</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-txt">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">  allocate placement memory
</span></span><span class="line"><span class="cl">             ||
</span></span><span class="line"><span class="cl">             ||
</span></span><span class="line"><span class="cl">             ||   =============================&gt; relocate object
</span></span><span class="line"><span class="cl">             ||   ||                                   ||
</span></span><span class="line"><span class="cl">             ||   ||               ============        ||
</span></span><span class="line"><span class="cl">             \/   ||               ||        ||        ||
</span></span><span class="line"><span class="cl">====&gt;  construct object ===&gt; assign object &lt;===        ||
</span></span><span class="line"><span class="cl">||           ||                    ||                  ||
</span></span><span class="line"><span class="cl">||           \/                    ||                  ||
</span></span><span class="line"><span class="cl">====== destruct object  &lt;============                  ||
</span></span><span class="line"><span class="cl">             ||                                        ||
</span></span><span class="line"><span class="cl">             \/                                        ||
</span></span><span class="line"><span class="cl"> deallocate placement memory &lt;===========================</span></span></code></pre></div></div>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2786r0.pdf" target="_blank" rel="noopener noreffer ">P2786R0: Trivial relocatability options, Proposal for an alternative approach to trivial relocatability</a></li>
<li><a href="https://quuxplusone.github.io/blog/2023/03/03/relocate-algorithm-design/" target="_blank" rel="noopener noreffer ">STL algorithms for trivial relocation</a></li>
<li><a href="https://www.youtube.com/watch?v=DZ0maTWD_9g" target="_blank" rel="noopener noreffer ">C++ Trivial Relocation Through Time - Mungo Gill - ACCU 2023</a></li>
</ul>
]]></description>
</item>
<item>
    <title>C&#43;&#43; 项目编写初步入门</title>
    <link>http://localhost:1313/posts/cmake_intro/</link>
    <pubDate>Sun, 12 May 2024 14:23:43 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cmake_intro/</guid>
    <description><![CDATA[<p>我第一次尝试使用 CMake 等工具管理自己的 C++ 项目的记录</p>
<h1 id="c-项目编写初步入门">C++ 项目编写初步入门</h1>
<p>由于想要编写一个 C++ 的项目，所以开始学习 <code>cmake</code> 管理项目的编译工作。我这里会把 <strong>src</strong> 和 <strong>include</strong> 分开，并且尝试使用<a href="https://github.com/google/googletest" target="_blank" rel="noopener noreffer ">Google test</a>做一些项目的简单测试。</p>
<p>并且我尝试使用 <code>clang-tidy</code> 和 <code>clang-format</code> 格式化我的代码，<code>doxygen</code> 生成项目 API 文档。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ tree -a -L <span class="m">2</span>
</span></span><span class="line"><span class="cl">.
</span></span><span class="line"><span class="cl">├── build/
</span></span><span class="line"><span class="cl">├── CMakeLists.txt
</span></span><span class="line"><span class="cl">├── compile_commands.json -&gt; build/compile_commands.json
</span></span><span class="line"><span class="cl">├── doc
</span></span><span class="line"><span class="cl">│   ├── doxygen-awesome-css/
</span></span><span class="line"><span class="cl">│   ├── html/
</span></span><span class="line"><span class="cl">│   └── man/
</span></span><span class="line"><span class="cl">├── Doxyfile
</span></span><span class="line"><span class="cl">├── LICENSE
</span></span><span class="line"><span class="cl">├── README.md
</span></span><span class="line"><span class="cl">├── README_ZH_CN.md
</span></span><span class="line"><span class="cl">├── src
</span></span><span class="line"><span class="cl">│   ├── CMakeLists.txt
</span></span><span class="line"><span class="cl">│   ├── core
</span></span><span class="line"><span class="cl">│   │   ├── CMakeLists.txt
</span></span><span class="line"><span class="cl">│   │   └── pack_core.cpp
</span></span><span class="line"><span class="cl">│   ├── curl_cpp
</span></span><span class="line"><span class="cl">│   │   ├── CMakeLists.txt
</span></span><span class="line"><span class="cl">│   │   └── cppcurl.cpp
</span></span><span class="line"><span class="cl">│   ├── include
</span></span><span class="line"><span class="cl">│   │   ├── cppcurl.h
</span></span><span class="line"><span class="cl">│   │   ├── env.h
</span></span><span class="line"><span class="cl">│   │   ├── log.h
</span></span><span class="line"><span class="cl">│   │   ├── misc.h
</span></span><span class="line"><span class="cl">│   │   ├── os-detect.h
</span></span><span class="line"><span class="cl">│   │   └── pack_core.h
</span></span><span class="line"><span class="cl">│   ├── main.cpp
</span></span><span class="line"><span class="cl">│   └── utils
</span></span><span class="line"><span class="cl">│       ├── CMakeLists.txt
</span></span><span class="line"><span class="cl">│       ├── env.cpp
</span></span><span class="line"><span class="cl">│       ├── log.cpp
</span></span><span class="line"><span class="cl">│       └── os-detect.cpp
</span></span><span class="line"><span class="cl">├── <span class="nb">test</span>
</span></span><span class="line"><span class="cl">│   ├── CMakeLists.txt
</span></span><span class="line"><span class="cl">│   └── main_test.cpp
</span></span><span class="line"><span class="cl">└── third_party
</span></span><span class="line"><span class="cl">    ├── argparse/
</span></span><span class="line"><span class="cl">    ├── CMakeLists.txt
</span></span><span class="line"><span class="cl">    ├── googletest/
</span></span><span class="line"><span class="cl">    └── json/</span></span></code></pre></div></div>
<p>上面这个就是我项目的基础结构，<strong>src</strong> 存放项目的源代码，<strong>src/include</strong> 从存放一些自定义的头文件，<strong>test</strong> 目录存放用于开发测试的代码文件，<strong>third_party</strong> 目录存放第三方库文件。</p>
<p>这里 <code>tree -a -L 2</code> 的输出，实际上我对它做了一些修改的工作，这里最后一级的文件夹我都加了 <code>/</code> 做区分，并且我认为不太重要的（如 <strong>.build</strong>, <strong>.git</strong> 文件夹）都删掉了它的下一级内容，并添加 <code>/</code> 表示它是文件夹。</p>
<h2 id="cmake-简单使用">CMake 简单使用</h2>
<blockquote>
<p>CMake is cross-platform free and open-source software for build automation, testing, packaging and installation of software by using a compiler-independent method. CMake is not a build system itself; it generates another system&rsquo;s build files. It supports directory hierarchies and applications that depend on multiple libraries. It can invoke native build environments such as Make, Qt Creator, Ninja, Android Studio, Apple&rsquo;s Xcode, and Microsoft Visual Studio. It has minimal dependencies, requiring only a C++ compiler on its own build system.</p>
<p><a href="https://cmake.org/" target="_blank" rel="noopener noreffer ">CMake</a> 是跨平台的自由开源软件，用于使用独立于编译器的方法构建自动化、测试、打包和安装软件。 CMake 本身并不是一个构建系统，它只是生成另一个系统的构建文件。它支持依赖于多个库的目录层次结构和应用程序。它可以调用本机构建环境，例如 Make、Qt Creator、Ninja、Android Studio、Apple 的 Xcode 和 Microsoft Visual Studio。它具有最小的依赖性，仅需要其自己的构建系统上的 C++ 编译器。</p>
</blockquote>
<p>上面这段话来自 <a href="https://en.wikipedia.org/wiki/CMake" target="_blank" rel="noopener noreffer ">WikiPedia</a></p>
<p>我根目录的 <strong>CMakeLists.txt</strong> 文件的内容是：</p>
<div class="code-block code-line-numbers" style="counter-reset: code-block 0">
    <div class="code-header language-CMakeLists">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="nf">cmake_minimum_required</span><span class="p">(</span><span class="n">VERSION</span><span class="w"> </span><span class="mi">3</span><span class="p">.</span><span class="mi">13</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">set</span><span class="p">(</span><span class="n">CMAKE_CXX_STANDARD</span><span class="w"> </span><span class="mi">17</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">set</span><span class="p">(</span><span class="n">CMAKE_CXX_STANDARD_REQUIRED</span><span class="w"> </span><span class="k">ON</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nf">project</span><span class="p">(</span><span class="n">ReleaseButler</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">VERSION</span><span class="w"> </span><span class="mi">2024</span><span class="p">.</span><span class="mi">5</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">DESCRIPTION</span><span class="w"> </span><span class="s2">&#34;package manager on GitHub&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">LANGUAGES</span><span class="w"> </span><span class="n">CXX</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nf">add_subdirectory</span><span class="p">(</span><span class="n">src</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nf">add_subdirectory</span><span class="p">(</span><span class="n">third_party</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">if</span><span class="p">(</span><span class="k">NOT</span><span class="w"> </span><span class="n">CMAKE_BUILD_TYPE</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="n">CMAKE_CONFIGURATION_TYPES</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nf">message</span><span class="p">(</span><span class="n">STATUS</span><span class="w"> </span><span class="s2">&#34;Setting build type to `Debug` as none was specified.&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">set</span><span class="p">(</span><span class="n">CMAKE_BUILD_TYPE</span><span class="w"> </span><span class="s2">&#34;Debug&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nf">endif</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">if</span><span class="p">(</span><span class="n">CMAKE_BUILD_TYPE</span><span class="w"> </span><span class="n">STREQUAL</span><span class="w"> </span><span class="s2">&#34;Debug&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nf">enable_testing</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nf">add_subdirectory</span><span class="p">(</span><span class="n">test</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">set</span><span class="p">(</span><span class="n">CMAKE_CXX_FLAGS_DEBUG</span><span class="w"> </span><span class="s2">&#34;${CMAKE_CXX_FLAGS_DEBUG} -Wall -Wextra -Werror&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nf">endif</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">if</span><span class="p">(</span><span class="n">CMAKE_BUILD_TYPE</span><span class="w"> </span><span class="n">STREQUAL</span><span class="w"> </span><span class="s2">&#34;Release&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nf">message</span><span class="p">(</span><span class="n">STATUS</span><span class="w"> </span><span class="s2">&#34;Configuring Release build&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1"># something come form https://airbus-seclab.github.io/c-compiler-security/clang_compilation.html
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kt">set</span><span class="p">(</span><span class="n">CMAKE_CXX_FLAGS_RELEASE</span><span class="w"> </span><span class="s2">&#34;${CMAKE_CXX_FLAGS_RELEASE} -O2 -pipe -fPIE -Wall -Wextra -Wpedantic -Werror&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">set</span><span class="p">(</span><span class="n">CMAKE_CXX_FLAGS_RELEASE</span><span class="w"> </span><span class="s2">&#34;${CMAKE_CXX_FLAGS_RELEASE} -fstack-clash-protection -fstack-protector-all -fcf-protection=full&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">set</span><span class="p">(</span><span class="n">CMAKE_CXX_FLAGS_RELEASE</span><span class="w"> </span><span class="s2">&#34;${CMAKE_CXX_FLAGS_RELEASE} -flto&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CMAKE_CXX_COMPILER_ID</span><span class="w"> </span><span class="n">STREQUAL</span><span class="w"> </span><span class="s2">&#34;Clang&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">set</span><span class="p">(</span><span class="n">CMAKE_CXX_FLAGS_RELEASE</span><span class="w"> </span><span class="s2">&#34;${CMAKE_CXX_FLAGS_RELEASE} -fsanitize=integer -fsanitize-minimal-runtime -fno-sanitize-recover&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">set</span><span class="p">(</span><span class="n">CMAKE_CXX_FLAGS_RELEASE</span><span class="w"> </span><span class="s2">&#34;${CMAKE_CXX_FLAGS_RELEASE} -Wthread-safety  -fvisibility=hidden -fsanitize=cfi&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">elseif</span><span class="p">(</span><span class="n">CMAKE_CXX_COMPILER_ID</span><span class="w"> </span><span class="n">STREQUAL</span><span class="w"> </span><span class="s2">&#34;GNU&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">set</span><span class="p">(</span><span class="n">CMAKE_CXX_FLAGS_RELEASE</span><span class="w"> </span><span class="s2">&#34;${CMAKE_CXX_FLAGS_RELEASE} -fsanitize=address -fsanitize=undefined&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">set</span><span class="p">(</span><span class="n">CMAKE_CXX_FLAGS_RELEASE</span><span class="w"> </span><span class="s2">&#34;${CMAKE_CXX_FLAGS_RELEASE} -fstack-protector-strong -D_FORTIFY_SOURCE=2&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">set</span><span class="p">(</span><span class="n">CMAKE_CXX_FLAGS_RELEASE</span><span class="w"> </span><span class="s2">&#34;${CMAKE_CXX_FLAGS_RELEASE} -Wl,-z,relro,-z,now,-z,noexecstack&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nf">endif</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nf">endif</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nf">file</span><span class="p">(</span><span class="n">TO_CMAKE_PATH</span><span class="w"> </span><span class="s2">&#34;${PROJECT_BINARY_DIR}/CMakeLists.txt&#34;</span><span class="w"> </span><span class="n">PATH_TO_CMAKELISTS_TXT</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">if</span><span class="p">(</span><span class="k">EXISTS</span><span class="w"> </span><span class="s2">&#34;${PATH_TO_CMAKELISTS_TXT}&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nf">message</span><span class="p">(</span><span class="n">FATAL_ERROR</span><span class="w"> </span><span class="s2">&#34;Run CMake from a build subdirectory! \&#34;</span><span class="n">mkdir</span><span class="w"> </span><span class="n">build</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">cd</span><span class="w"> </span><span class="n">build</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">cmake</span><span class="w"> </span><span class="p">..</span><span class="err">\</span><span class="s2">&#34; \
</span></span></span><span class="line"><span class="cl"><span class="s2">    Some junk files were created in this folder (CMakeCache.txt, CMakeFiles); you should delete those.&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nf">endif</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1"># Compiler flags.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">set</span><span class="p">(</span><span class="n">CMAKE_POSITION_INDEPENDENT_CODE</span><span class="w"> </span><span class="k">ON</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nf">message</span><span class="p">(</span><span class="n">STATUS</span><span class="w"> </span><span class="s2">&#34;CMAKE_CXX_FLAGS: ${CMAKE_CXX_FLAGS}&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">if</span><span class="p">(</span><span class="n">CMAKE_BUILD_TYPE</span><span class="w"> </span><span class="n">STREQUAL</span><span class="w"> </span><span class="s2">&#34;Debug&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nf">message</span><span class="p">(</span><span class="n">STATUS</span><span class="w"> </span><span class="s2">&#34;CMAKE_CXX_FLAGS_DEBUG: ${CMAKE_CXX_FLAGS_DEBUG}&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">elseif</span><span class="p">(</span><span class="n">CMAKE_BUILD_TYPE</span><span class="w"> </span><span class="n">STREQUAL</span><span class="w"> </span><span class="s2">&#34;Release&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nf">message</span><span class="p">(</span><span class="n">STATUS</span><span class="w"> </span><span class="s2">&#34;CMAKE_CXX_FLAGS_RELEASE: ${CMAKE_CXX_FLAGS_RELEASE}&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nf">endif</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nf">message</span><span class="p">(</span><span class="n">STATUS</span><span class="w"> </span><span class="s2">&#34;CMAKE_EXE_LINKER_FLAGS: ${CMAKE_EXE_LINKER_FLAGS}&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nf">message</span><span class="p">(</span><span class="n">STATUS</span><span class="w"> </span><span class="s2">&#34;CMAKE_SHARED_LINKER_FLAGS: ${CMAKE_SHARED_LINKER_FLAGS}&#34;</span><span class="p">)</span></span></span></code></pre></div></div>
<p>这里我对 Debug 模式和 Release 模式都设置了不同的编译选项，我因为个人的原因很希望 Release 模式编译出来的是尽可能安全些的，所以找了一些安全方面的编译选项。
由于 clang 实现了 CFI 保护，所以我这里检测当前编译环境的编译器如果是 clang 的话就启用该支持。 如果检测到是 GCC 环境的话也会启用相应的支持。</p>
<p>根目录下的 <strong>CMakeLists.txt</strong> 只是设置好相关的编译选项和一些基础设置，而后添加各个子目录的 <strong>CMakeLists.txt</strong>。</p>
<p><strong>third_party</strong> 目录下的 <strong>CMakeLists.txt</strong> 判断如果是 Debug 的话就添加 googletest 库，并且把其他第三方库添加进去。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-CMakeLists">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">set(JSON_BuildTests OFF CACHE INTERNAL &#34;&#34;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">if(CMAKE_BUILD_TYPE STREQUAL &#34;Debug&#34;)
</span></span><span class="line"><span class="cl">    add_subdirectory(googletest)
</span></span><span class="line"><span class="cl">endif()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">add_subdirectory(argparse)</span></span></code></pre></div></div>
<p><strong>test</strong> 目录下还有些东西，因为遇到额外添加 <strong>googletest</strong> 中的 include 到编译过程中，还要启用 testing</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-CMakeLists">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cmake_minimum_required(VERSION 3.11)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">set(TEST_TARGET_NAME main_test)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">set(TEST_SOURCE_FILES
</span></span><span class="line"><span class="cl">    main_test.cpp
</span></span><span class="line"><span class="cl">)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">add_executable(${TEST_TARGET_NAME} ${TEST_SOURCE_FILES})
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">set(
</span></span><span class="line"><span class="cl">    TEST_INCLUDE_DIR
</span></span><span class="line"><span class="cl">    ${PROJECT_SOURCE_DIR}/src/include
</span></span><span class="line"><span class="cl">    ${PROJECT_SOURCE_DIR}/third_party/googletest/googletest/include
</span></span><span class="line"><span class="cl">)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">include_directories(${TEST_INCLUDE_DIR})
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">target_link_libraries(${TEST_TARGET_NAME} PRIVATE gtest gtest_main ${ReleaseButler_LIBS})
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">add_test(NAME ${TEST_TARGET_NAME} COMMAND ${TEST_TARGET_NAME})</span></span></code></pre></div></div>
<p><strong>test</strong> 目录下的示例程序:</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;gtest/gtest.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;gtest/gtest.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;pack_core.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">TEST</span><span class="p">(</span><span class="n">ExampleTest</span><span class="p">,</span> <span class="n">Install</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">Install</span><span class="p">(</span><span class="s">&#34;https://github.com/fastfetch-cli/fastfetch&#34;</span><span class="p">,</span> <span class="s">&#34;fastfetch-linux-amd64.deb&#34;</span><span class="p">,</span> <span class="s">&#34;true&#34;</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">InitGoogleTest</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">RUN_ALL_TESTS</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p><strong>src</strong> 目录下的 <strong>CMakeLists.txt</strong> 设置了可执行文件的具体配置:</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-CMakeLists">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">add_subdirectory(core)
</span></span><span class="line"><span class="cl">add_subdirectory(curl_cpp)
</span></span><span class="line"><span class="cl">add_subdirectory(utils)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">set(PROGRAM_NAME releasebutler)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">add_executable(${PROGRAM_NAME} &#34;main.cpp&#34;)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">set(
</span></span><span class="line"><span class="cl">    RB_SRC_INCLUDE_DIR
</span></span><span class="line"><span class="cl">    ${PROJECT_SOURCE_DIR}/src/include
</span></span><span class="line"><span class="cl">)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">set(
</span></span><span class="line"><span class="cl">    RB_THIRD_PARTY_INCLUDE_DIR
</span></span><span class="line"><span class="cl">    ${PROJECT_SOURCE_DIR}/third_party/argparse/include
</span></span><span class="line"><span class="cl">)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">include_directories(${RB_SRC_INCLUDE_DIR} ${RB_THIRD_PARTY_INCLUDE_DIR})
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">set(ReleaseButler_LIBS
</span></span><span class="line"><span class="cl">    core
</span></span><span class="line"><span class="cl">    utils
</span></span><span class="line"><span class="cl">    curl_cpp
</span></span><span class="line"><span class="cl">)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">target_link_libraries(${PROGRAM_NAME} ${ReleaseButler_LIBS})</span></span></code></pre></div></div>
<p>这里设置好了可执行文件的名称，以及它依赖的库文件，并在最开始添加相关库的子目录进去，先把子目录的 lib 编译好。</p>
<p>下边贴一个 <strong>src/core/CMakeLists.txt</strong> 的内容:</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-CMakeLists.txt">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-CMakeLists.txt" data-lang="CMakeLists.txt"><span class="line"><span class="cl"><span class="nb">set</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">RB_CORE_SRC_INCLUDE</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="o">}</span><span class="s">/src/include</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">RB_CORE_TP_INCLUDE</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="o">}</span><span class="s">/third_party/json/single_include/nlohmann</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">RB_CORE_SRC</span>
</span></span><span class="line"><span class="cl">    <span class="s">pack_core.cpp</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">RB_CORE_SRC_INCLUDE</span><span class="o">}</span> <span class="o">${</span><span class="nv">RB_CORE_TP_INCLUDE</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">core</span>
</span></span><span class="line"><span class="cl">    <span class="s">OBJECT</span>
</span></span><span class="line"><span class="cl">    <span class="o">${</span><span class="nv">RB_CORE_SRC</span><span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></div></div>
<p>可以看到就是简单的设置 include 路径并编译成 object</p>
<p>在项目的根目录下，执行下边的语句:</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ cmake --build build -j <span class="sb">`</span>nproc<span class="sb">`</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>  5%<span class="o">]</span> Building CXX object src/utils/CMakeFiles/utils.dir/log.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span> 11%<span class="o">]</span> Building CXX object src/utils/CMakeFiles/utils.dir/os-detect.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span> 17%<span class="o">]</span> Building CXX object src/utils/CMakeFiles/utils.dir/env.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span> 23%<span class="o">]</span> Building CXX object src/core/CMakeFiles/core.dir/pack_core.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span> 29%<span class="o">]</span> Building CXX object src/curl_cpp/CMakeFiles/curl_cpp.dir/cppcurl.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span> 35%<span class="o">]</span> Building CXX object third_party/googletest/googletest/CMakeFiles/gtest.dir/src/gtest-all.cc.o
</span></span><span class="line"><span class="cl"><span class="o">[</span> 35%<span class="o">]</span> Built target curl_cpp
</span></span><span class="line"><span class="cl"><span class="o">[</span> 35%<span class="o">]</span> Built target core
</span></span><span class="line"><span class="cl"><span class="o">[</span> 35%<span class="o">]</span> Built target utils
</span></span><span class="line"><span class="cl"><span class="o">[</span> 41%<span class="o">]</span> Building CXX object src/CMakeFiles/releasebutler.dir/main.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span> 47%<span class="o">]</span> Linking CXX static library ../../../lib/libgtest.a
</span></span><span class="line"><span class="cl"><span class="o">[</span> 47%<span class="o">]</span> Built target gtest
</span></span><span class="line"><span class="cl"><span class="o">[</span> 58%<span class="o">]</span> Building CXX object third_party/googletest/googlemock/CMakeFiles/gmock.dir/src/gmock-all.cc.o
</span></span><span class="line"><span class="cl"><span class="o">[</span> 58%<span class="o">]</span> Building CXX object third_party/googletest/googletest/CMakeFiles/gtest_main.dir/src/gtest_main.cc.o
</span></span><span class="line"><span class="cl"><span class="o">[</span> 64%<span class="o">]</span> Linking CXX executable releasebutler
</span></span><span class="line"><span class="cl"><span class="o">[</span> 64%<span class="o">]</span> Built target releasebutler
</span></span><span class="line"><span class="cl"><span class="o">[</span> 70%<span class="o">]</span> Linking CXX static library ../../../lib/libgtest_main.a
</span></span><span class="line"><span class="cl"><span class="o">[</span> 70%<span class="o">]</span> Built target gtest_main
</span></span><span class="line"><span class="cl"><span class="o">[</span> 76%<span class="o">]</span> Building CXX object test/CMakeFiles/main_test.dir/main_test.cpp.o
</span></span><span class="line"><span class="cl"><span class="o">[</span> 82%<span class="o">]</span> Linking CXX executable main_test
</span></span><span class="line"><span class="cl"><span class="o">[</span> 82%<span class="o">]</span> Built target main_test
</span></span><span class="line"><span class="cl"><span class="o">[</span> 88%<span class="o">]</span> Linking CXX static library ../../../lib/libgmock.a
</span></span><span class="line"><span class="cl"><span class="o">[</span> 88%<span class="o">]</span> Built target gmock
</span></span><span class="line"><span class="cl"><span class="o">[</span> 94%<span class="o">]</span> Building CXX object third_party/googletest/googlemock/CMakeFiles/gmock_main.dir/src/gmock_main.cc.o
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Linking CXX static library ../../../lib/libgmock_main.a
</span></span><span class="line"><span class="cl"><span class="o">[</span>100%<span class="o">]</span> Built target gmock_main</span></span></code></pre></div></div>
<p>这样在 <strong>build/test</strong> 目录下就会生成一个用于测试的程序。执行即可</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ ./build/test/main_test
</span></span><span class="line"><span class="cl"><span class="o">[==========]</span> Running <span class="m">1</span> <span class="nb">test</span> from <span class="m">1</span> <span class="nb">test</span> suite.
</span></span><span class="line"><span class="cl"><span class="o">[</span>----------<span class="o">]</span> Global <span class="nb">test</span> environment set-up.
</span></span><span class="line"><span class="cl"><span class="o">[</span>----------<span class="o">]</span> <span class="m">1</span> <span class="nb">test</span> from ExampleTest
</span></span><span class="line"><span class="cl"><span class="o">[</span> RUN      <span class="o">]</span> ExampleTest.Addition
</span></span><span class="line"><span class="cl"><span class="o">[</span>       OK <span class="o">]</span> ExampleTest.Addition <span class="o">(</span><span class="m">0</span> ms<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>----------<span class="o">]</span> <span class="m">1</span> <span class="nb">test</span> from ExampleTest <span class="o">(</span><span class="m">0</span> ms total<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>----------<span class="o">]</span> Global <span class="nb">test</span> environment tear-down
</span></span><span class="line"><span class="cl"><span class="o">[==========]</span> <span class="m">1</span> <span class="nb">test</span> from <span class="m">1</span> <span class="nb">test</span> suite ran. <span class="o">(</span><span class="m">0</span> ms total<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>  PASSED  <span class="o">]</span> <span class="m">1</span> test.</span></span></code></pre></div></div>
<p>这里有一个问题，我使用的是 Visual Studio Code 写代码，用 <code>clangd</code> 插件提高 C/C++ 的编程体验，我一开始用 <code>ln -s</code> 给 <strong>build/compile_commands.json</strong> 文件在根目录建一个软链接，但是 <code>clangd</code> 的没有成功解析出 <strong>test/main_test.cpp</strong> 文件的头文件位置，后来我安装了bear，特地 <code>bear -- cmake</code> 生成了一个 <strong>compile_commands.json</strong> 才成功解析。</p>
<p>不过后来又好使了，不好评价那时候发生了什么。</p>
<h2 id="clang-tidy-和-clang-format"><code>clang-tidy</code> 和 <code>clang-format</code></h2>
<blockquote>
<p><code>clang-tidy</code> is a clang-based C++ “linter” tool. Its purpose is to provide an extensible framework for diagnosing and fixing typical programming errors, like style violations, interface misuse, or bugs that can be deduced via static analysis. <code>clang-tidy</code> is modular and provides a convenient interface for writing new checks.</p>
<p><code>clang-tidy</code> 是一个基于 <code>clang</code> 的 C++ “linter” 工具。其目的是提供一个可扩展的框架，用于诊断和修复典型的编程错误，例如样式违规、接口误用或可以通过静态分析推断出的错误。 <code>clang-tidy</code> 是模块化的，并提供了一个方便的接口来编写新的检查。</p>
</blockquote>
<p><a href="https://clang.llvm.org/extra/clang-tidy/" target="_blank" rel="noopener noreffer ">clang-tidy</a> 是一个静态语法扫描器。我第一次听说它就是在一个文章中，那篇文章介绍了 C++ 目前面临的困境，其中一个就是 C++ 的学习者还在对着已经过时的语法学习，根本不怎么了解 &ldquo;modern cpp&rdquo;。之后那篇文章介绍 <code>clang-tidy</code> 一定程度上正在解决这个问题，我对它的理解就是会检查源文件的语法是否符合 <code>clang-tidy</code> 认为的好写法，它根据多种规则来检查。但是 <code>clang-tidy</code> 内置的部分规则是没有必要的，比如要求类的成员函数的首字母需要大写（至少我认为没什么必要，甚至我写函数就没有大写的习惯，宏写的函数除外，不过宏写的到底能不能叫函数🤔）。</p>
<p><code>clang-tidy</code> 支持项目根目录下存在一个 <strong>.clang-tidy</strong> 文件，该文件可以指定规则，检查的范围，对一些规则作具体的设置。</p>
<p><a href="https://clang.llvm.org/docs/ClangFormat.html" target="_blank" rel="noopener noreffer ">clang-format</a> 就是一个专门的代码格式化工具了，<code>clang-format</code> 内置了多种代码风格，可以指定某个风格并做一些额外的修改，当然也是写在项目的根目录下的 <strong>.clang-format</strong>。</p>
<p>下面是我 <strong>.clang-tidy</strong> 文件的内容：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-txt">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">Checks: &#39;
</span></span><span class="line"><span class="cl">        bugprone-*,
</span></span><span class="line"><span class="cl">        clang-analyzer-*,
</span></span><span class="line"><span class="cl">        google-*,
</span></span><span class="line"><span class="cl">        modernize-*,
</span></span><span class="line"><span class="cl">        performance-*,
</span></span><span class="line"><span class="cl">        portability-*,
</span></span><span class="line"><span class="cl">        readability-*,
</span></span><span class="line"><span class="cl">        -bugprone-easily-swappable-parameters,
</span></span><span class="line"><span class="cl">        -bugprone-implicit-widening-of-multiplication-result,
</span></span><span class="line"><span class="cl">        -bugprone-narrowing-conversions,
</span></span><span class="line"><span class="cl">        -bugprone-reserved-identifier,
</span></span><span class="line"><span class="cl">        -bugprone-signed-char-misuse,
</span></span><span class="line"><span class="cl">        -bugprone-suspicious-include,
</span></span><span class="line"><span class="cl">        -bugprone-unhandled-self-assignment,
</span></span><span class="line"><span class="cl">        -clang-analyzer-cplusplus.NewDelete,
</span></span><span class="line"><span class="cl">        -clang-analyzer-cplusplus.NewDeleteLeaks,
</span></span><span class="line"><span class="cl">        -clang-analyzer-security.insecureAPI.rand,
</span></span><span class="line"><span class="cl">        -clang-diagnostic-implicit-int-float-conversion,
</span></span><span class="line"><span class="cl">        -google-readability-avoid-underscore-in-googletest-name,
</span></span><span class="line"><span class="cl">        -modernize-avoid-c-arrays,
</span></span><span class="line"><span class="cl">        -modernize-use-nodiscard,
</span></span><span class="line"><span class="cl">        -readability-convert-member-functions-to-static,
</span></span><span class="line"><span class="cl">        -readability-identifier-length,
</span></span><span class="line"><span class="cl">        -readability-function-cognitive-complexity,
</span></span><span class="line"><span class="cl">        -readability-magic-numbers,
</span></span><span class="line"><span class="cl">        -readability-make-member-function-const,
</span></span><span class="line"><span class="cl">        -readability-qualified-auto,
</span></span><span class="line"><span class="cl">        -readability-identifier-naming,
</span></span><span class="line"><span class="cl">        -readability-redundant-access-specifiers,
</span></span><span class="line"><span class="cl">        -bugprone-exception-escape,
</span></span><span class="line"><span class="cl">        -performance-avoid-endl,
</span></span><span class="line"><span class="cl">        -readability-use-anyofallof,
</span></span><span class="line"><span class="cl">        &#39;
</span></span><span class="line"><span class="cl">CheckOptions:
</span></span><span class="line"><span class="cl">  - { key: readability-identifier-naming.ClassCase,           value: CamelCase  }
</span></span><span class="line"><span class="cl">  - { key: readability-identifier-naming.EnumCase,            value: CamelCase  }
</span></span><span class="line"><span class="cl">  - { key: readability-identifier-naming.FunctionCase,        value: CamelCase  }
</span></span><span class="line"><span class="cl">  - { key: readability-identifier-naming.GlobalConstantCase,  value: UPPER_CASE }
</span></span><span class="line"><span class="cl">  - { key: readability-identifier-naming.MemberCase,          value: lower_case }
</span></span><span class="line"><span class="cl">  - { key: readability-identifier-naming.MemberSuffix,        value: _          }
</span></span><span class="line"><span class="cl">  - { key: readability-identifier-naming.NamespaceCase,       value: lower_case }
</span></span><span class="line"><span class="cl">  - { key: readability-identifier-naming.StructCase,          value: CamelCase  }
</span></span><span class="line"><span class="cl">  - { key: readability-identifier-naming.UnionCase,           value: CamelCase  }
</span></span><span class="line"><span class="cl">  - { key: readability-identifier-naming.VariableCase,        value: lower_case }
</span></span><span class="line"><span class="cl">WarningsAsErrors: &#39;*&#39;
</span></span><span class="line"><span class="cl">HeaderFilterRegex: &#39;/(src|test)/include&#39;
</span></span><span class="line"><span class="cl">AnalyzeTemporaryDtors: true</span></span></code></pre></div></div>
<p>下面则是 <strong>.clang-format</strong> 的内容</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-txt">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">BasedOnStyle: Google
</span></span><span class="line"><span class="cl">ColumnLimit: 80</span></span></code></pre></div></div>
<p>我对代码格式化还没有什么太高的需求，等我以后再好好研究如何更好的格式化吧。</p>
<h2 id="doxygen-使用"><code>doxygen</code> 使用</h2>
<p><code>doxygen</code> 是一个根据源文件的注释生成项目 API 文档的软件。我认为一定程度上这逼迫者我写注释😶‍🌫️。这个文档格式可以是 HTML，LaTeX，man pages 等，</p>
<p><code>doxygen</code> 是根据 <strong>Doxyfile</strong> 生成相关文档的。在项目的根目录下打开终端输入 <code>doxygen -g</code> 即可产生一份带有注释信息的 <strong>Doxyfile</strong>，可以根据注释了解一下 <strong>Doxyfile</strong> 的写法。</p>
<p>下面是我 <strong>Doxyfile</strong> 的内容：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-Doxyfile">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">PROJECT_NAME</span>           <span class="p">=</span> <span class="s">&#34;ReleaseButler&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">PROJECT_NUMBER</span>         <span class="p">=</span> <span class="s">&#34;1.0&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nx">PROJECT_BRIEF</span>          <span class="p">=</span> <span class="s">&#34;😙 package manager on GitHub 😙&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">#</span> <span class="nx">Project</span> <span class="nx">section</span>
</span></span><span class="line"><span class="cl"><span class="err">#</span> <span class="nx">BRIEF_MEMBER_DESC</span> <span class="p">=</span> <span class="nx">NO</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">HTML_STYLESHEET</span> <span class="p">=</span> <span class="nx">doc</span><span class="o">/</span><span class="nx">doxygen</span><span class="o">-</span><span class="nx">awesome</span><span class="o">-</span><span class="nx">css</span><span class="o">/</span><span class="nx">doxygen</span><span class="o">-</span><span class="nx">awesome</span><span class="p">.</span><span class="nx">css</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">#</span> <span class="nx">输入</span>
</span></span><span class="line"><span class="cl"><span class="nx">INPUT</span>                  <span class="p">=</span> <span class="nx">src</span> <span class="nx">README</span><span class="p">.</span><span class="nx">md</span> <span class="nx">README_ZH_CN</span><span class="p">.</span><span class="nx">md</span>
</span></span><span class="line"><span class="cl"><span class="nx">FILE_PATTERNS</span>          <span class="p">=</span> <span class="o">*</span><span class="p">.</span><span class="nx">cpp</span> <span class="o">*</span><span class="p">.</span><span class="nx">h</span>
</span></span><span class="line"><span class="cl"><span class="nx">RECURSIVE</span>              <span class="p">=</span> <span class="nx">YES</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">#</span> <span class="nx">输出格式</span>
</span></span><span class="line"><span class="cl"><span class="nx">GENERATE_HTML</span>          <span class="p">=</span> <span class="nx">YES</span>
</span></span><span class="line"><span class="cl"><span class="nx">HTML_OUTPUT</span>            <span class="p">=</span> <span class="nx">doc</span><span class="o">/</span><span class="nx">html</span>
</span></span><span class="line"><span class="cl"><span class="nx">GENERATE_LATEX</span>         <span class="p">=</span> <span class="nx">NO</span>
</span></span><span class="line"><span class="cl"><span class="nx">GENERATE_XML</span>           <span class="p">=</span> <span class="nx">NO</span>
</span></span><span class="line"><span class="cl"><span class="nx">GENERATE_RTF</span>           <span class="p">=</span> <span class="nx">NO</span>
</span></span><span class="line"><span class="cl"><span class="nx">GENERATE_MAN</span>           <span class="p">=</span> <span class="nx">YES</span>
</span></span><span class="line"><span class="cl"><span class="nx">MAN_OUTPUT</span>            <span class="p">=</span> <span class="nx">doc</span><span class="o">/</span><span class="nx">man</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">#</span> <span class="nx">文档风格</span>
</span></span><span class="line"><span class="cl"><span class="nx">OUTPUT_LANGUAGE</span>        <span class="p">=</span> <span class="nx">English</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">#</span> <span class="nx">文档内容</span>
</span></span><span class="line"><span class="cl"><span class="nx">EXTRACT_ALL</span>            <span class="p">=</span> <span class="nx">YES</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">#</span> <span class="nx">注释风格</span>
</span></span><span class="line"><span class="cl"><span class="nx">JAVADOC_AUTOBRIEF</span>      <span class="p">=</span> <span class="nx">YES</span>
</span></span><span class="line"><span class="cl"><span class="nx">QT_AUTOBRIEF</span>           <span class="p">=</span> <span class="nx">NO</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">#</span> <span class="nx">其他</span>
</span></span><span class="line"><span class="cl"><span class="nx">GENERATE_TREEVIEW</span>      <span class="p">=</span> <span class="nx">YES</span>
</span></span><span class="line"><span class="cl"><span class="nx">GENERATE_LATEX</span>         <span class="p">=</span> <span class="nx">NO</span>
</span></span><span class="line"><span class="cl"><span class="nx">GENERATE_HTMLHELP</span>      <span class="p">=</span> <span class="nx">NO</span>
</span></span><span class="line"><span class="cl"><span class="nx">DISTRIBUTE_GROUP_DOC</span>   <span class="p">=</span> <span class="nx">NO</span>
</span></span><span class="line"><span class="cl"><span class="nx">USE_MDFILE_AS_MAINPAGE</span> <span class="p">=</span> <span class="nx">README</span><span class="p">.</span><span class="nx">md</span></span></span></code></pre></div></div>
<p><code>doxygen</code> 生成的 HTML 网页好难看啊😢，所以我特地找了一个主题 <a href="https://github.com/jothepro/doxygen-awesome-css" target="_blank" rel="noopener noreffer ">doxygen-awesome-css</a>，这样还能相对好看一些。</p>
<p><code>doxygen</code> 对注释格式也有些要求，这是我写的一个注释：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @brief Simple encapsulation of std::getenv
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param name Name of the environment variable
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return The value of the environment variable
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="na">[[nodiscard]]</span> <span class="k">auto</span> <span class="n">get_env2str</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span></span></span></code></pre></div></div>
<p><code>@brief</code> 是简要说明，<code>@param</code> 是参数说明，<code>@return</code> 是对返回值的说明。其实还有 <code>@note</code> 等字段，也可以用来标示一种信息。</p>
<p>而且实际上 <code>clangd</code> 目前不支持对 Doxygen 这样格式的注释的解析，导致 Visual Studio Code 读自己写的注释是没有什么好渲染的。
不过貌似微软官方的 C/C++ 插件可以解析 Doxygen 的注释，并渲染出来，但我习惯使用 <code>clangd</code> 了。</p>]]></description>
</item>
<item>
    <title>CS106L: Type &amp; RAII</title>
    <link>http://localhost:1313/posts/cs106l_type_raii/</link>
    <pubDate>Mon, 05 Feb 2024 03:42:51 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cs106l_type_raii/</guid>
    <description><![CDATA[<p>CS106L 中关于 Type 和 RAII 的部分</p>
<h1 id="type--raii">Type &amp; RAII</h1>
<h2 id="type--stdoptional">Type &amp; <code>std::optional</code></h2>
<h3 id="type-conversion">Type Conversion</h3>
<p>C++提供了更好的类型转换（相比于 C 那样直接写括号的强制类型转换）</p>
<p><a href="https://en.cppreference.com/w/cpp/language/static_cast" target="_blank" rel="noopener noreffer ">static_cast</a> 和 <a href="https://en.cppreference.com/w/cpp/language/dynamic_cast" target="_blank" rel="noopener noreffer ">dynamic_cast</a></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Derived</span> <span class="n">derivedObj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Base</span><span class="o">*</span> <span class="n">basePtr</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">derivedObj</span><span class="p">);</span></span></span></code></pre></div></div>
<p>就像这个 <code>static_cast</code>，会在编译时检验转换是否合法。</p>
<h3 id="stdoptional"><code>std::optional</code></h3>
<p><code>std::optional</code> interface：</p>
<ul>
<li><code>.value()</code>
<ul>
<li>返回包含的值或抛出 <code>bad_optional_access</code> 错误。</li>
</ul>
</li>
<li><code>.value_or(valueType val)</code>
<ul>
<li>返回包含的值或默认值 val（参数）。</li>
</ul>
</li>
<li><code>.has_value()</code>
<ul>
<li>如果存在包含的值，则返回 true；否则返回 false。</li>
</ul>
</li>
</ul>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">lookupStudent</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">){</span> <span class="cm">/*something*/</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="n">lookupStudent</span><span class="p">(</span><span class="err">“</span><span class="n">Keith</span><span class="err">”</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">student</span><span class="p">.</span><span class="n">has_value</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">output</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="err">“</span> <span class="n">is</span> <span class="n">from</span> <span class="err">“</span> <span class="o">&lt;&lt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">output</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">state</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="err">“</span><span class="n">No</span> <span class="n">student</span> <span class="n">found</span><span class="err">”</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>使用 <code>std::optional</code> 返回值的优点：</p>
<ul>
<li>函数签名可以创建更具信息性的合约（contracts）。</li>
<li>类的函数调用具有保证和可用的行为。</li>
</ul>
<p>缺点：</p>
<ul>
<li>你需要在每个地方使用 <code>.value()</code>。</li>
<li>（在 C++中）仍然可能出现 bad_optional_access 错误。</li>
<li>（在 C++中）optional 也可能具有 undefined behavior（<code>*optional</code> 与 <code>.value()</code> 执行相同的操作，没有错误检查）。</li>
<li>在许多情况下，开发者希望有 <code>std::optional&lt;T&amp;&gt;</code>，但实际上并没有这个类型。</li>
</ul>
<p><code>std::optional</code> 的 monadic 接口（C++23）：</p>
<ul>
<li><code>.and_then(function f)</code>
<ul>
<li>如果存在包含的值，则返回调用 <code>f(value)</code> 的结果，否则返回 null_opt（f 必须返回 optional 类型）。</li>
</ul>
</li>
<li><code>.transform(function f)</code>
<ul>
<li>如果存在包含的值，则返回调用 <code>f(value)</code> 的结果，否则返回 null_opt（f 必须返回 optional<!-- raw HTML omitted --> 类型）。</li>
</ul>
</li>
<li><code>.or_else(function f)</code>
<ul>
<li>如果存在值，则返回该值，否则返回调用 <code>f</code> 的结果</li>
</ul>
</li>
</ul>
<p>那样代码就可以这么写：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">lookupStudent</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">){</span><span class="cm">/*something*/</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="n">lookupStudent</span><span class="p">(</span><span class="err">“</span><span class="n">Keith</span><span class="err">”</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">stu</span><span class="p">)[]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">stu</span> <span class="o">?</span> <span class="n">stu</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">name</span> <span class="o">+</span> <span class="err">“</span><span class="n">is</span> <span class="n">from</span> <span class="err">“</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">stu</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">state</span><span class="p">)</span> <span class="o">:</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">output</span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="n">func</span><span class="p">).</span><span class="n">value_or</span><span class="p">(</span><span class="err">“</span><span class="n">No</span> <span class="n">student</span> <span class="n">found</span><span class="err">”</span><span class="p">);</span></span></span></code></pre></div></div>
<h2 id="raii">RAII</h2>
<h3 id="intro">intro</h3>
<blockquote>
<p>The best example of why I shouldn&rsquo;t be in marketing. I didn&rsquo;t have a good day when I named that &ndash; Bjarne Stroustrup (daddy of C++)</p>
</blockquote>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">EvaluateSalaryAndReturnName</span><span class="p">(</span><span class="kt">int</span> <span class="n">idNumber</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Employee</span><span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Employee</span><span class="p">(</span><span class="n">idNumber</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">Title</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#34;CEO&#34;</span> <span class="o">||</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">Salary</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">100000</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">First</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span>
</span></span><span class="line"><span class="cl">                  <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">Last</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; is overpaid&#34;</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">First</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; &#34;</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">Last</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="n">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>对于这个函数，有很多地方可能导致内存泄露，即在 <code>delete</code> 之前的异常退出该函数从而导致在 heap 上的内存没有 free。所以我们需要 <code>try-catch</code>。</p>
<p><strong>关于异常安全</strong></p>
<p>不抛出异常：<code>noexcept</code> 关键字保证函数不会因为异常而导致一些 undefined behavior。这会出现在析构函数，swap，移动构造函数之类的。</p>
<p>在 <a href="https://google.github.io/styleguide/cppguide.html#Exceptions" target="_blank" rel="noopener noreffer ">Google C++ Style Guide</a> 中，Google 提到不建议使用异常。</p>
<p>理由：</p>
<blockquote>
<p>On their face, the benefits of using exceptions outweigh the costs, especially in new projects. However, for existing code, the introduction of exceptions has implications on all dependent code. If exceptions can be propagated beyond a new project, it also becomes problematic to integrate the new project into existing exception-free code. Because most existing C++ code at Google is not prepared to deal with exceptions, it is comparatively difficult to adopt new code that generates exceptions.
Given that Google&rsquo;s existing code is not exception-tolerant, the costs of using exceptions are somewhat greater than the costs in a new project. The conversion process would be slow and error-prone. We don&rsquo;t believe that the available alternatives to exceptions, such as error codes and assertions, introduce a significant burden.
Our advice against using exceptions is not predicated on philosophical or moral grounds, but practical ones. Because we&rsquo;d like to use our open-source projects at Google and it&rsquo;s difficult to do so if those projects use exceptions, we need to advise against exceptions in Google open-source projects as well. Things would probably be different if we had to do it all over again from scratch.
This prohibition also applies to exception handling related features such as <code>std::exception_ptr</code> and <code>std::nested_exception</code>.</p>
</blockquote>
<p>来自 ChatGPT@Poe 的中文翻译：</p>
<blockquote>
<p>在表面上，使用异常的好处超过了成本，尤其是在新项目中。然而，对于现有的代码来说，引入异常会对所有相关的代码产生影响。如果异常可以传播到新项目之外，将新项目整合到现有的无异常代码中也会带来问题。由于 Google 大部分现有的 C++代码都没有准备好处理异常，采用生成异常的新代码相对困难。
考虑到 Google 现有的代码不具备异常容忍性，使用异常的成本要略高于在新项目中的成本。转换过程将会缓慢且容易出错。我们认为，异常的替代方案（如错误码和断言）并不会引入重大负担。
我们反对使用异常的建议并非基于哲学或道德的立场，而是出于实际考虑。因为我们希望在 Google 使用我们的开源项目，但如果这些项目使用异常，那么在使用过程中会变得困难。如果我们从头开始重新做，情况可能会有所不同。
这个禁令也适用于与异常处理相关的特性，如 <code>std::exception_ptr</code> 和 <code>std::nested_exception</code>。</p>
</blockquote>
<h3 id="raii-1">RAII</h3>
<p><strong>RAII</strong>: <strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization</p>
<p>这个技术还有几个叫法：</p>
<p><strong>SBRM</strong>: <strong>S</strong>cope <strong>B</strong>ased Memo<strong>r</strong>y <strong>M</strong>anagement</p>
<p><strong>CADRE</strong>: <strong>C</strong>onstructor <strong>A</strong>cquires, <strong>D</strong>estructor <strong>Re</strong>leases</p>
<p>从后两个的全拼能看出来，RAII 就是利用了类在超出作用域范围的时候就自动调用析构函数这一点，将 <code>new</code> 和 <code>delete</code> 放到构造函数和析构函数中。</p>
<p>比如在 open 一个文件的时候，不应该先用 <code>ifstream</code> 创建一个变量，然后调用 <code>open</code> 函数，而是直接 <code>ifstream input(&quot;test.txt)</code>，这就是 RAII 的写法，这样也不需要在后面写 <code>input.close()</code> 了。</p>
<p>锁也有类似的：<code>lock_guard</code></p>
<p></p>
<p>在 <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines" target="_blank" rel="noopener noreffer ">C++ Core Guidelines</a> 也有相关描述:</p>
<p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-newdelete" target="_blank" rel="noopener noreffer ">R.11: Avoid calling new and delete explicitly</a></p>
<h3 id="smart-pointers">Smart Pointers</h3>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Tp</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Tp</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Tp</span><span class="o">&gt;</span><span class="p">;</span></span></span></code></pre></div></div>
<p><strong>unique_ptr</strong></p>
<p><code>unique_ptr</code>，唯一持有自己的资源并在被销毁的时候用析构函数释放。唯一持有为了防止复制后发生重复的 free。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">rawPtrFn</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">delete</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// use unique_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">rawPtrFn</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">n</span><span class="p">(</span><span class="k">new</span> <span class="n">Node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div></div>
<p><code>unique_ptr</code> 无法被复制，但可以通过 <code>std::move</code> 移动：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">u3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">u4</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">u3</span><span class="p">);</span></span></span></code></pre></div></div>
<p><strong>shared_ptr</strong></p>
<p><code>shared_ptr</code> 可以复制，当所有指向这个资源的 <code>shared_ptr</code> 都死掉后就 free 掉这块内存。<code>shared_ptr</code> 用引用计数实现了这一点。</p>
<p><strong>weak_ptr</strong></p>
<p><code>weak_ptr</code> 类似于 <code>shared_ptr</code>，但是没有引用计数。</p>]]></description>
</item>
<item>
    <title>CS106L: Class</title>
    <link>http://localhost:1313/posts/cs106l_class_op/</link>
    <pubDate>Sun, 04 Feb 2024 03:42:51 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cs106l_class_op/</guid>
    <description><![CDATA[<p>CS106L 中关于类的部分</p>
<h1 id="class">Class</h1>
<blockquote>
<p>A struct simply feels like an open pile of bits with very little in the way of encapsulation or functionality. A class feels like a living and responsible member of society with intelligent services, a strong encapsulation barrier, and a well defined interface</p>
<ul>
<li>Bjarne Stroustrup</li>
</ul>
</blockquote>
<h2 id="构造函数初始化列表">构造函数初始化列表</h2>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Student</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span><span class="p">)</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">state</span><span class="p">(</span><span class="n">state</span><span class="p">),</span> <span class="n">age</span><span class="p">(</span><span class="n">age</span><span class="p">){</span> <span class="p">}</span></span></span></code></pre></div></div>
<p>函数体内部还是可以写代码的</p>
<h2 id="关于-delete">关于 delete</h2>
<p>array 作为一个基础的类型，当开发者手动为此创建内存之后也可以之后手动释放掉：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//int * is the type of an array variable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">my_int_array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//this is how you initialize an array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">my_int_array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">//this is how you index into an array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">one_element</span> <span class="o">=</span> <span class="n">my_int_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">delete</span> <span class="p">[]</span> <span class="n">my_int_array</span><span class="p">;</span></span></span></code></pre></div></div>
<p>delete 一般在类的析构函数中出现（需要手动掉释放这块内存）</p>
<p></p>
<p>这里那个虚函数等于 0 的意义在于，让继承它的类必须实现该函数，否则编译失败。这种虚函数叫作纯虚函数（<em>pure virtual function</em></p>
<p>一个类存在一个纯虚函数就叫作抽象类，抽象类不能被实例化。</p>
<p>如何子类不想要实现自己的构造函数，可以：</p>
<p></p>
<p>如果是析构函数可能有点麻烦，如果有一个基类（这个类的析构函数不是虚函数）的指针指向派生类，并且这时候要 <code>delete</code> 这个指针就不会调用派生类的析构函数。如果基类的析构函数实现为虚函数，那么才可以正常调用派生类的析构函数释放内存。</p>
<p></p>
<p></p>
<p>如果基类的虚函数有实现了，并且派生类想要调用，可以这么写：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">t</span><span class="p">.</span><span class="n">Drink</span><span class="o">::</span><span class="n">make</span><span class="p">();</span></span></span></code></pre></div></div>
<h2 id="template-classes">Template classes</h2>
<blockquote>
<p>Fundamental Theorem of Software Engineering: Any problem can be solved by adding enough layers of indirection</p>
</blockquote>
<p>模板类之前也见到过：<code>std::vector&lt;int&gt;</code>。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//Example: Structs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">First</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Second</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">MyPair</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">First</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Second</span> <span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">First</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Second</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyPair</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">First</span> <span class="n">getFirst</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">Second</span> <span class="nf">getSecond</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="nf">setFirst</span><span class="p">(</span><span class="n">First</span> <span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="nf">setSecond</span><span class="p">(</span><span class="n">Second</span> <span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">First</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Second</span> <span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">First</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Second</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyPair</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*...*/</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">First</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Second</span> <span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div></div>
<p>而其部分函数的实现，也需要加 template：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">First</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Second</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">First</span> <span class="n">MyPair</span><span class="o">::</span><span class="n">getFirst</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>模板类的成员函数和其他函数并不一样，编写的时候最好在一起，而不是像其他普通的编写一样，分为.h 和.cpp 两个文件。因为模板类的成员函数需要编译时的实例化，需要具体的参数生成对应函数的实现。</p>
<p>模板类可以针对特定类型写一个版本：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">FooSpecial</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">FooSpecial</span><span class="p">(</span><span class="kt">float</span> <span class="n">var</span><span class="p">)</span> <span class="o">:</span> <span class="n">var_</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;hello float! &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">var_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">var_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div></div>
<h2 id="const-keyword">const keyword</h2>
<p>const 函数不可以修改类的元素后者传给它的参数。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span> <span class="k">const</span> <span class="n">p</span><span class="p">;</span></span></span></code></pre></div></div>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">++</span> <span class="c1">// ok
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">p</span><span class="o">++</span> <span class="c1">// error
</span></span></span></code></pre></div></div>
<p>const-interface：所有成员函数都可以在定义类的时候被 const 标记</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">StrVector</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">using</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">size_t</span> <span class="n">kInitialSize</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*...*/</span>
</span></span><span class="line"><span class="cl">        <span class="n">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>            <span class="c1">//here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>             <span class="c1">//here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="n">size_t</span> <span class="n">indx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">size_t</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">iterator</span> <span class="nf">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">iterator</span> <span class="nf">end</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*...*/</span></span></span></code></pre></div></div>
<p>这种标记是一种 <code>const</code> 成员函数，它保证了函数内部不会修改 <code>this</code> 实例。</p>
<h2 id="operators">Operators</h2>
<h3 id="运算符重载">运算符重载</h3>
<p></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">strvec</span><span class="p">{</span><span class="s">&#34;Hello&#34;</span><span class="p">,</span> <span class="s">&#34;World&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">strvec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">strvec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s">&#34;!&#34;</span><span class="p">;</span></span></span></code></pre></div></div>
<p>上面这段代码相当于：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">strvec</span><span class="p">{</span><span class="s">&#34;Hello&#34;</span><span class="p">,</span> <span class="s">&#34;World&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">.</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">strvec</span><span class="p">.</span><span class="k">operator</span><span class="p">[](</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">strvec</span><span class="p">.</span><span class="k">operator</span><span class="p">[](</span><span class="mi">1</span><span class="p">).</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="s">&#34;!&#34;</span><span class="p">);</span></span></span></code></pre></div></div>
<p>或者是这样：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">strvec</span><span class="p">{</span><span class="s">&#34;Hello&#34;</span><span class="p">,</span> <span class="s">&#34;World&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span> <span class="n">strvec</span><span class="p">.</span><span class="k">operator</span><span class="p">[](</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">strvec</span><span class="p">.</span><span class="k">operator</span><span class="p">[](</span><span class="mi">1</span><span class="p">),</span> <span class="s">&#34;!&#34;</span><span class="p">);</span></span></span></code></pre></div></div>
<p>每个运算符都有一个与之对应的函数</p>
<p>对于操作符重载时的返回值问题，有的虽然看起来不会有返回值其实也是有的，例如 <code>i += z</code>，返回值就应该是 <code>i</code>，所以 <code>(i += z) += y</code> 这样的操作也是可以的。</p>
<p>像 <code>+=</code> 这种都是类自己的成员函数，会被这个类型的变量所调用，所以对这种运算符重载，参数表只有一个参数，通过 <code>*this</code> 还是可以访问到那个变量。</p>
<p>假设实现 <code>+</code> 运算符的重载：</p>
<p></p>
<p>将重载的函数实现成成员函数还是非成员函数的一般规则：</p>
<ul>
<li>由于 C++的语义原因，一些操作符必须被实现为成员函数（例如<code>[]</code>, <code>()</code>, <code>-&gt;</code>, <code>=</code>）</li>
<li>还有一些必须实现为非成员函数（例如 <code>&lt;&lt;</code>，开发者不能覆盖掉 STL 库的实现，所以需要实现为非成员函数）</li>
<li>如果是一元操作符（例如 <code>++</code>）就实现为成员函数。</li>
<li>如果是二元操作符，而且对这两个变量的操作是一致的（即要么都修改，要么都不修改），就实现成非成员函数（例如 <code>+</code>, <code>&lt;</code>）。</li>
<li>如果是二元操作符，但是对这两个变量的操作不一致，就实现为成员函数（例如 <code>+=</code>）。</li>
</ul>
<p>如果非成员函数涉及到访问类的私有变量，可以考虑 <code>friends</code></p>
<p></p>
<p><strong>Principle of Least Astonishment (POLA)</strong></p>
<ul>
<li>设计一个操作符主要是为了模仿传统意义上该操作符的用法
<ul>
<li>比如之前提到的 <code>+=</code> 需要有一个返回值</li>
</ul>
</li>
<li>对称的运算符需要实现为非成员函数
<ul>
<li>这里说的对称的意思感觉就是运算符两边的表达式可以互换，举的例子是 <code>a + 1</code> 这样的，如果是成员函数的话 <code>1 + a</code> 就不能调用对应函数了。</li>
</ul>
</li>
<li>如果重载了一个运算符，它相关那一套都需要重载。
<ul>
<li>这里的一套就是上面介绍有哪些运算符中那个分类，一套说的是那里面的一类。</li>
</ul>
</li>
</ul>
<h2 id="special-member-functions">Special Member Functions</h2>
<p></p>
<p>它们特殊在如果开发者不自己实现的话，编译器会自动生成，但是编译器自动生成的有时候未必能满足开发者的需要。</p>
<p>这些函数就是：构造函数，析构函数，复制构造函数，复制运算符。其中，复制构造函数会创建一个新的变量（也是在创建新变量的时候被调用的）。</p>
<h3 id="copy-semantics">Copy Semantics</h3>
<p>编译器默认生成的复制构造函数会把很多信息都复制一遍，所以新变量和旧变量的指针会指向同一个内存，复制运算符会把要覆写的变量清空然后重新全部复制一遍。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Student</span><span class="p">(</span><span class="k">const</span> <span class="n">Student</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">name</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">name</span><span class="p">),</span> <span class="n">state</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">state</span><span class="p">),</span> <span class="n">age</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">age</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div></div>
<p>重载复制运算符的时候就不能像上面这样写初始化列表了，毕竟它不是构造函数（</p>
<p>当这个类有一些自己独有的资源时（比如指针，文件流），应该写自己的复制构造函数。</p>
<p>当要实现（删除）一个复制构造函数或者复制运算符或者析构函数的时候，你应该实现（删除）这三个所有。</p>
<h3 id="move-semantics">Move Semantics</h3>
<p>移动语义代表了 C++ 的一大哲学——尽量不要牺牲效率。</p>
<p>例如 <code>std::vector</code> 中有一个与 <code>push_back()</code> 类似的函数：<code>emplace_back()</code>。它和 <code>push_back()</code> 不同的是，它可以将参数在内部直接构造插入，而不是像 <code>push_back()</code> 需要创建一个已有的变量。<a href="https://en.cppreference.com/w/cpp/container/vector/emplace_back" target="_blank" rel="noopener noreffer ">cppreference 网站关于它的条目中</a> 有一个例子：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">President</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">country</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">year</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">President</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">p_name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">p_country</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p_year</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p_name</span><span class="p">)),</span> <span class="n">country</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p_country</span><span class="p">)),</span> <span class="n">year</span><span class="p">(</span><span class="n">p_year</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;I am being constructed.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">President</span><span class="p">(</span><span class="n">President</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">name</span><span class="p">)),</span> <span class="n">country</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">country</span><span class="p">)),</span> <span class="n">year</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">year</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;I am being moved.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">President</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">President</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">President</span><span class="o">&gt;</span> <span class="n">elections</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;emplace_back:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">elections</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">&#34;Nelson Mandela&#34;</span><span class="p">,</span> <span class="s">&#34;South Africa&#34;</span><span class="p">,</span> <span class="mi">1994</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">year</span> <span class="o">==</span> <span class="mi">1994</span> <span class="o">&amp;&amp;</span> <span class="s">&#34;uses a reference to the created object (C++17)&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">President</span><span class="o">&gt;</span> <span class="n">reElections</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">push_back:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">reElections</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">President</span><span class="p">(</span><span class="s">&#34;Franklin Delano Roosevelt&#34;</span><span class="p">,</span> <span class="s">&#34;the USA&#34;</span><span class="p">,</span> <span class="mi">1936</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">Contents:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">President</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">president</span><span class="p">:</span> <span class="n">elections</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">president</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; was elected president of &#34;</span>
</span></span><span class="line"><span class="cl">                  <span class="o">&lt;&lt;</span> <span class="n">president</span><span class="p">.</span><span class="n">country</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; in &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">president</span><span class="p">.</span><span class="n">year</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">President</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">president</span><span class="p">:</span> <span class="n">reElections</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">president</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; was re-elected president of &#34;</span>
</span></span><span class="line"><span class="cl">                  <span class="o">&lt;&lt;</span> <span class="n">president</span><span class="p">.</span><span class="n">country</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; in &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">president</span><span class="p">.</span><span class="n">year</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>可以看到：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span><span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">elections</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">&#34;Nelson Mandela&#34;</span><span class="p">,</span> <span class="s">&#34;South Africa&#34;</span><span class="p">,</span> <span class="mi">1994</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">reElections</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">President</span><span class="p">(</span><span class="s">&#34;Franklin Delano Roosevelt&#34;</span><span class="p">,</span> <span class="s">&#34;the USA&#34;</span><span class="p">,</span> <span class="mi">1936</span><span class="p">));</span></span></span></code></pre></div></div>
<p></p>
<p></p>
<p>移动构造函数和移动符号的函数原型如下：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Student</span><span class="p">(</span><span class="n">Student</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Student</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Student</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span></span></span></code></pre></div></div>
<p>但是虽然参数列表里面写的是 <code>&amp;&amp;</code> 右值引用，但是在函数体内部，这个引用本身是一个左值，常规的 <code>=</code> 不再是移动而是复制。为了让复制变成移动，需要用到 <code>std::move()</code>，它会接受一个左值并返回相应的右值。经验之谈：在类成员函数中，如果接受一个 <code>const &amp;</code> 参数并在函数内部将其赋值给其他变量，那么通常可以使用 <code>std::move</code>，除此之外不要使用它。</p>
<p>如果一个类定义了复制构造函数和复制运算符，那么应该也实现一份移动构造函数和移动运算符。</p>
<p></p>
<p></p>]]></description>
</item>
<item>
    <title>CS106L: Templates</title>
    <link>http://localhost:1313/posts/cs106l_template_algorithms/</link>
    <pubDate>Sat, 03 Feb 2024 03:42:51 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cs106l_template_algorithms/</guid>
    <description><![CDATA[<p>CS106L 中关于 Templates 的部分</p>
<h1 id="templates">Templates</h1>
<h2 id="templates-function">Templates Function</h2>
<p>template 应该算得上很自然的想法（🤔 又或者是套娃的另一次应用），我认为这就是对函数的进一层抽象，它将函数的逻辑抽象成与类型无关，比如</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">min</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="o">=</span><span class="kt">int</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">Type</span> <span class="n">myMin</span><span class="p">(</span><span class="n">Type</span> <span class="n">a</span><span class="p">,</span> <span class="n">Type</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>这里的 <code>typename</code> 没有指明类型，实际上可以写成 <code>class T</code>，这样这个函数就不会接受 int 之类的类型。那个 <code>=int</code> 表示其默认类型（虽然我还没认识到写它的意义）。</p>
<p>可以针对性的再写一个特定类型的模板函数:</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="kt">void</span> <span class="n">print_msg</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;print_msg called with float type!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">add3</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">minvar</span> <span class="o">=</span> <span class="n">min</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span></span></span></code></pre></div></div>
<p>隐式存在一个问题在于参数的类型未必能被识别出来（有些类型的定义方式差不多）。不过貌似编译器这时候会报错。</p>
<p>从一个实际的类型推广到一个模板，这个过程被称为 <em>Concept Lifting</em>。对于隐式类型的来说，这种提升可能会导致传入一些不可以工作的类型（比如函数内部使用了 <code>=</code> 赋值，但 stream 是不可以这样做的）</p>
<p>毕竟有了函数指针，其实可以把抽象做的更细一些。比如 <em>Predicate Functions</em></p>
<p></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">InputIt</span><span class="p">,</span> <span class="k">typename</span> <span class="n">UniPred</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">count_occurrences</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">begin</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">end</span><span class="p">,</span> <span class="n">UniPred</span> <span class="n">pred</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">))</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">isVowel</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">vowels</span> <span class="o">=</span> <span class="s">&#34;aeiou&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">vowels</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;Xadia&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">count_occurrences</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">isVowel</span><span class="p">);</span></span></span></code></pre></div></div>
<p>C++20 允许开发者显示指定其 template 类型的要求，具体可以参见文档：<a href="https://en.cppreference.com/w/cpp/language/constraints" target="_blank" rel="noopener noreffer ">Constraints and concepts (since C++20)</a> 和 <a href="https://en.cppreference.com/w/cpp/language/requires" target="_blank" rel="noopener noreffer ">Requires expression (since C++20)</a></p>
<h2 id="lamdba--algorithms">Lamdba &amp; Algorithms</h2>
<p>Lamda function:</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[</span><span class="n">capture</span><span class="o">-</span><span class="n">clause</span><span class="p">](</span><span class="n">parameters</span><span class="p">)</span><span class="o">-&gt;</span><span class="k">return</span><span class="o">-</span><span class="n">value</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div></div>
<p>C++14 开始，这个 <code>return-value</code> 是可选的。</p>
<p></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="p">[]</span> <span class="c1">// captures nothing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="n">limit</span><span class="p">]</span> <span class="c1">// captures lower by value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="o">&amp;</span><span class="n">limit</span><span class="p">]</span> <span class="c1">// captures lower by reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="o">&amp;</span><span class="n">limit</span><span class="p">,</span> <span class="n">upper</span><span class="p">]</span> <span class="c1">// captures lower by reference, higher by value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">limit</span><span class="p">]</span> <span class="c1">// captures everything except lower by reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="c1">// captures everything by reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="c1">// captures everything by value
</span></span></span></code></pre></div></div>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">isMoreThan</span> <span class="o">=</span> <span class="p">[</span><span class="n">limit</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">isMoreThan</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span> <span class="c1">//true
</span></span></span></code></pre></div></div>
<p>有了这个之后，也就不需要像之前那样定义<em>Predicate Functions</em>了，可以直接写 lamdba。</p>
<p>STL 的一些 algorithm 不能用于开发者自定义的类型（比如寻找最小值之类的），这时候需要用到 lambda 函数。</p>
<p>比如对于这样的 vector:</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">vecstu</span><span class="p">{{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">}};</span></span></span></code></pre></div></div>
<p>直接使用 <code>std::minmax_element()</code> 是无法通过编译的</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="p">[</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span><span class="n">vecstu</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecstu</span><span class="p">.</span><span class="n">end</span><span class="p">());</span></span></span></code></pre></div></div>
<p>额，根据我看到的录像那里，其开发环境是没有在编译前给出预警的。但是我的 vscode 在只给了两个参数的时候：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-text">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">In template: invalid operands to binary expression (&#39;Student&#39; and &#39;Student&#39;) clang(typecheck_invalid_operands)</span></span></code></pre></div></div>
<p>这时候就可以加一个 lamdba 函数，并传给 <code>minmax_element()</code></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">compareStudent</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Student</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="n">Student</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">averge</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">averge</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div></div>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="p">[</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span><span class="n">vecstu</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecstu</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">compareStudent</span><span class="p">);</span></span></span></code></pre></div></div>
<p>在 <code>std::copy</code> 这个函数中，如果传入的 iterator 指向的 container 没有足够的空间，那么就会复制到为初始化的内存中，这时候应该传入一个 iterator adaptor。这种函数可以给 iterator 加点料（比如 <code>back_inserter()</code> 会让返回的 iterator 在赋值不存在的空间时扩展 container）。</p>
<p>引用上一章一开始给出的代码：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">generate</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">rand</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>]]></description>
</item>
<item>
    <title>CS106L: Containers &amp; Iterators</title>
    <link>http://localhost:1313/posts/cs106l_container_iterator/</link>
    <pubDate>Fri, 02 Feb 2024 03:42:51 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cs106l_container_iterator/</guid>
    <description><![CDATA[<p>CS106L 中关于 container 和 iterators 的部分</p>
<h1 id="containers">Containers</h1>
<p>STL 是一个历史相较悠久并且一直在更新的一个标准库，它提供了很多算法供开发者使用</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">generate</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">rand</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>这 5 行代码，就完成了对 vector 元素的随机化赋值并排序，然后输出到 console 上这一系列的工作。</p>
<h2 id="sequence-containers">Sequence Containers</h2>
<p>这是一种数据结构，提供了对元素序列的访问</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">foraword_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></span></span></code></pre></div></div>
<p></p>
<p>如果越界访问，<code>vec.at(i)</code> 会抛出一个异常，而 <code>vec[i]</code> 会是一个 undefined behavior</p>
<p>Sequence Containers 是一种特殊的 Containers，因为它是顺序的。</p>
<p>正如关于数组和链表之间老生长谈的对比一样，在 vector 的前面添加一个元素还是很难绷的，C++提供了另一种数据结构处理这种情况：<code>std::deque&lt;T&gt;</code></p>
<p>vector 有 <code>push_back()</code> 函数添加变量，deque 除了 <code>push_back()</code> 有 <code>push_front()</code> 可以在前面插入</p>
<p>A <strong>deque</strong> is a <strong>d</strong>ouble <strong>e</strong>nded <strong>que</strong>ue</p>
<p>deque 的实现是将多个 vector 作为枝干，一个 vector 作为主干。如果你从后插入，那就将元素插入最后面枝叶里面，如果最后面那个满了就给主干多加一个，如果主干满了不能加枝叶了那就换一个更长的主干。插入前面是类似的操作。</p>
<p>有两种经典的数据结构——栈和队列，在这里它们被称为 <em>Container Adaptors</em>。它们会通过对 Container 做一些调整来适应它们自身数据结构的定义。在 C++ 文档中，它们的描述都会有这么一句：</p>
<blockquote>
<p>The std::stack class is a container adaptor that gives the programmer the functionality of a stack - specifically, a LIFO (last-in, first-out) data structure.
The std::queue class is a container adaptor that gives the functionality of a queue - specifically, a FIFO (first-in, first-out) data structure.</p>
</blockquote>
<p>正如 C++ 设计哲学所说的那句赋予开发者完全的掌控权，所以 stack 虽然是默认用 deque 实现的，但开发者可以自己选择使用什么 container（比如 vector）实现的 stack。（在文档中也有叙述：<a href="https://en.cppreference.com/w/cpp/container/stack" target="_blank" rel="noopener noreffer ">std::stack</a></p>
<p>额，按照我的理解，这句话所说的代码应该是这么写：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">st</span><span class="p">;</span></span></span></code></pre></div></div>
<p>查找 vector 可以使用<code>std::find</code></p>
<h2 id="associative-containers">Associative Containers</h2>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></span></span></code></pre></div></div>
<p>正如前面所说，Sequence Containers 是顺序的，可以通过索引来访问，而 Associative Containers 是不能通过索引来访问的。</p>
<p>虽然是不能通过索引访问，但是 <code>std::map&lt;T1, T2&gt;</code> 和 <code>std::set&lt;T&gt;</code> 会按照大小顺序排列。如果这里存储的是开发者自定义的类型，可以定义用于比较两个实例的大小的小于号帮助它按照顺序排列。vector 会有 sort 函数用于排序，这里面也是会存在这个问题，如果 vector 存储的是开发者自定义的类型，要么是实现这个类型的小于号，要么使用 lamdba 函数</p>
<p></p>
<p></p>
<p><code>map.at(key)</code> 和 <code>may[key]</code> 区别类似之前提到的，前者不存在的话会抛出异常，后者默认创建它。</p>
<p>可以通过<code>map.count(key)</code> 来查看是否存在。C++20 也支持了<code>var.contains()</code> 来查找：<a href="https://en.cppreference.com/w/cpp/container/set/contains" target="_blank" rel="noopener noreffer ">std::set&lt;Key,Compare,Allocator&gt;::contains</a>，<a href="https://en.cppreference.com/w/cpp/container/map/contains" target="_blank" rel="noopener noreffer ">std::map&lt;Key,T,Compare,Allocator&gt;::contains</a>。</p>
<p>map 的 key 重复出现的话被称为 <em>multimap</em></p>
<h2 id="iterators">Iterators</h2>
<p>它允许开发者迭代访问任何 containers</p>
<p>比如 <code>map.begin()</code>，它会返回一个 iterator，这个 iterator 指向第一个元素。就像这样：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">mymap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span></span></span></code></pre></div></div>
<p><code>++it</code> 会让这个 iterator 指向下一个元素。<code>*it</code> 可以访问这个 iterator 实际指向的值，这里也可以发现 iterator 和指针是差不多玩意。</p>
<p>map 的 iterator 和其他的 container 有些不同——因为 map 有两个值，它的 iterator 实际上是 <code>std::pair&lt;string, int&gt;</code></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">mymap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">mymap</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">thing</span> <span class="p">:</span> <span class="n">mymap</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">thing</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>在 vector 中，iterator 可以通过 <code>begin() + 3</code> 这样的方式挪动，但 <code>std::list</code> 等就不可以这么做，这是因为 container 的实现略有不同，但是 iterators 的实现就为了消除 containers 的区别从而用一种通用的方式调用 container。所以存在 5 种 iterator。</p>
<ol>
<li>Input</li>
<li>Output</li>
<li>Forward</li>
<li>Bidirectional</li>
<li>Random Access</li>
</ol>
<p>上述的这几种 iterator 都有上面所介绍的那些功能（<code>++it</code>什么的）</p>
<p>第一种 input iterator 只能被读，只能向前走，而且只能+1，比如 <code>find()</code> 或者 <code>count()</code> 这样的只需要遍历的地方中就会用到它，C++文档中也有描述：</p>
<p></p>
<p>Output iterator 和 input iterator 类似，只不过是只写的。<code>copy</code>这个函数会用到这个</p>
<p></p>
<p>Forward iterator 同时具有 output iterator 和 input iterator 的特点，即 RW 它都拿到了。<code>replace()</code> 函数会用到这个，还有就是之前 Sequence Containers 上提到的<code>std::foraword_list&lt;T&gt;</code></p>
<p></p>
<p>Bidirectional iterator 具有 Forward iterator 的功能，并且这个可以 <code>--</code>。在 <code>std::map</code>，<code>std::set</code>，<code>std::list</code>，或者<code>reverse()</code> 中会看到</p>
<p></p>
<p>Random access iterator 具有 Bidirectional iterator 的功能并且不受递增递减的约束，而是可以随意访问。在<code>std::vertor</code>，<code>std::string</code>，pointer 中都会使用它，所以这个是最常用的。</p>]]></description>
</item>
<item>
    <title>CS106L: Streams &amp; Type</title>
    <link>http://localhost:1313/posts/cs106l_stream_type/</link>
    <pubDate>Thu, 01 Feb 2024 03:42:51 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cs106l_stream_type/</guid>
    <description><![CDATA[<p>CS106L 中关于 Streams 和 type 的部分</p>
<h1 id="streams">Streams</h1>
<h2 id="string-stream">String Stream</h2>
<p>使用 Stream 缘于程序需要与外部资源交互。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ostringstream</span> <span class="n">oss</span><span class="p">(</span><span class="s">&#34;Ito En Green Tea&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="mf">16.9</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; Ounce &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>使用 g++ 编译并运行：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ g++ -std<span class="o">=</span>c++17 test.cpp -o <span class="nb">test</span>
</span></span><span class="line"><span class="cl">$ ./test
</span></span><span class="line"><span class="cl">Ito En Green Tea
</span></span><span class="line"><span class="cl">16.9 Ounce n Tea</span></span></code></pre></div></div>
<p>因为 stream 创建后，指针处于头部，所以写入的时候会从头部开始覆盖写入，如果给 <code>oss()</code> 传入其他参数可以控制这个模式，比如改成 <code>ostringstream oss(&quot;Ito En Green Tea&quot;, stringstream::ate);</code> 之后，指针会指向尾端。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-c">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">istringstream</span> <span class="nf">iss</span><span class="p">(</span><span class="n">oss</span><span class="p">.</span><span class="nf">str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">ammount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">struint</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">ammount</span> <span class="o">&gt;&gt;</span> <span class="n">struint</span><span class="p">;</span></span></span></code></pre></div></div>
<p><code>iss</code> 在输出的时候会根据空格分隔这个 stream。</p>
<p>对于移动 stream 指针的需求，可以使用下边这份代码：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-c">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ostringstream</span> <span class="nf">oss</span><span class="p">(</span><span class="s">&#34;Ito En Green Tea &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="mf">16.9</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">fpos</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">oss</span><span class="p">.</span><span class="nf">tellp</span><span class="p">()</span> <span class="o">+</span> <span class="nf">streamoff</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">oss</span><span class="p">.</span><span class="nf">seekp</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Black&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">oss</span><span class="p">.</span><span class="nf">good</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p><code>i/ostringstream</code> 都有快速的错误检查，分别为<code>good()</code>、<code>fail()</code>、<code>eof()</code>、<code>bad</code>。</p>
<ul>
<li>good: ready for read/write.</li>
<li>fail: previous operation failed, all future operation frozen.</li>
<li>eof: previous operation reached the end of buffer content.</li>
<li>bad: external error, likely irrecoverable.</li>
</ul>
<p><code>iss.good()</code> 就会返回一个 bool 表示该 stream 是否出错。类似：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">iss</span><span class="p">.</span><span class="n">fail</span><span class="p">())</span>  <span class="k">throw</span> <span class="n">domain_error</span><span class="p">(...);</span></span></span></code></pre></div></div>
<p>还有一种隐式转换成 bool 的写法会更简短，二者是等价的：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-c">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">ch</span><span class="p">))</span>  <span class="n">throw</span> <span class="nf">domain_error</span><span class="p">(...);</span></span></span></code></pre></div></div>
<p>比如一个将 string 转为 int 的函数可以这么写：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">stringToInteger</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">istringstream</span> <span class="n">iss</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">result</span><span class="p">;</span> <span class="kt">char</span> <span class="n">remain</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">)</span> <span class="o">||</span> <span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">remain</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="n">domain_error</span><span class="p">(...);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>什么时候应该使用 string stream</p>
<ul>
<li>处理字符串的时候</li>
<li>格式化输出或输入（一些 stream manipulators，比如 endl, hex, uppercase 之类的）</li>
<li>解析成不同的类型</li>
</ul>
<h2 id="input-stream--output-steam">Input stream &amp; Output steam</h2>
<ul>
<li>cin, standard input stream</li>
<li>cout, standard output stream (buffered)</li>
<li>cerr, standard error stream (unbuffered)</li>
<li>clog, standard error stream (buffered)</li>
</ul>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">home</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;What is your name?&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;What is your age?&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Where are you from?&#34;</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">home</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello, &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; (age &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; from &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">home</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;)&#34;</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></div></div>
<p>对于上面这段代码，如果你输入 Avery Wang，程序会直接走到终点：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ g++ -std<span class="o">=</span>c++17 -Wall test.cpp -o <span class="nb">test</span>
</span></span><span class="line"><span class="cl">$ ./test
</span></span><span class="line"><span class="cl">What is your name ?
</span></span><span class="line"><span class="cl">Avery Wang
</span></span><span class="line"><span class="cl">What is your age ?
</span></span><span class="line"><span class="cl">Where are you from ?
</span></span><span class="line"><span class="cl">Hello, Avery <span class="o">(</span>age <span class="m">0</span> from <span class="o">)</span></span></span></code></pre></div></div>
<p><code>cin</code> 会读到下一个空白符，所以第一个 <code>cin</code> 只会把 <code>Avery</code> 读进去，并且指针更新到了那个空白符的位置，之后 <code>cin &gt;&gt; age</code> 的时候，由于 buffer 不为空，所以会直接尝试把 <code>Wang</code> 读成 int，但是失败了，这时候 fail bit 打开，之后的 <code>cin</code> 也不会进行了。</p>
<p>这就是<code>cin</code>带来的问题了：</p>
<ol>
<li><code>cin</code> 会读一整行到 buufer 中，但是会用空格符分隔开递出。</li>
<li>buffer 中可能会有残余的数据导致用户无法及时地被提示应该输入</li>
<li><code>cin</code> fail 了之后就再也不会执行 <code>cin</code> 了</li>
</ol>
<p>如果使用<code>getline()</code>，就可以避免这个问题。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span></span></span></code></pre></div></div>
<p>第三个参数就是一个标记，<code>getline()</code> 会读到这个字符之前（也就是不包括这个字符），并把指针更新到这个字符之后。但如果你把第三个 <code>home</code> 变量的读取也改成了 <code>getline()</code> 读取，程序运行的时候会跳过它，因为 <code>cin &gt;&gt; age</code> 把指针更新到了 <code>\n</code> 之前，而 <code>getline()</code> 会直接读到 <code>\n</code> 之前（也就是空数据）。就像这样：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">A</td>
          <td style="text-align: center">v</td>
          <td style="text-align: center">e</td>
          <td style="text-align: center">r</td>
          <td style="text-align: center">y</td>
          <td style="text-align: center">_</td>
          <td style="text-align: center">W</td>
          <td style="text-align: center">a</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">g</td>
          <td style="text-align: center">\n</td>
          <td style="text-align: center">2</td>
          <td style="text-align: center">0</td>
          <td style="text-align: center">\n</td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>这里的<code>_</code>指的是空格符。</p>
<p>可以在第二个 <code>getline()</code> 之前加上一句 <code>cin.ignore()</code> 跳过一个字符（也就是<code>\n</code>）来解决这个问题。</p>
<p><code>std::cout</code> 是 <code>std::ostream</code> 定义的全局的 constant 对象，<code>std::ostream</code> 会将输入的数据类型都转成 string 并发送到 stream，而 <code>std::cout</code> 是会将这个 output stream 发送到 console 上。</p>
<p><code>std::cin</code> 是 <code>std::istream</code> 定义的全局 constant 对象。这里的 <code>&gt;&gt;</code> 会一直读取用户的输入直到 <em>whitespace</em>，这里的 whitespace 是指 Tab, space, newline。</p>
<h2 id="file-stream">File Stream</h2>
<p><code>std::ofstream</code>，只能用 <code>&lt;&lt;</code> 操作符传递数据，它会将数据类型转成 string 并发送到 file stream 上。</p>
<p><code>std::ifstream</code>，只能用 <code>&gt;&gt;</code> 操作符传递数据。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">out</span><span class="p">(</span><span class="s">&#34;out.txt&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// out is now an ofstream that outputs to out.txt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// out.txt contains 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">in</span><span class="p">(</span><span class="s">&#34;out.txt&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// in is now an ifstream that reads from out.txt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">in</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">;</span> <span class="c1">// first word in out.txt goes into str
</span></span></span></code></pre></div></div>
<hr>
<p>Uniform initialization: 使用大括号来初始化变量，适用于所有类型</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">numSuffix1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="s">&#34;st&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Student</span> <span class="n">s</span><span class="p">{</span><span class="s">&#34;Frankie&#34;</span><span class="p">,</span> <span class="s">&#34;MN&#34;</span><span class="p">,</span> <span class="mi">21</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">possible</span><span class="o">!</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span><span class="p">{</span><span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">f</span><span class="p">{</span><span class="s">&#34;Frankie&#34;</span><span class="p">};</span></span></span></code></pre></div></div>
<p>但要注意对 vector 大括号和括号之间的区别：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec1</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// makes {5, 5, 5}, not {3, 5}!
</span></span></span><span class="line"><span class="cl"><span class="c1">//uses a std::initializer_list (more later)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec2</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// makes {3, 5}
</span></span></span></code></pre></div></div>
<hr>
<h1 id="type">Type</h1>
<h2 id="type-alias">Type alias</h2>
<p>类型别名是一个很有用的东西，比如对于下边这样的代码：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">forward_list</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">unordered_set</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">studentMap</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">forward_list</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">unordered_set</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">end</span> <span class="o">=</span> <span class="n">studentMap</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span></span></span></code></pre></div></div>
<p>可以使用别名简化</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">map_iterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">forward_list</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">unordered_set</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">map_iterator</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">studentMap</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">map_iterator</span> <span class="n">end</span> <span class="o">=</span> <span class="n">studentMap</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span></span></span></code></pre></div></div>
<p>C++引入了 <code>auto</code> 关键字，<code>auto</code> 的本质是要让编译器找出这个类型。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">studentMap</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">studentMap</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span></span></span></code></pre></div></div>
<p>又比如这样：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">};</span></span></span></code></pre></div></div>
<p>这是一个 lamdba 函数，你并不知道这是什么类型，编译器会自动为此创建一个类的实例，由于开发者不知道编译器会为这个类起什么名字，所以需要用 <code>auto</code>。</p>
<h2 id="when-auto-should-be-used">When <code>auto</code> should be used</h2>
<p>AAA 原则： almost always auto</p>
<ul>
<li>在代码上下文清晰的时候使用<code>auto</code></li>
<li>当用确切的类型定义不重要的时候使用<code>auto</code></li>
<li>当严重破坏了可读性的时候不要使用<code>auto</code></li>
</ul>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">findPriceRange</span><span class="p">(</span><span class="kt">int</span> <span class="n">dist</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dist</span> <span class="o">*</span> <span class="mf">0.08</span> <span class="o">+</span> <span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dist</span> <span class="o">*</span> <span class="mf">0.36</span> <span class="o">+</span> <span class="mi">750</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">make_pair</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="mi">6452</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="p">[</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">]</span> <span class="o">=</span> <span class="n">findPriceRange</span><span class="p">(</span><span class="n">dist</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;You can find price between: &#34;</span>
</span></span><span class="line"><span class="cl">         <span class="o">&lt;&lt;</span> <span class="n">min</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; and &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">max</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>这样的代码更加的现代一些，<code>findPriceRange()</code> 函数只需要传一个参数<code>dist</code>，返回 <code>min</code> 和 <code>max</code> 的 pair，这样也更加自然（对比传入三个参数：dist, min, max）。</p>
<p>像上面这个代码寻找区间的代码写成库函数给开发者调用的话是很不友好的，因为返回值没有做出更好的区分表明到底谁是 min，谁是 max，这时候可以使用结构体来对返回值进行一层抽象。不过在 C++中，结构体定义变量的时候 <code>struct</code> 关键字是可选的，比如：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Student</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Student</span> <span class="n">st</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;age: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, number: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></div></div>
<p>在 C 中，这需要<code>typedef</code>才能实现</p>
<p>Structured binding：一次性将复合类型变量的元素取值操作完成</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="err">“</span><span class="n">s</span><span class="err">”</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">;</span></span></span></code></pre></div></div>
<p>使用了 Structured binding 就可以写成下边这样：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="err">“</span><span class="n">s</span><span class="err">”</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span></span></span></code></pre></div></div>
<p>C++ 默认赋值是 copy 的，如果函数传参涉及修改原数据应该用 <code>&amp;</code> 引用，如果在其函数内部会出现对这种参数的赋值，也需要加 <code>&amp;</code> ：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">shift</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">num1</span><span class="p">,</span> <span class="n">num2</span><span class="p">]</span><span class="o">:</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">num1</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">num2</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>]]></description>
</item>
</channel>
</rss>
