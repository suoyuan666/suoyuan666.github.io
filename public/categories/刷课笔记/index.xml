<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>刷课笔记 - Category - 索元的博客</title>
        <link>http://localhost:1313/categories/%E5%88%B7%E8%AF%BE%E7%AC%94%E8%AE%B0/</link>
        <description>刷课笔记 - Category - 索元的博客</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>s5n666@outlook.com (suo yuan)</managingEditor>
            <webMaster>s5n666@outlook.com (suo yuan)</webMaster><lastBuildDate>Mon, 12 Aug 2024 22:28:09 &#43;0000</lastBuildDate><atom:link href="http://localhost:1313/categories/%E5%88%B7%E8%AF%BE%E7%AC%94%E8%AE%B0/" rel="self" type="application/rss+xml" /><item>
    <title>TCP 的错误检测 &amp; 流量控制 &amp; 状态转换</title>
    <link>http://localhost:1313/posts/cs144_notes_004/</link>
    <pubDate>Mon, 12 Aug 2024 22:28:09 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cs144_notes_004/</guid>
    <description><![CDATA[<p>CS114 课程的课程笔记</p>
<h1 id="tcp-的错误检测--流量控制--状态转换">TCP 的错误检测 &amp; 流量控制 &amp; 状态转换</h1>
<h2 id="错误检测">错误检测</h2>
<p>通常使用三种检测手段：校验和，循环冗余码CRC和消息认证码。例如，Ethernet 附加循环冗余码，TLS 附加消息认证，IP 附加校验和</p>
<ul>
<li>校验和
<ul>
<li>计算快速，由软件做校验和运算也不会有太大的消耗</li>
<li>并不可靠，如果两个错误的码相互抵消，比如一个位错误地加 2，另一个位错误地减 2，校验和就捕获不到这个错误。</li>
</ul>
</li>
<li>CRC
<ul>
<li>很多链路层会使用，计算代价更加大</li>
<li>比校验和更可靠</li>
<li>一般来说，链路层使用了 CRC，TCP/IP 甚至可以不使用校验和，n 位的 CRC 可以检测任何小于等于 n 位长度的错误。</li>
</ul>
</li>
<li>消息验证码 (message authentication code，MAC)
<ul>
<li>就是消息摘要算法</li>
<li>TLS 使用</li>
<li>很可靠，但不容易排错</li>
</ul>
</li>
</ul>
<h3 id="校验和">校验和</h3>
<p>IP，TCP，UDP 都使用补码校验和，一些较老一些的计算机使用的是二进制算数版本。</p>
<p>将校验和字段设为 0，后取数据包的 16 bit 相加，0x8000 + 0x8000 = 0x0001。最后取反，如果结果为 0xffff，那就不取反，直接用 0xffff。0 表示没有校验和。</p>
<p>校验的时候是将校验和和数据都再加一次，看看是不是 0xffff。</p>
<p>早期 Internet 通过软件实现校验和</p>
<h3 id="crc">CRC</h3>
<p>如果是 n 为的数据，需要以某种方式分成 c 为错误检测数据，c 比 n 小得多。</p>
<p>如果有 1500 字节的 Ethernet 就携带 4 字节 32 bit CRC，USB 和蓝牙使用 16 bit。</p>
<p>CRC 无法检测所有错误，有 $2^{-c}$ 几率无法检测到。例如对于 8 bit的 CRC 而言，两个不同的数据的 CRC 相同的概率就是 $\frac{1}{256}$，即 0.4%。</p>
<p>对于一个多项式 M，其每一位都是 1 的系数，即 <code>M = 1001 = x^4 + 1</code>。</p>
<p>当计算 CRC 时，需要使用 CRC 算法定义的生成多项式 G。例如 CRC-16 算法的生成多项式 0x8005 = x^16 + x^15 + x^2 + 1。由于历史原因，生成多项式的比其位数长一位（其第一项始终为 1）。</p>
<p>计算 CRC：获许消息 M，用 CRC 长度的 0 填充它，将这个值和 G 相除，其余数就是 CRC。将 CRC 附加到消息上，得到 M&rsquo; = M + CRC。如果 M&rsquo; 和 G 的余数是 0，则通过测试。</p>
<h3 id="mac">MAC</h3>
<ol>
<li>不同长度的输入，产生固定长度的输出</li>
<li>散列后的密文不可逆</li>
<li>散列后的结果唯一（不太严谨）</li>
<li>哈希碰撞</li>
<li>一般用于检验数据完整性（签名sign）</li>
<li>消息摘要算法也叫单向散列函数、哈希函数</li>
</ol>
<p>MAC 和其他消息摘要算法（如 MD5，SHA256 等）不同的是多了一个密钥。</p>
<h2 id="流量控制">流量控制</h2>
<p>流量控制要解决通信双方处理数据包的速度不一致的问题。最简单的就是 stop and wait，但现在都会选择 sliding window。</p>
<h3 id="stop-and-wait">stop and wait</h3>
<p>就是发送方发一个就等待这个包的 ack，超时了就重发。</p>
<h3 id="sliding-window">sliding window</h3>
<p>sliding window 就是维护一个 window，window size 就是一次性能发送或接收的数据包的数量。</p>
<p>并且可以只发一个 ack 包确认发送的所有数据包。</p>
<p>超时重发有两种选择:</p>
<ul>
<li>window 里的包全部重发</li>
<li>只重发第一个</li>
</ul>
<p>如果接收方的 window size 为 1 的话，就需要全部重发，因为接收方没有缓存。一般发送的量不多的时候会选择全部重发的策略。</p>
<h2 id="tcp-header">TCP header</h2>
<p></p>
<ul>
<li>window
告诉对方自己的 window size</li>
<li>Flags
<ul>
<li>U
<ul>
<li>表明该数据应该优先被处理</li>
</ul>
</li>
<li>P
<ul>
<li>表明应该立即将已接收的数据传递给应用程序，而不是等待缓冲区填满</li>
</ul>
</li>
<li>A,R,S,F
<ul>
<li>ack, reset, syn, fin</li>
</ul>
</li>
</ul>
</li>
<li>offset
<ul>
<li>tcp header 的长度</li>
</ul>
</li>
<li>padding
<ul>
<li>帮助 header 对齐</li>
</ul>
</li>
</ul>
<h2 id="tcp-状态图">TCP 状态图</h2>
<p></p>
<blockquote>
<p>图片来自 <a href="https://en.wikipedia.org/wiki/File:Tcp_state_diagram_fixed.svg" target="_blank" rel="noopener noreffer ">https://en.wikipedia.org/wiki/File:Tcp_state_diagram_fixed.svg</a></p>
</blockquote>
<p>蓝色的线表示服务器，红色的是客户端。</p>
<p>服务器打开就进入 <code>LISTEN</code> 状态，关闭就回到 <code>CLOSED</code> 状态</p>
<p>客户端先发送 SYN 进入 <code>SYN SENT</code> 状态，服务器收到后发送 SYN ACK 进入 <code>SYN RECEIVED</code> 状态。</p>
<p>客户端收到了 SYN ACK 再发送 ACK 并进入 <code>ESTABLISHED</code> 状态，服务器收到了 ACK 包后也会进入这个状态，自此双方建立连接。</p>
<p>但同时还有一种路径，就是虚线那条，服务器 <code>LISENSE</code> 状态可以主动发 SYN 包，客户端处于 <code>SYN SENT</code> 状态收到后再向服务器发送一个 <code>SYN ACK</code> 包，这样是双方都发送了 SYN，并收到了对方的 ACK。</p>
<p>下面的就是关于连接的关闭，服务器收到 FIN 之后回一个 ACK，服务器这里需要把数据发送完后 close，之后再发送 FIN。</p>
<p>客户端这里 close 之后就发送一个 FIN，并且再收到 FIN-ACK 或者 FIN 的时候就开始清理资源准备 close，如果只收到了 ACK，表示对方数据还没发送完，则继续等待</p>]]></description>
</item>
<item>
    <title>TCP &amp; UDP &amp; ICMP</title>
    <link>http://localhost:1313/posts/cs144_notes_003/</link>
    <pubDate>Fri, 26 Jul 2024 00:01:22 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cs144_notes_003/</guid>
    <description><![CDATA[<p>CS114 课程的课程笔记</p>
<h2 id="tcp-服务">TCP 服务</h2>
<p>TCP (Transmission Control Protocol4) 提供了 可靠的，端到端的，双向的字节流服务。TCP 是传输层的协议。</p>
<p>将两个主机之间的 TCP 通信称为连接 (connection)。在连接的两端，TCP 会保留一个状态机去跟踪连接在做什么。</p>
<p>A 主机和 B 主机需要三次握手后建立 TCP 连接。</p>
<ol>
<li>A 向 B 发送一条信息表示 A 处的 TCP 层 希望和 B 建立连接，该消息称为 SYN 消息。因为 A 还会发送其将用来识别字节流中的字节的基数，如果发送 0 ，表示将会从 0 开始。</li>
<li>B 会回复一个 SYN-ACK，B 发出 SYN 信号，因为 B 确认 A 的请求并同意建立连接。B 的 TCP 层还会发送一个 SYN 给 A，以表示它希望建立连接，并且发送一个数字以表明字节流起始编号。</li>
<li>A 回复一个 ACK，表示它正在接收通信请求。</li>
</ol>
<p>当 A 和 B 完成相互之间的数据发送之后，它们需要关闭连接，并在之后都开始清理与状态机关联的状态。</p>
<ol>
<li>A 上的 TCP 层可以通过发送 FIN 信息以关闭连接。</li>
<li>B 确认 A 不再有要发送的数据，并停止从 A 中获取数据。
<ul>
<li>但 B 可能仍有新数据要发送，并且还没有准备管理连接，所以回复的 ACK 还可以将新数据从 B 发送到 A。B 可以一致向 A 发送新数据。</li>
<li>等 B 把数据都发送完了，就发送自己的 FIN 给 A。</li>
</ul>
</li>
<li>A 再发送一个 ACK 进行确认，以确认连接现已关闭。</li>
</ol>
<p>现在就是正式关闭，状态也可以安全移除。</p>
<p>通过以下四个方式保证了可靠地发送:</p>
<ol>
<li>当 TCP 层接收到数据时，它将确认 ACK 给发送方使其知道数据已送达。</li>
<li>checksum 检测损坏的数据，TCP header 带有一个 checksum，覆盖了报头和内部的数据，以检测在途中是否存坏。</li>
<li>序列号检测丢失的数据，每个段的 header 都包含字节序列中的序列号。例如双方都同一序列号从 1000 开始，则第一个段的序号就是 1000，如果这个段有 500 字节数据，那下一个段的序列号应该是 1500。
<ul>
<li>如果段丢失，就能通过序列号发现，这时候就需要发送方重发数据。</li>
</ul>
</li>
<li>流量控制以防止接收器超速运行。
<ul>
<li>防止 A 发包速度比 B 处理快多了，B 处理不过来的情况。</li>
<li>在 TCP 中，接收方不断询问发送方是否可以继续发送，也就是告诉发送方其缓冲区并还有多少空间可以接收新数据。</li>
</ul>
</li>
</ol>
<p>TCP 按照正确的顺序将数据传送到应用程序。</p>
<p>TCP 会尝试平衡所有 TCP 连接之间的网络容量，也就是 Congestion Control。</p>
<ul>
<li>Flag
<ul>
<li>ACK, 确认序列号有效</li>
<li>SYN, 正在发送同步信号，这是三次握手的一部分</li>
<li>FIN, 表示连接一个方向的关闭</li>
<li>PSH, 告诉另一端 TCP 立即传送数据，而不是等待更多的数据
<ul>
<li>对于携带与时间相关的数据（比如按键）来说有用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="udp-服务">UDP 服务</h2>
<p>UDP (User Datagram Protocol)并不保证可靠的到达，只提供简单的送达功能。</p>
<p>使用 IPV4 时，UDP 数据包中 checksum 字段是可选的，可以全为 0 表示不包含该字段。checksum 还会包含 IP
数据包中的一些信息，如源地址，目的地址，协议 ID 等。这违反了分层原理，这是为了允许 UDP 检测传递到错误地址的数据包。</p>
<p>UDP 不需要先建立连接，可以直接发包，所以更适合那些简单的请求-应答的服务，比如 DNS, DHCP, NTP 等。</p>
<h2 id="icmp-服务">ICMP 服务</h2>
<p>ICMP (Internet Control Message Protocol) 用于报错以及诊断问题。</p>
<ul>
<li>在主机间传达有关网络层的信息</li>
<li>报告错误，并帮助诊断错误</li>
</ul>
<p>ICMP位于 IP 之上，是一种传输层协议，并不可靠，它没有重发，也不会保留消息的状态。</p>
<p>假设 A 向 B 发包，但是路由器找不到 B，就会发送一个 ICMP 包给 A 表示找不到。</p>
<p>路由器会将 IP 数据报中的header 放到自己的 header 中。之后加上类型和 code 以标记错误。最后将这些放到新的 IP 数据报中。</p>
<ul>
<li>ping
<ul>
<li>ping 直接调用 ICMP，它发送 ICMP 回显请求。ping 了对方后，对方也会发送一个 ICMP 回来。</li>
</ul>
</li>
<li>tarceroute
<ul>
<li>traceroute 的目标是在 A 到 B 的路径中找到路由器，并测量从 A 到每个路由器的数据包的往返时间</li>
<li>这是通过 UDP 实现的。
<ul>
<li>A 发送 UDP 信息，并且这个 IP 数据报的 TTL 是 1，第一个路由器收到后递减 TTL 直接到 0，就会丢包，然后发回一个 ICMP 信息以通知 TTL 过期。这时就可以知道第一个路由器的信息，并且还可以测量时间。</li>
<li>之后再发送一个 TTL 为 2 的数据报，以此类推。</li>
<li>并且这个 UDP 包会请求对方的一个不太可能使用的端口，以让对方也是发送一个 ICMP 回来表示该端口无法访问。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="端到端原则">端到端原则</h2>
<p>1984 年， Saltzer, Reed, and Clark paper 的一篇文章指出：端到端原则指的是网络虽然可以完成更多的事情，但只是帮助，不能完全依靠网络，尽可能由终端主机实现功能。</p>
<p>在 IETF 的 <a href="https://www.rfc-editor.org/rfc/rfc1958#page-3" target="_blank" rel="noopener noreffer ">RFC 1958</a> 中有更简短的描述：网络的工作就是尽可能高效灵活地传输数据包，除此之外的工作都应该在主机上实现。</p>]]></description>
</item>
<item>
    <title>字节序 &amp; IPV4 地址 &amp; ARP 协议</title>
    <link>http://localhost:1313/posts/cs144_notes_002/</link>
    <pubDate>Thu, 25 Jul 2024 06:28:24 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cs144_notes_002/</guid>
    <description><![CDATA[<p>CS114 课程的课程笔记</p>
<h1 id="字节序--ipv4-地址--arp-协议">字节序 &amp; IPV4 地址 &amp; ARP 协议</h1>
<h2 id="字节排版和格式">字节排版和格式</h2>
<p>假设要发送 1024 ，十六进制是 0x0400 来表示。</p>
<p>在小端法表示中，最低有效字节位于最低地址，也就是 0x00, 0x04 这么存储。</p>
<p>在大端法表示中，最高有效字节位于最低地址，也就是 0x04, 0x00 这么存储。</p>
<p>但通信双方处理器使用的的字节序未必一致。例如 Intel 和 AMD x86 处理器使用小端法，不过一些处理器支持双端法，然后由操作系统决定到底用小端还是大端。</p>
<p>协议规范规定了使用大端，互联网所有协议都使用大端字节序。</p>
<p>如果自身机器是小端字节序的话，可以写个测试:</p>
<p>假设 TCP 端口为 80，存一个变量 <code>http_port = 80</code></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-c">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">uint16_t</span> <span class="n">http_port</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">==</span> <span class="n">http_port</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// ERROR
</span></span></span></code></pre></div></div>
<p>此时就可以比对，<code>http_port</code> 是小端存储，但 <code>packet-&gt;port</code> 则是大端，虽然实际上要存储的值都是 80，但测试失败。</p>
<p>为了简化这个过程，C 提供了一些库函数: <code>htons()</code>, <code>ntohs()</code>, <code>htonl()</code>, <code>ntohl()</code></p>
<ul>
<li>htons: host to network short</li>
<li>ntohl: network to host long</li>
</ul>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-c">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">uint</span> <span class="n">http_port</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">uint16_t</span> <span class="n">packet_port</span> <span class="o">=</span> <span class="nf">ntohs</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">packet_port</span> <span class="o">==</span> <span class="n">http_port</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// OK
</span></span></span></code></pre></div></div>
<p>对于小端字节序表示来说，<code>ntohs()</code> 和 <code>htons()</code> 会调换字节的顺序，对于大端字节序来说，二者什么也不做，只是将参数返回。</p>
<h2 id="ipv4-地址">IPV4 地址</h2>
<p>IPV4 地址长度为 32 位。通常分成4组写，例如: 192.168.1.1</p>
<p>除了 IP 地址的标示，还有网络掩码 (netmask)。例如网络掩码 255.255.255.0，表示 IP 地址 和自己的前三个八位字节匹配的在同一网络中。而 255.255.252.0 则表示前 22 位相同的和自己在同一网络中。</p>
<p>这就可以对两个 IP 地址和它们自己的掩码按位与来判断是否在同一网络中</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-c">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">((</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">netmask</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">B</span> <span class="o">&amp;</span> <span class="n">netmask</span><span class="p">))</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span></span></span></code></pre></div></div>
<p>可以使用 <code>ip addr</code> 查看自己的 IP 地址，有些发行版默认不装 <a href="https://net-tools.sourceforge.io/" target="_blank" rel="noopener noreffer ">net-tools</a> 也就无法使用 <code>ipconfig</code>，但应该会带 <a href="https://git.kernel.org/pub/scm/network/iproute2/iproute2.git" target="_blank" rel="noopener noreffer ">iproute2</a>。</p>
<h3 id="地址结构">地址结构</h3>
<p>传统分为三种</p>
<ul>
<li>0 network(1 -&gt; 7) host(8 -&gt; 31)</li>
<li>1 0 network(2 -&gt; 15) host(16 -&gt; 31)</li>
<li>1 1 0 network(3 -&gt; 23) host(24 -&gt; 31)</li>
</ul>
<p>其中，network 部分表示为 administrative domain，比如 MIT，Stanford，host 部分具体指是该网络的哪个设备。</p>
<p>但这种方式无法应对早就膨胀的互联网主机数量。</p>
<p>现在 IPV4 已经结构化，称为 CIDR (Classless Inter-Domain Routing)。CIDR 可以自定义前缀长度，其大小为 2 的幂次。当说到 CIDR 地址时，也就是在说就是网络掩码的长度，例如 <code>192.168.1.0/24</code>，表示长度为 24 的网络掩码，表示其容纳了 256 个地址，<code>/16</code> 是长度为16的网络掩码，描述了 65536 个地址。</p>
<p><a href="https://en.wikipedia.org/wiki/Internet_Assigned_Numbers_Authority" target="_blank" rel="noopener noreffer ">IANA</a> (Internet Assigned Numbers Authority)组织负责分配 IP 地址，其背后是 <a href="https://en.wikipedia.org/wiki/ICANN" target="_blank" rel="noopener noreffer ">ICANN</a> (Internet Corporation for Assigned Names and Numbers)，ICANN 将工作委托给了 IANA。IANA 向区域互联网注册机构 (Regional Internet Registries, RIRs)分发了 <code>/8</code> (1600 万个地址)，每个州有自己的 RIR，目前总共有五个 RIR。</p>
<blockquote>
<ul>
<li>美洲互联网号码注册管理机构（American Registry for Internet Numbers，ARIN）管理北美、南极洲和部分加勒比地区事务</li>
<li>欧洲IP网络资源协调中心（RIPE Network Coordination Centre，RIPE NCC）管理欧洲、中东和中亚地区事务</li>
<li>亚太网络信息中心（Asia-Pacific Network Information Centre，APNIC）管理亚洲和太平洋地区事务</li>
<li>拉丁美洲及加勒比地区互联网地址注册管理机构（Latin American and Caribbean Internet Address Registry，LACNIC）管理拉丁美洲和部分加勒比地区事务</li>
<li>非洲网络信息中心（African Network Information Centre，AfriNIC）管理非洲事务</li>
</ul>
</blockquote>
<h2 id="longest-prefix-match">Longest Prefix Match</h2>
<p>路由器通过转发表决定转发数据包的链路，当数据包到达时，路由器会在转发表找到和该地址最匹配的条目，并以此决定转发链路。</p>
<p>最长前缀匹配 (Longest Prefix Match, LPM)是 IP 路由用来决定转发地址的算法。</p>
<h2 id="arp-address-resolution-protocol">ARP, Address Resolution Protocol</h2>
<p>ARP 协议是网络层使用，用于发现与其直连的网络地址的 link 地址。设备自己有 IP 地址，但是它需要将数据报发送到哪个 link 上，ARP 协议解决了这个问题。每一层服务都有每一层用于标识的地址，IP 是网络层的地址，而 link 地址标示了特定的网卡，例如，Ethernet 地址是 48 bit。</p>
<p>48 bit 的 Ethernet 地址以冒号分隔的 6 个组形式写入，例如: <code>0:18:e7:f3:ce:1a</code>。</p>
<p>假设下面这个场景:</p>
<p></p>
<p>中间的网关有两个网卡，分别连 A 和 B 两个主机。网关本身就是位于 A 所属的这部分网络中，但网关在只有一个 IP 地址的情况下无法正常工作。所以网卡或路由器具有多个接口，也就具有多个 IP 地址。</p>
<p></p>
<p>假设 A 要向 B 发送数据包。首先判断目的地是否和自己处于同一网络内，网络掩码会表明这一点。
所以 A 需要通过网关来发包，该数据报网络层目标是 <code>171.43.22.5</code>，但链路层的目标为网关的地址 <code>0:18:e7:f3:ce:1a</code>。当网关收到数据报后，网关会为它的下一跳确定为节点 B，然后将其放到 B 的链路层帧中。</p>
<p>这里存在一个问题，A 知道需要通过 <code>192.168.0.1</code> 的网关发送数据包，所以它需要有和 <code>192.168.0.1</code> 关联的 link 地址，但如何获取这个地址。</p>
<p>这里通过一种方式将网络层地址映射到其对应的链路层地址。这里使用的就是 ARP 协议执行此操作。</p>
<p>ARP 是一种简单的 &ldquo;request-reply&rdquo; 的协议。</p>
<p>每个节点都保留在网络中 IP 地址到链路层地址映射的缓存，如果节点需要将数据报发送到它没有映射的 IP 地址，就需要发送一个请求，内容类似 “谁的 IP 地址是 XXX”，对应 IP 地址的节点再给出回应“我是这个地址”，这个回应就带着链路层地址。收到这个回复后，节点就可以建立映射缓存并发包。一个节点发出请求，网络中的每个节点都会收到该数据包。</p>
<p>ARP 请求时包含请求者的 IP 地址和链路层地址，以便于收到的一方可以插入或更新自己的映射缓存。这种映射缓存保存的时间取决于其操作系统。</p>
<p></p>
<ul>
<li>Hardware: 此请求或响应应用于哪个链路层</li>
<li>Protocol: 此请求或响应针对的网络协议</li>
<li>opcode: 该数据报是请求还是响应</li>
<li>length 指长度，比如 Ethernet 48 bit 长度就是 6，而 IPV4 地址长度则是 4。</li>
</ul>
<p>这些字段都会以大端字节序来存储。</p>
<p>最开始 ARP 规范认为回应者应该单播发给请求者，但现在广播更加普遍。</p>]]></description>
</item>
<item>
    <title>网络应用协议 &amp; 网络分层模型 &amp; 设计原则</title>
    <link>http://localhost:1313/posts/cs144_notes_001/</link>
    <pubDate>Mon, 22 Jul 2024 00:31:31 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cs144_notes_001/</guid>
    <description><![CDATA[<p>CS114 课程的课程笔记</p>
<h1 id="网络应用协议--网络分层模型--设计原则">网络应用协议 &amp; 网络分层模型 &amp; 设计原则</h1>
<h2 id="网络应用所使用的协议简介">网络应用所使用的协议简介</h2>
<h3 id="world-wide-web-http">World Wide Web (HTTP)</h3>
<p>万维网使用 HTTP (Hypertext Transfer Protocol) 通信。</p>
<p>在 HTTP 中，客户端打开到服务器的连接并发送命令</p>
<h3 id="bittorrent">BitTorrent</h3>
<p>BitTorrent 是一种允许人们共享大文件的程序。</p>
<p>不同于 Web，BitTorrent 中是客户端像其他客户端申请。BitTorrent 将文件分为称为 pieces 的数据块，一个客户端从另一个客户端下载了一个块后，它会告诉其他客户端自己拥有这个块，这种协作的客户端的集合被称为群集(swarms)。</p>
<p>当用户想要下载某个文件时，他需要先下载 torrent 文件（这通常是通过互联网找到的），这个 torrent 文件描述了要下载的文件的相关信息，还有这个 torrent 的 tracker 信息（tracker 是一个保持 track 群集的成员的节点）。</p>
<p>加入一个 torrent，自己这个客户端会连接到 tracker，并请求其他客户端的列表，本机就会尝试连接到其他客户端并开始下载文件</p>
<h3 id="skype">Skype</h3>
<p>简单情况下就是客户端A和客户端B都能互相访问，那么也没什么可做的。</p>
<p>如果引入了 NAT (Network Address Translator，就像无线路由器就是NAT) 就会复杂一些。自己的设备会在 NAT 的后面，这就导致自己的设备可以通过 NAT 连接互联网，但互联网上的设备不能直接访问到自己的设备。</p>
<p>假设 B 在 NAT 后方，那么 A 就无法直接连接 B。</p>
<p>Skype 通过使用一种被称为 Rendezvous 服务器的东西解决了这个问题。</p>
<p>一开始 A 和 B 都会和 Rendezvous 服务器建立连接，当 A 想要连接 B 的时候，这个请求会通过 Rendezvous 服务器发送到B这里，如果B同意就由 B 尝试连接到 A。这里被称为反向连接。</p>
<p>如果 A 和 B 都在 NAT 后面，Skype 通过使用 Relay 服务器处理这个情况。</p>
<h2 id="网络分层模型">网络分层模型</h2>
<p></p>
<p>整个互联网本身就由主机，链接和路由组成，数据以数据包的形式在每个链接中跳转传递。数据包包含数据和一段头部信息，这个信息包含数据包的来路和去向。</p>
<h3 id="链路层">链路层</h3>
<p>链路层的工作就是将数据在链接中不断的跳转。链路层的应用的例子就是以太网和 WiFi 等</p>
<h3 id="网络层">网络层</h3>
<p>网络层的工作是在互联网中将数据端对端的传送给对方。网络层的数据包(也叫数据报, datagram)的 header 会附带源地址和目标地址的信息。网络层会将数据包给链路层，让链路层通过第一个链接传递数据。链路层会将它跳到路由，路由的链路层接收到之后再传递给路由的网络层，这里的网络层会检查这个数据报的目标地址，并将其向目标地址跳一下。路由再传递到路由，直到到达目标地址。</p>
<p>链路层的具体实现方式并不是一种（例如以太网或 WiFi ），但网络层通过接口传递数据报，这种分离的效果使得网络层无需关注链路层的细节。</p>
<p>在网络层中，通过 Internet 传递数据就需要用到 IP 协议 (Internet Protocol)。</p>
<ul>
<li>IP 尽可能尝试将数据报传递到目的地，但其本身并不保证这一点。</li>
<li>IP 数据报可能会丢失，传递不按顺序，也可能会损坏，它没有保证这些。</li>
</ul>
<h3 id="传输层">传输层</h3>
<p>最常见的传输层的协议就是 TCP (Transmission Control Protocol)。TCP 确保了数据会以正确的顺序并传递过去，并且传输过程中数据报丢失了的话会重发。TCP 保证了运行在网络层之上的服务是的网络连接是可靠的。</p>
<p>相应的，有不保证顺序，也不会在丢失的时候重发的 UDP (User Datagram Protocol) 协议。UDP 只是将应用层的数据送到网络层。</p>
<p>常用的就是 TCP 和 UDP 了，但实际上还有其他的协议(比如 RTP )。</p>
<h3 id="应用层">应用层</h3>
<p>应用层就是常见的那些 http, smtp, ssh, ftp 之类的了。</p>
<h3 id="iso七层模型">ISO七层模型</h3>
<p></p>
<h3 id="ip-服务">IP 服务</h3>
<p>当传输层需要传输数据的时候，传输层将数据发送到下一层——网络层。网络层会将数据放到 IP 数据报中，IP 的工作就是将它发送到另一端。IP 数据包需要通过链路层进行传输，所以它要将数据包发送给链路层，链路层将其放到数据帧(frame)中(例如以太网数据包)，然后送到第一个路由器中。</p>
<p>IP 并不可靠，它不保证数据报一定到达，更不会保证到达的顺序，甚至在必要的时候会丢弃数据报（比如路由器中的数据报队列满了）。</p>
<p>这么设计是为了以下几点</p>
<ul>
<li>更加简单，容易维护，消费更低，速度更快。</li>
<li>端到端原则：尽可能在端测主机实现功能，而不是在网络硬件中。</li>
<li>允许顶层构建可能可靠或不可靠的服务。</li>
<li>对下层的链路层要求更低，对链路层没有太多的假设条件。</li>
</ul>
<h4 id="ip-服务的细节">IP 服务的细节</h4>
<ul>
<li>IP 尝试阻止数据报永远循环。
<ul>
<li>由于路由器转发表错误，可能导致数据报一直在循环发送。</li>
<li>引入了 TTL 字段解决这个问题，TTL 每通过一个路由器都递减一次，如果到 0 了，就认为处于循环的状态，由路由器丢弃它。</li>
</ul>
</li>
<li>IP 会对太长的数据报分段
<ul>
<li>IP 被设计为各种链路工作，不同链路对数据报大小的要求不一致。
<ul>
<li>比如 Ethernet 携带的数据报长度不能超过 1500 字节。</li>
</ul>
</li>
<li>IP 的 header 包含一些字段用于帮助路由器将一个数据报分开，并向对面主机提供信息需要重组数据。</li>
</ul>
</li>
<li>IP 数据报 header 包含一个校验和字段，以确保数据报到达正确的位置。</li>
<li>IP 有两种版本
<ul>
<li>IPV4: 当前广泛使用，32 bit 的地址</li>
<li>IPV6: 128 bit 地址。</li>
</ul>
</li>
<li>IP 允许新字段加入数据报 header 中。</li>
</ul>
<h4 id="ipv4-数据报-header-的细节">IPV4 数据报 header 的细节</h4>
<p></p>
<ul>
<li>Destination IP Address: 目标地址。</li>
<li>Source IP Address: 源地址。</li>
<li>Protocol ID: 数据字段的内容。允许目标主机对包解开并复用，如果 Portocal ID 是6，则该数据就包含一个 TCP 段。<a href="https://en.wikipedia.org/wiki/Internet_Assigned_Numbers_Authority" target="_blank" rel="noopener noreffer ">IANA</a> 定义了 140+种不同的协议值。</li>
<li>Version: IP 当前的版本，V4 还是 V6。</li>
<li>Total Packet Length: 数据报总长度。</li>
<li>TTL: 防止数据报永远处于循环状态。</li>
<li>Packet ID, Flags, Fragment Offset: 帮助路由器将 IP 数据报分成小份。</li>
<li>Type of Service: 向路由器提示该数据报的重要性。</li>
<li>Header Length: header 的长度，帮助自定义 header 字段。</li>
<li>Checksum: 防止发送到错误的地方。</li>
</ul>
<h3 id="数据包的一生">数据包的一生</h3>
<p>互联网四层模型中，从应用层获取数据流，传输层将其可靠地传递给另一台计算机上的应用程序。传输层将这些作为网络层数据包发送，网络层将其传递给另一台计算机。</p>
<h4 id="以-tcp-流为例">以 TCP 流为例</h4>
<p>客户端通过三次握手和服务器连接:</p>
<ol>
<li>当客户端发送服务器一个 synchronize 信息，通常称为 SYN。</li>
<li>服务端收到 SYN 后，发送一个确认连接消息，通常称为 SYN-ACK。</li>
<li>客户端收到后，再回复一个确认信息 ACK。</li>
</ol>
<p>为了标示将数据报传送给哪个应用程序，存在 TCP prot 用于标识。</p>
<p>客户端第一步跳到 WiFi 接入点，接入点存在一个 broader Ethernet 有线连接，所以数据报强制沿着线路跳。路由器连接很多链路，当数据报到达时，路由器决定将其发送到哪个链路。</p>
<p>路由器有 IP 地址，所以它可能不为了一个包，而是用自己的软件发送。例如使用 TCP 登录路由器时，IP 数据报将被发送到路由器自己的 IP 地址。这是通过转发表实现。</p>
<p>数据报到达后，路由器检查那个转发条目和数据报最匹配。</p>
<p>可以使用 Wireshark 验证这一过程。</p>
<p></p>
<hr>
<p>我认为现在没有什么网站是 HTTP 的了，我这里访问的是 BiliBili 所以三次握手后还有专属于 HTTPS 的 TLS 握手。</p>
<p><code>traceroute</code> 可以 trace 数据包传递的每一跳的信息，但是貌似对方可以设置不回显，这样返回不了信息。</p>
<hr>
<h2 id="设计原则">设计原则</h2>
<h3 id="原则数据包切换">原则：数据包切换</h3>
<p>这是构建网络的常用做法。</p>
<p>独立每个到达的数据包，选择将其传出链路，如果该链路空闲就发送，否则保存并等待。</p>
<ol>
<li>交换机可以为每个数据包单独做决定，不需要保留额外的数据包，它只需要负责转发。
<ul>
<li>例如语音电话由多个连续的数据包组成，它们属于同一组通信，将这种数据包序列称为流 (flow)。</li>
<li>由于各个数据包是独立的，所以交换机不需要处理整个流。</li>
<li>交换机不需要担心添加或删除流的状态，交换机会在合适的时候完成转发。交换机不会存储状态信息，因为交换机必须快速，将该状态存储到高速内存中的代价昂贵。</li>
<li>如果手机发出一个 web 请求后没电了，交换机将保存请求的 &ldquo;per-flow state&rdquo;，但如果其中一个节点创建状态失败后，交换机需要知道如何清除它，否则你可能面临被一堆流量占内存的情况。对于数据报切换来说，交换机不存储 &ldquo;per-flow state&rdquo;，如果手机没电了，交换机只会停止接收来自它的数据包。</li>
<li>因此，交换机在功能上就独立于发送流量的计算机。</li>
</ul>
</li>
<li>更有效的共享链接
<ul>
<li>考虑到一点，用户使用的网络服务都是突发性的，不会以固定的频率发送和接收特定的数据。</li>
<li>将所有流量都视作数据包，可以做到：假如 A 在阅读网页，B 在加载网页，路由器可以将A的容量都放B的数据包。如果 A 和 B 都在使用，那么路由器在二者之间共享。</li>
<li>采取单一资源并以概率方式在多个用户之间共享的想法被称为统计复用。每个用户都会获得基于多少用户正在使用的资源的统计份额。例如 A 正在阅读，B 就可以使用所有的链路，如果两个人都在加载页面，那都得到一半的链路容量。</li>
</ul>
</li>
</ol>
<h3 id="分层原则">分层原则</h3>
<p>就是模块化，每层只为它的上层，抽象接口。</p>
<h3 id="封装原则">封装原则</h3>
<p>封装是将分层和数据报切换结合发生的结果。</p>
<p>发送一个数据包时，每个数据包都包含来自多个层的数据。例如 TCP 段位于 IP 数据包内，而 IP 数据包又会在以太网帧内。封装就是这个原则。</p>
<p>关于封装的数据包，有两种画法:</p>
<p></p>
<p>第一种是硬件的视角，header 在右边，右边也是第一位，离开交换机的第一位是最右边的位。</p>
<p></p>
<p>第二种是软件的视角，header 在左边，许多文档和协议都这么画，这么画的出发点是数据包的开头是地址0，而左边是地址0，所以 header 在左边。</p>
<h4 id="vpn-服务示例">VPN 服务示例</h4>
<p>VPN (Virtual Private Network)</p>
<p>当你与互联网通信并发送 IP 数据包而不是正常发送它们时，它们会被发送到 VPN 连接中，以便 IP 数据包到达私有网络内。</p>
<p>在这种路线中，HTTP 被 TCP 封装，TCP 被 IP 封装，IP 被 TLS 封装，而 TLS 再被 TCP 封装，这个 TCP 被 IP 封装。</p>
<p>外层的 TCP/IP 都是用于到达 VPN 网关而用，内部的 TCP/IP 用来访问具体的 web server。</p>]]></description>
</item>
<item>
    <title>CS106L: Type &amp; RAII</title>
    <link>http://localhost:1313/posts/cs106l_type_raii/</link>
    <pubDate>Mon, 05 Feb 2024 03:42:51 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cs106l_type_raii/</guid>
    <description><![CDATA[<p>CS106L 中关于 Type 和 RAII 的部分</p>
<h1 id="type--raii">Type &amp; RAII</h1>
<h2 id="type--stdoptional">Type &amp; <code>std::optional</code></h2>
<h3 id="type-conversion">Type Conversion</h3>
<p>C++提供了更好的类型转换（相比于 C 那样直接写括号的强制类型转换）</p>
<p><a href="https://en.cppreference.com/w/cpp/language/static_cast" target="_blank" rel="noopener noreffer ">static_cast</a> 和 <a href="https://en.cppreference.com/w/cpp/language/dynamic_cast" target="_blank" rel="noopener noreffer ">dynamic_cast</a></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Derived</span> <span class="n">derivedObj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Base</span><span class="o">*</span> <span class="n">basePtr</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">derivedObj</span><span class="p">);</span></span></span></code></pre></div></div>
<p>就像这个 <code>static_cast</code>，会在编译时检验转换是否合法。</p>
<h3 id="stdoptional"><code>std::optional</code></h3>
<p><code>std::optional</code> interface：</p>
<ul>
<li><code>.value()</code>
<ul>
<li>返回包含的值或抛出 <code>bad_optional_access</code> 错误。</li>
</ul>
</li>
<li><code>.value_or(valueType val)</code>
<ul>
<li>返回包含的值或默认值 val（参数）。</li>
</ul>
</li>
<li><code>.has_value()</code>
<ul>
<li>如果存在包含的值，则返回 true；否则返回 false。</li>
</ul>
</li>
</ul>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">lookupStudent</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">){</span> <span class="cm">/*something*/</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="n">lookupStudent</span><span class="p">(</span><span class="err">“</span><span class="n">Keith</span><span class="err">”</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">student</span><span class="p">.</span><span class="n">has_value</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">output</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="err">“</span> <span class="n">is</span> <span class="n">from</span> <span class="err">“</span> <span class="o">&lt;&lt;</span>
</span></span><span class="line"><span class="cl">    <span class="n">output</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">state</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="err">“</span><span class="n">No</span> <span class="n">student</span> <span class="n">found</span><span class="err">”</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>使用 <code>std::optional</code> 返回值的优点：</p>
<ul>
<li>函数签名可以创建更具信息性的合约（contracts）。</li>
<li>类的函数调用具有保证和可用的行为。</li>
</ul>
<p>缺点：</p>
<ul>
<li>你需要在每个地方使用 <code>.value()</code>。</li>
<li>（在 C++中）仍然可能出现 bad_optional_access 错误。</li>
<li>（在 C++中）optional 也可能具有 undefined behavior（<code>*optional</code> 与 <code>.value()</code> 执行相同的操作，没有错误检查）。</li>
<li>在许多情况下，开发者希望有 <code>std::optional&lt;T&amp;&gt;</code>，但实际上并没有这个类型。</li>
</ul>
<p><code>std::optional</code> 的 monadic 接口（C++23）：</p>
<ul>
<li><code>.and_then(function f)</code>
<ul>
<li>如果存在包含的值，则返回调用 <code>f(value)</code> 的结果，否则返回 null_opt（f 必须返回 optional 类型）。</li>
</ul>
</li>
<li><code>.transform(function f)</code>
<ul>
<li>如果存在包含的值，则返回调用 <code>f(value)</code> 的结果，否则返回 null_opt（f 必须返回 optional<!-- raw HTML omitted --> 类型）。</li>
</ul>
</li>
<li><code>.or_else(function f)</code>
<ul>
<li>如果存在值，则返回该值，否则返回调用 <code>f</code> 的结果</li>
</ul>
</li>
</ul>
<p>那样代码就可以这么写：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">lookupStudent</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">){</span><span class="cm">/*something*/</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="n">lookupStudent</span><span class="p">(</span><span class="err">“</span><span class="n">Keith</span><span class="err">”</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">stu</span><span class="p">)[]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">stu</span> <span class="o">?</span> <span class="n">stu</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">name</span> <span class="o">+</span> <span class="err">“</span><span class="n">is</span> <span class="n">from</span> <span class="err">“</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">stu</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">state</span><span class="p">)</span> <span class="o">:</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">output</span><span class="p">.</span><span class="n">and_then</span><span class="p">(</span><span class="n">func</span><span class="p">).</span><span class="n">value_or</span><span class="p">(</span><span class="err">“</span><span class="n">No</span> <span class="n">student</span> <span class="n">found</span><span class="err">”</span><span class="p">);</span></span></span></code></pre></div></div>
<h2 id="raii">RAII</h2>
<h3 id="intro">intro</h3>
<blockquote>
<p>The best example of why I shouldn&rsquo;t be in marketing. I didn&rsquo;t have a good day when I named that &ndash; Bjarne Stroustrup (daddy of C++)</p>
</blockquote>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">EvaluateSalaryAndReturnName</span><span class="p">(</span><span class="kt">int</span> <span class="n">idNumber</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Employee</span><span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Employee</span><span class="p">(</span><span class="n">idNumber</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">Title</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#34;CEO&#34;</span> <span class="o">||</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">Salary</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">100000</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">First</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span>
</span></span><span class="line"><span class="cl">                  <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">Last</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; is overpaid&#34;</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">First</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; &#34;</span> <span class="o">+</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">Last</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">delete</span> <span class="n">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>对于这个函数，有很多地方可能导致内存泄露，即在 <code>delete</code> 之前的异常退出该函数从而导致在 heap 上的内存没有 free。所以我们需要 <code>try-catch</code>。</p>
<p><strong>关于异常安全</strong></p>
<p>不抛出异常：<code>noexcept</code> 关键字保证函数不会因为异常而导致一些 undefined behavior。这会出现在析构函数，swap，移动构造函数之类的。</p>
<p>在 <a href="https://google.github.io/styleguide/cppguide.html#Exceptions" target="_blank" rel="noopener noreffer ">Google C++ Style Guide</a> 中，Google 提到不建议使用异常。</p>
<p>理由：</p>
<blockquote>
<p>On their face, the benefits of using exceptions outweigh the costs, especially in new projects. However, for existing code, the introduction of exceptions has implications on all dependent code. If exceptions can be propagated beyond a new project, it also becomes problematic to integrate the new project into existing exception-free code. Because most existing C++ code at Google is not prepared to deal with exceptions, it is comparatively difficult to adopt new code that generates exceptions.
Given that Google&rsquo;s existing code is not exception-tolerant, the costs of using exceptions are somewhat greater than the costs in a new project. The conversion process would be slow and error-prone. We don&rsquo;t believe that the available alternatives to exceptions, such as error codes and assertions, introduce a significant burden.
Our advice against using exceptions is not predicated on philosophical or moral grounds, but practical ones. Because we&rsquo;d like to use our open-source projects at Google and it&rsquo;s difficult to do so if those projects use exceptions, we need to advise against exceptions in Google open-source projects as well. Things would probably be different if we had to do it all over again from scratch.
This prohibition also applies to exception handling related features such as <code>std::exception_ptr</code> and <code>std::nested_exception</code>.</p>
</blockquote>
<p>来自 ChatGPT@Poe 的中文翻译：</p>
<blockquote>
<p>在表面上，使用异常的好处超过了成本，尤其是在新项目中。然而，对于现有的代码来说，引入异常会对所有相关的代码产生影响。如果异常可以传播到新项目之外，将新项目整合到现有的无异常代码中也会带来问题。由于 Google 大部分现有的 C++代码都没有准备好处理异常，采用生成异常的新代码相对困难。
考虑到 Google 现有的代码不具备异常容忍性，使用异常的成本要略高于在新项目中的成本。转换过程将会缓慢且容易出错。我们认为，异常的替代方案（如错误码和断言）并不会引入重大负担。
我们反对使用异常的建议并非基于哲学或道德的立场，而是出于实际考虑。因为我们希望在 Google 使用我们的开源项目，但如果这些项目使用异常，那么在使用过程中会变得困难。如果我们从头开始重新做，情况可能会有所不同。
这个禁令也适用于与异常处理相关的特性，如 <code>std::exception_ptr</code> 和 <code>std::nested_exception</code>。</p>
</blockquote>
<h3 id="raii-1">RAII</h3>
<p><strong>RAII</strong>: <strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization</p>
<p>这个技术还有几个叫法：</p>
<p><strong>SBRM</strong>: <strong>S</strong>cope <strong>B</strong>ased Memo<strong>r</strong>y <strong>M</strong>anagement</p>
<p><strong>CADRE</strong>: <strong>C</strong>onstructor <strong>A</strong>cquires, <strong>D</strong>estructor <strong>Re</strong>leases</p>
<p>从后两个的全拼能看出来，RAII 就是利用了类在超出作用域范围的时候就自动调用析构函数这一点，将 <code>new</code> 和 <code>delete</code> 放到构造函数和析构函数中。</p>
<p>比如在 open 一个文件的时候，不应该先用 <code>ifstream</code> 创建一个变量，然后调用 <code>open</code> 函数，而是直接 <code>ifstream input(&quot;test.txt)</code>，这就是 RAII 的写法，这样也不需要在后面写 <code>input.close()</code> 了。</p>
<p>锁也有类似的：<code>lock_guard</code></p>
<p></p>
<p>在 <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines" target="_blank" rel="noopener noreffer ">C++ Core Guidelines</a> 也有相关描述:</p>
<p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-newdelete" target="_blank" rel="noopener noreffer ">R.11: Avoid calling new and delete explicitly</a></p>
<h3 id="smart-pointers">Smart Pointers</h3>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Tp</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Tp</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Tp</span><span class="o">&gt;</span><span class="p">;</span></span></span></code></pre></div></div>
<p><strong>unique_ptr</strong></p>
<p><code>unique_ptr</code>，唯一持有自己的资源并在被销毁的时候用析构函数释放。唯一持有为了防止复制后发生重复的 free。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">rawPtrFn</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">delete</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// use unique_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">rawPtrFn</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">n</span><span class="p">(</span><span class="k">new</span> <span class="n">Node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//do something
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div></div>
<p><code>unique_ptr</code> 无法被复制，但可以通过 <code>std::move</code> 移动：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">u3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">u4</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">u3</span><span class="p">);</span></span></span></code></pre></div></div>
<p><strong>shared_ptr</strong></p>
<p><code>shared_ptr</code> 可以复制，当所有指向这个资源的 <code>shared_ptr</code> 都死掉后就 free 掉这块内存。<code>shared_ptr</code> 用引用计数实现了这一点。</p>
<p><strong>weak_ptr</strong></p>
<p><code>weak_ptr</code> 类似于 <code>shared_ptr</code>，但是没有引用计数。</p>]]></description>
</item>
<item>
    <title>CS106L: Class</title>
    <link>http://localhost:1313/posts/cs106l_class_op/</link>
    <pubDate>Sun, 04 Feb 2024 03:42:51 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cs106l_class_op/</guid>
    <description><![CDATA[<p>CS106L 中关于类的部分</p>
<h1 id="class">Class</h1>
<blockquote>
<p>A struct simply feels like an open pile of bits with very little in the way of encapsulation or functionality. A class feels like a living and responsible member of society with intelligent services, a strong encapsulation barrier, and a well defined interface</p>
<ul>
<li>Bjarne Stroustrup</li>
</ul>
</blockquote>
<h2 id="构造函数初始化列表">构造函数初始化列表</h2>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Student</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span><span class="p">)</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">state</span><span class="p">(</span><span class="n">state</span><span class="p">),</span> <span class="n">age</span><span class="p">(</span><span class="n">age</span><span class="p">){</span> <span class="p">}</span></span></span></code></pre></div></div>
<p>函数体内部还是可以写代码的</p>
<h2 id="关于-delete">关于 delete</h2>
<p>array 作为一个基础的类型，当开发者手动为此创建内存之后也可以之后手动释放掉：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//int * is the type of an array variable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">my_int_array</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">//this is how you initialize an array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">my_int_array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">//this is how you index into an array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">one_element</span> <span class="o">=</span> <span class="n">my_int_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">delete</span> <span class="p">[]</span> <span class="n">my_int_array</span><span class="p">;</span></span></span></code></pre></div></div>
<p>delete 一般在类的析构函数中出现（需要手动掉释放这块内存）</p>
<p></p>
<p>这里那个虚函数等于 0 的意义在于，让继承它的类必须实现该函数，否则编译失败。这种虚函数叫作纯虚函数（<em>pure virtual function</em></p>
<p>一个类存在一个纯虚函数就叫作抽象类，抽象类不能被实例化。</p>
<p>如何子类不想要实现自己的构造函数，可以：</p>
<p></p>
<p>如果是析构函数可能有点麻烦，如果有一个基类（这个类的析构函数不是虚函数）的指针指向派生类，并且这时候要 <code>delete</code> 这个指针就不会调用派生类的析构函数。如果基类的析构函数实现为虚函数，那么才可以正常调用派生类的析构函数释放内存。</p>
<p></p>
<p></p>
<p>如果基类的虚函数有实现了，并且派生类想要调用，可以这么写：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">t</span><span class="p">.</span><span class="n">Drink</span><span class="o">::</span><span class="n">make</span><span class="p">();</span></span></span></code></pre></div></div>
<h2 id="template-classes">Template classes</h2>
<blockquote>
<p>Fundamental Theorem of Software Engineering: Any problem can be solved by adding enough layers of indirection</p>
</blockquote>
<p>模板类之前也见到过：<code>std::vector&lt;int&gt;</code>。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//Example: Structs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">First</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Second</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">MyPair</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">First</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Second</span> <span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">First</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Second</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyPair</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">First</span> <span class="n">getFirst</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">Second</span> <span class="nf">getSecond</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="nf">setFirst</span><span class="p">(</span><span class="n">First</span> <span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="nf">setSecond</span><span class="p">(</span><span class="n">Second</span> <span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">First</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Second</span> <span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">First</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Second</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyPair</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*...*/</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">First</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Second</span> <span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div></div>
<p>而其部分函数的实现，也需要加 template：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">First</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Second</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">First</span> <span class="n">MyPair</span><span class="o">::</span><span class="n">getFirst</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>模板类的成员函数和其他函数并不一样，编写的时候最好在一起，而不是像其他普通的编写一样，分为.h 和.cpp 两个文件。因为模板类的成员函数需要编译时的实例化，需要具体的参数生成对应函数的实现。</p>
<p>模板类可以针对特定类型写一个版本：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">FooSpecial</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">FooSpecial</span><span class="p">(</span><span class="kt">float</span> <span class="n">var</span><span class="p">)</span> <span class="o">:</span> <span class="n">var_</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;hello float! &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">var_</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">var_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div></div>
<h2 id="const-keyword">const keyword</h2>
<p>const 函数不可以修改类的元素后者传给它的参数。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span> <span class="k">const</span> <span class="n">p</span><span class="p">;</span></span></span></code></pre></div></div>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">++</span> <span class="c1">// ok
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">p</span><span class="o">++</span> <span class="c1">// error
</span></span></span></code></pre></div></div>
<p>const-interface：所有成员函数都可以在定义类的时候被 const 标记</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">StrVector</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">using</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">size_t</span> <span class="n">kInitialSize</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*...*/</span>
</span></span><span class="line"><span class="cl">        <span class="n">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>            <span class="c1">//here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>             <span class="c1">//here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="n">size_t</span> <span class="n">indx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">size_t</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">elem</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">iterator</span> <span class="nf">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">iterator</span> <span class="nf">end</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*...*/</span></span></span></code></pre></div></div>
<p>这种标记是一种 <code>const</code> 成员函数，它保证了函数内部不会修改 <code>this</code> 实例。</p>
<h2 id="operators">Operators</h2>
<h3 id="运算符重载">运算符重载</h3>
<p></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">strvec</span><span class="p">{</span><span class="s">&#34;Hello&#34;</span><span class="p">,</span> <span class="s">&#34;World&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">strvec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">strvec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s">&#34;!&#34;</span><span class="p">;</span></span></span></code></pre></div></div>
<p>上面这段代码相当于：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">strvec</span><span class="p">{</span><span class="s">&#34;Hello&#34;</span><span class="p">,</span> <span class="s">&#34;World&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">.</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">strvec</span><span class="p">.</span><span class="k">operator</span><span class="p">[](</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">strvec</span><span class="p">.</span><span class="k">operator</span><span class="p">[](</span><span class="mi">1</span><span class="p">).</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="s">&#34;!&#34;</span><span class="p">);</span></span></span></code></pre></div></div>
<p>或者是这样：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">strvec</span><span class="p">{</span><span class="s">&#34;Hello&#34;</span><span class="p">,</span> <span class="s">&#34;World&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span> <span class="n">strvec</span><span class="p">.</span><span class="k">operator</span><span class="p">[](</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">strvec</span><span class="p">.</span><span class="k">operator</span><span class="p">[](</span><span class="mi">1</span><span class="p">),</span> <span class="s">&#34;!&#34;</span><span class="p">);</span></span></span></code></pre></div></div>
<p>每个运算符都有一个与之对应的函数</p>
<p>对于操作符重载时的返回值问题，有的虽然看起来不会有返回值其实也是有的，例如 <code>i += z</code>，返回值就应该是 <code>i</code>，所以 <code>(i += z) += y</code> 这样的操作也是可以的。</p>
<p>像 <code>+=</code> 这种都是类自己的成员函数，会被这个类型的变量所调用，所以对这种运算符重载，参数表只有一个参数，通过 <code>*this</code> 还是可以访问到那个变量。</p>
<p>假设实现 <code>+</code> 运算符的重载：</p>
<p></p>
<p>将重载的函数实现成成员函数还是非成员函数的一般规则：</p>
<ul>
<li>由于 C++的语义原因，一些操作符必须被实现为成员函数（例如<code>[]</code>, <code>()</code>, <code>-&gt;</code>, <code>=</code>）</li>
<li>还有一些必须实现为非成员函数（例如 <code>&lt;&lt;</code>，开发者不能覆盖掉 STL 库的实现，所以需要实现为非成员函数）</li>
<li>如果是一元操作符（例如 <code>++</code>）就实现为成员函数。</li>
<li>如果是二元操作符，而且对这两个变量的操作是一致的（即要么都修改，要么都不修改），就实现成非成员函数（例如 <code>+</code>, <code>&lt;</code>）。</li>
<li>如果是二元操作符，但是对这两个变量的操作不一致，就实现为成员函数（例如 <code>+=</code>）。</li>
</ul>
<p>如果非成员函数涉及到访问类的私有变量，可以考虑 <code>friends</code></p>
<p></p>
<p><strong>Principle of Least Astonishment (POLA)</strong></p>
<ul>
<li>设计一个操作符主要是为了模仿传统意义上该操作符的用法
<ul>
<li>比如之前提到的 <code>+=</code> 需要有一个返回值</li>
</ul>
</li>
<li>对称的运算符需要实现为非成员函数
<ul>
<li>这里说的对称的意思感觉就是运算符两边的表达式可以互换，举的例子是 <code>a + 1</code> 这样的，如果是成员函数的话 <code>1 + a</code> 就不能调用对应函数了。</li>
</ul>
</li>
<li>如果重载了一个运算符，它相关那一套都需要重载。
<ul>
<li>这里的一套就是上面介绍有哪些运算符中那个分类，一套说的是那里面的一类。</li>
</ul>
</li>
</ul>
<h2 id="special-member-functions">Special Member Functions</h2>
<p></p>
<p>它们特殊在如果开发者不自己实现的话，编译器会自动生成，但是编译器自动生成的有时候未必能满足开发者的需要。</p>
<p>这些函数就是：构造函数，析构函数，复制构造函数，复制运算符。其中，复制构造函数会创建一个新的变量（也是在创建新变量的时候被调用的）。</p>
<h3 id="copy-semantics">Copy Semantics</h3>
<p>编译器默认生成的复制构造函数会把很多信息都复制一遍，所以新变量和旧变量的指针会指向同一个内存，复制运算符会把要覆写的变量清空然后重新全部复制一遍。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Student</span><span class="p">(</span><span class="k">const</span> <span class="n">Student</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">name</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">name</span><span class="p">),</span> <span class="n">state</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">state</span><span class="p">),</span> <span class="n">age</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">age</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div></div>
<p>重载复制运算符的时候就不能像上面这样写初始化列表了，毕竟它不是构造函数（</p>
<p>当这个类有一些自己独有的资源时（比如指针，文件流），应该写自己的复制构造函数。</p>
<p>当要实现（删除）一个复制构造函数或者复制运算符或者析构函数的时候，你应该实现（删除）这三个所有。</p>
<h3 id="move-semantics">Move Semantics</h3>
<p>移动语义代表了 C++ 的一大哲学——尽量不要牺牲效率。</p>
<p>例如 <code>std::vector</code> 中有一个与 <code>push_back()</code> 类似的函数：<code>emplace_back()</code>。它和 <code>push_back()</code> 不同的是，它可以将参数在内部直接构造插入，而不是像 <code>push_back()</code> 需要创建一个已有的变量。<a href="https://en.cppreference.com/w/cpp/container/vector/emplace_back" target="_blank" rel="noopener noreffer ">cppreference 网站关于它的条目中</a> 有一个例子：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">President</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">country</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">year</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">President</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">p_name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">p_country</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p_year</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p_name</span><span class="p">)),</span> <span class="n">country</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p_country</span><span class="p">)),</span> <span class="n">year</span><span class="p">(</span><span class="n">p_year</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;I am being constructed.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">President</span><span class="p">(</span><span class="n">President</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">name</span><span class="p">)),</span> <span class="n">country</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">country</span><span class="p">)),</span> <span class="n">year</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">year</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;I am being moved.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">President</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">President</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">President</span><span class="o">&gt;</span> <span class="n">elections</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;emplace_back:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">elections</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">&#34;Nelson Mandela&#34;</span><span class="p">,</span> <span class="s">&#34;South Africa&#34;</span><span class="p">,</span> <span class="mi">1994</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">year</span> <span class="o">==</span> <span class="mi">1994</span> <span class="o">&amp;&amp;</span> <span class="s">&#34;uses a reference to the created object (C++17)&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">President</span><span class="o">&gt;</span> <span class="n">reElections</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">push_back:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">reElections</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">President</span><span class="p">(</span><span class="s">&#34;Franklin Delano Roosevelt&#34;</span><span class="p">,</span> <span class="s">&#34;the USA&#34;</span><span class="p">,</span> <span class="mi">1936</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">Contents:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">President</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">president</span><span class="p">:</span> <span class="n">elections</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">president</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; was elected president of &#34;</span>
</span></span><span class="line"><span class="cl">                  <span class="o">&lt;&lt;</span> <span class="n">president</span><span class="p">.</span><span class="n">country</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; in &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">president</span><span class="p">.</span><span class="n">year</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">President</span> <span class="k">const</span><span class="o">&amp;</span> <span class="nl">president</span><span class="p">:</span> <span class="n">reElections</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">president</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; was re-elected president of &#34;</span>
</span></span><span class="line"><span class="cl">                  <span class="o">&lt;&lt;</span> <span class="n">president</span><span class="p">.</span><span class="n">country</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; in &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">president</span><span class="p">.</span><span class="n">year</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>可以看到：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span><span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">elections</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="s">&#34;Nelson Mandela&#34;</span><span class="p">,</span> <span class="s">&#34;South Africa&#34;</span><span class="p">,</span> <span class="mi">1994</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">reElections</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">President</span><span class="p">(</span><span class="s">&#34;Franklin Delano Roosevelt&#34;</span><span class="p">,</span> <span class="s">&#34;the USA&#34;</span><span class="p">,</span> <span class="mi">1936</span><span class="p">));</span></span></span></code></pre></div></div>
<p></p>
<p></p>
<p>移动构造函数和移动符号的函数原型如下：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Student</span><span class="p">(</span><span class="n">Student</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Student</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Student</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span></span></span></code></pre></div></div>
<p>但是虽然参数列表里面写的是 <code>&amp;&amp;</code> 右值引用，但是在函数体内部，这个引用本身是一个左值，常规的 <code>=</code> 不再是移动而是复制。为了让复制变成移动，需要用到 <code>std::move()</code>，它会接受一个左值并返回相应的右值。经验之谈：在类成员函数中，如果接受一个 <code>const &amp;</code> 参数并在函数内部将其赋值给其他变量，那么通常可以使用 <code>std::move</code>，除此之外不要使用它。</p>
<p>如果一个类定义了复制构造函数和复制运算符，那么应该也实现一份移动构造函数和移动运算符。</p>
<p></p>
<p></p>]]></description>
</item>
<item>
    <title>CS106L: Templates</title>
    <link>http://localhost:1313/posts/cs106l_template_algorithms/</link>
    <pubDate>Sat, 03 Feb 2024 03:42:51 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cs106l_template_algorithms/</guid>
    <description><![CDATA[<p>CS106L 中关于 Templates 的部分</p>
<h1 id="templates">Templates</h1>
<h2 id="templates-function">Templates Function</h2>
<p>template 应该算得上很自然的想法（🤔 又或者是套娃的另一次应用），我认为这就是对函数的进一层抽象，它将函数的逻辑抽象成与类型无关，比如</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">min</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="o">=</span><span class="kt">int</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">Type</span> <span class="n">myMin</span><span class="p">(</span><span class="n">Type</span> <span class="n">a</span><span class="p">,</span> <span class="n">Type</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>这里的 <code>typename</code> 没有指明类型，实际上可以写成 <code>class T</code>，这样这个函数就不会接受 int 之类的类型。那个 <code>=int</code> 表示其默认类型（虽然我还没认识到写它的意义）。</p>
<p>可以针对性的再写一个特定类型的模板函数:</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="kt">void</span> <span class="n">print_msg</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;print_msg called with float type!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">add3</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">minvar</span> <span class="o">=</span> <span class="n">min</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span></span></span></code></pre></div></div>
<p>隐式存在一个问题在于参数的类型未必能被识别出来（有些类型的定义方式差不多）。不过貌似编译器这时候会报错。</p>
<p>从一个实际的类型推广到一个模板，这个过程被称为 <em>Concept Lifting</em>。对于隐式类型的来说，这种提升可能会导致传入一些不可以工作的类型（比如函数内部使用了 <code>=</code> 赋值，但 stream 是不可以这样做的）</p>
<p>毕竟有了函数指针，其实可以把抽象做的更细一些。比如 <em>Predicate Functions</em></p>
<p></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">InputIt</span><span class="p">,</span> <span class="k">typename</span> <span class="n">UniPred</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">count_occurrences</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">begin</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">end</span><span class="p">,</span> <span class="n">UniPred</span> <span class="n">pred</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">))</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">isVowel</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">vowels</span> <span class="o">=</span> <span class="s">&#34;aeiou&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">vowels</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;Xadia&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">count_occurrences</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">isVowel</span><span class="p">);</span></span></span></code></pre></div></div>
<p>C++20 允许开发者显示指定其 template 类型的要求，具体可以参见文档：<a href="https://en.cppreference.com/w/cpp/language/constraints" target="_blank" rel="noopener noreffer ">Constraints and concepts (since C++20)</a> 和 <a href="https://en.cppreference.com/w/cpp/language/requires" target="_blank" rel="noopener noreffer ">Requires expression (since C++20)</a></p>
<h2 id="lamdba--algorithms">Lamdba &amp; Algorithms</h2>
<p>Lamda function:</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[</span><span class="n">capture</span><span class="o">-</span><span class="n">clause</span><span class="p">](</span><span class="n">parameters</span><span class="p">)</span><span class="o">-&gt;</span><span class="k">return</span><span class="o">-</span><span class="n">value</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// body
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span></span></span></code></pre></div></div>
<p>C++14 开始，这个 <code>return-value</code> 是可选的。</p>
<p></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="p">[]</span> <span class="c1">// captures nothing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="n">limit</span><span class="p">]</span> <span class="c1">// captures lower by value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="o">&amp;</span><span class="n">limit</span><span class="p">]</span> <span class="c1">// captures lower by reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="o">&amp;</span><span class="n">limit</span><span class="p">,</span> <span class="n">upper</span><span class="p">]</span> <span class="c1">// captures lower by reference, higher by value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">limit</span><span class="p">]</span> <span class="c1">// captures everything except lower by reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="c1">// captures everything by reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="c1">// captures everything by value
</span></span></span></code></pre></div></div>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">isMoreThan</span> <span class="o">=</span> <span class="p">[</span><span class="n">limit</span><span class="p">]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">isMoreThan</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span> <span class="c1">//true
</span></span></span></code></pre></div></div>
<p>有了这个之后，也就不需要像之前那样定义<em>Predicate Functions</em>了，可以直接写 lamdba。</p>
<p>STL 的一些 algorithm 不能用于开发者自定义的类型（比如寻找最小值之类的），这时候需要用到 lambda 函数。</p>
<p>比如对于这样的 vector:</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">vecstu</span><span class="p">{{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">}};</span></span></span></code></pre></div></div>
<p>直接使用 <code>std::minmax_element()</code> 是无法通过编译的</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="p">[</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span><span class="n">vecstu</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecstu</span><span class="p">.</span><span class="n">end</span><span class="p">());</span></span></span></code></pre></div></div>
<p>额，根据我看到的录像那里，其开发环境是没有在编译前给出预警的。但是我的 vscode 在只给了两个参数的时候：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-text">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">In template: invalid operands to binary expression (&#39;Student&#39; and &#39;Student&#39;) clang(typecheck_invalid_operands)</span></span></code></pre></div></div>
<p>这时候就可以加一个 lamdba 函数，并传给 <code>minmax_element()</code></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">compareStudent</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Student</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="n">Student</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">averge</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">averge</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div></div>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="p">[</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">minmax_element</span><span class="p">(</span><span class="n">vecstu</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vecstu</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">compareStudent</span><span class="p">);</span></span></span></code></pre></div></div>
<p>在 <code>std::copy</code> 这个函数中，如果传入的 iterator 指向的 container 没有足够的空间，那么就会复制到为初始化的内存中，这时候应该传入一个 iterator adaptor。这种函数可以给 iterator 加点料（比如 <code>back_inserter()</code> 会让返回的 iterator 在赋值不存在的空间时扩展 container）。</p>
<p>引用上一章一开始给出的代码：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">generate</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">rand</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>]]></description>
</item>
<item>
    <title>CS106L: Containers &amp; Iterators</title>
    <link>http://localhost:1313/posts/cs106l_container_iterator/</link>
    <pubDate>Fri, 02 Feb 2024 03:42:51 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cs106l_container_iterator/</guid>
    <description><![CDATA[<p>CS106L 中关于 container 和 iterators 的部分</p>
<h1 id="containers">Containers</h1>
<p>STL 是一个历史相较悠久并且一直在更新的一个标准库，它提供了很多算法供开发者使用</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">generate</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">rand</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>这 5 行代码，就完成了对 vector 元素的随机化赋值并排序，然后输出到 console 上这一系列的工作。</p>
<h2 id="sequence-containers">Sequence Containers</h2>
<p>这是一种数据结构，提供了对元素序列的访问</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">foraword_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></span></span></code></pre></div></div>
<p></p>
<p>如果越界访问，<code>vec.at(i)</code> 会抛出一个异常，而 <code>vec[i]</code> 会是一个 undefined behavior</p>
<p>Sequence Containers 是一种特殊的 Containers，因为它是顺序的。</p>
<p>正如关于数组和链表之间老生长谈的对比一样，在 vector 的前面添加一个元素还是很难绷的，C++提供了另一种数据结构处理这种情况：<code>std::deque&lt;T&gt;</code></p>
<p>vector 有 <code>push_back()</code> 函数添加变量，deque 除了 <code>push_back()</code> 有 <code>push_front()</code> 可以在前面插入</p>
<p>A <strong>deque</strong> is a <strong>d</strong>ouble <strong>e</strong>nded <strong>que</strong>ue</p>
<p>deque 的实现是将多个 vector 作为枝干，一个 vector 作为主干。如果你从后插入，那就将元素插入最后面枝叶里面，如果最后面那个满了就给主干多加一个，如果主干满了不能加枝叶了那就换一个更长的主干。插入前面是类似的操作。</p>
<p>有两种经典的数据结构——栈和队列，在这里它们被称为 <em>Container Adaptors</em>。它们会通过对 Container 做一些调整来适应它们自身数据结构的定义。在 C++ 文档中，它们的描述都会有这么一句：</p>
<blockquote>
<p>The std::stack class is a container adaptor that gives the programmer the functionality of a stack - specifically, a LIFO (last-in, first-out) data structure.
The std::queue class is a container adaptor that gives the functionality of a queue - specifically, a FIFO (first-in, first-out) data structure.</p>
</blockquote>
<p>正如 C++ 设计哲学所说的那句赋予开发者完全的掌控权，所以 stack 虽然是默认用 deque 实现的，但开发者可以自己选择使用什么 container（比如 vector）实现的 stack。（在文档中也有叙述：<a href="https://en.cppreference.com/w/cpp/container/stack" target="_blank" rel="noopener noreffer ">std::stack</a></p>
<p>额，按照我的理解，这句话所说的代码应该是这么写：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">st</span><span class="p">;</span></span></span></code></pre></div></div>
<p>查找 vector 可以使用<code>std::find</code></p>
<h2 id="associative-containers">Associative Containers</h2>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span></span></span></code></pre></div></div>
<p>正如前面所说，Sequence Containers 是顺序的，可以通过索引来访问，而 Associative Containers 是不能通过索引来访问的。</p>
<p>虽然是不能通过索引访问，但是 <code>std::map&lt;T1, T2&gt;</code> 和 <code>std::set&lt;T&gt;</code> 会按照大小顺序排列。如果这里存储的是开发者自定义的类型，可以定义用于比较两个实例的大小的小于号帮助它按照顺序排列。vector 会有 sort 函数用于排序，这里面也是会存在这个问题，如果 vector 存储的是开发者自定义的类型，要么是实现这个类型的小于号，要么使用 lamdba 函数</p>
<p></p>
<p></p>
<p><code>map.at(key)</code> 和 <code>may[key]</code> 区别类似之前提到的，前者不存在的话会抛出异常，后者默认创建它。</p>
<p>可以通过<code>map.count(key)</code> 来查看是否存在。C++20 也支持了<code>var.contains()</code> 来查找：<a href="https://en.cppreference.com/w/cpp/container/set/contains" target="_blank" rel="noopener noreffer ">std::set&lt;Key,Compare,Allocator&gt;::contains</a>，<a href="https://en.cppreference.com/w/cpp/container/map/contains" target="_blank" rel="noopener noreffer ">std::map&lt;Key,T,Compare,Allocator&gt;::contains</a>。</p>
<p>map 的 key 重复出现的话被称为 <em>multimap</em></p>
<h2 id="iterators">Iterators</h2>
<p>它允许开发者迭代访问任何 containers</p>
<p>比如 <code>map.begin()</code>，它会返回一个 iterator，这个 iterator 指向第一个元素。就像这样：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">mymap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span></span></span></code></pre></div></div>
<p><code>++it</code> 会让这个 iterator 指向下一个元素。<code>*it</code> 可以访问这个 iterator 实际指向的值，这里也可以发现 iterator 和指针是差不多玩意。</p>
<p>map 的 iterator 和其他的 container 有些不同——因为 map 有两个值，它的 iterator 实际上是 <code>std::pair&lt;string, int&gt;</code></p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">mymap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">mymap</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;test&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">thing</span> <span class="p">:</span> <span class="n">mymap</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">thing</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>在 vector 中，iterator 可以通过 <code>begin() + 3</code> 这样的方式挪动，但 <code>std::list</code> 等就不可以这么做，这是因为 container 的实现略有不同，但是 iterators 的实现就为了消除 containers 的区别从而用一种通用的方式调用 container。所以存在 5 种 iterator。</p>
<ol>
<li>Input</li>
<li>Output</li>
<li>Forward</li>
<li>Bidirectional</li>
<li>Random Access</li>
</ol>
<p>上述的这几种 iterator 都有上面所介绍的那些功能（<code>++it</code>什么的）</p>
<p>第一种 input iterator 只能被读，只能向前走，而且只能+1，比如 <code>find()</code> 或者 <code>count()</code> 这样的只需要遍历的地方中就会用到它，C++文档中也有描述：</p>
<p></p>
<p>Output iterator 和 input iterator 类似，只不过是只写的。<code>copy</code>这个函数会用到这个</p>
<p></p>
<p>Forward iterator 同时具有 output iterator 和 input iterator 的特点，即 RW 它都拿到了。<code>replace()</code> 函数会用到这个，还有就是之前 Sequence Containers 上提到的<code>std::foraword_list&lt;T&gt;</code></p>
<p></p>
<p>Bidirectional iterator 具有 Forward iterator 的功能，并且这个可以 <code>--</code>。在 <code>std::map</code>，<code>std::set</code>，<code>std::list</code>，或者<code>reverse()</code> 中会看到</p>
<p></p>
<p>Random access iterator 具有 Bidirectional iterator 的功能并且不受递增递减的约束，而是可以随意访问。在<code>std::vertor</code>，<code>std::string</code>，pointer 中都会使用它，所以这个是最常用的。</p>]]></description>
</item>
<item>
    <title>CS106L: Streams &amp; Type</title>
    <link>http://localhost:1313/posts/cs106l_stream_type/</link>
    <pubDate>Thu, 01 Feb 2024 03:42:51 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/cs106l_stream_type/</guid>
    <description><![CDATA[<p>CS106L 中关于 Streams 和 type 的部分</p>
<h1 id="streams">Streams</h1>
<h2 id="string-stream">String Stream</h2>
<p>使用 Stream 缘于程序需要与外部资源交互。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ostringstream</span> <span class="n">oss</span><span class="p">(</span><span class="s">&#34;Ito En Green Tea&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="mf">16.9</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; Ounce &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">oss</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>使用 g++ 编译并运行：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ g++ -std<span class="o">=</span>c++17 test.cpp -o <span class="nb">test</span>
</span></span><span class="line"><span class="cl">$ ./test
</span></span><span class="line"><span class="cl">Ito En Green Tea
</span></span><span class="line"><span class="cl">16.9 Ounce n Tea</span></span></code></pre></div></div>
<p>因为 stream 创建后，指针处于头部，所以写入的时候会从头部开始覆盖写入，如果给 <code>oss()</code> 传入其他参数可以控制这个模式，比如改成 <code>ostringstream oss(&quot;Ito En Green Tea&quot;, stringstream::ate);</code> 之后，指针会指向尾端。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-c">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">istringstream</span> <span class="nf">iss</span><span class="p">(</span><span class="n">oss</span><span class="p">.</span><span class="nf">str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">ammount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">struint</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">ammount</span> <span class="o">&gt;&gt;</span> <span class="n">struint</span><span class="p">;</span></span></span></code></pre></div></div>
<p><code>iss</code> 在输出的时候会根据空格分隔这个 stream。</p>
<p>对于移动 stream 指针的需求，可以使用下边这份代码：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-c">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ostringstream</span> <span class="nf">oss</span><span class="p">(</span><span class="s">&#34;Ito En Green Tea &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="mf">16.9</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">fpos</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">oss</span><span class="p">.</span><span class="nf">tellp</span><span class="p">()</span> <span class="o">+</span> <span class="nf">streamoff</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">oss</span><span class="p">.</span><span class="nf">seekp</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Black&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">oss</span><span class="p">.</span><span class="nf">good</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p><code>i/ostringstream</code> 都有快速的错误检查，分别为<code>good()</code>、<code>fail()</code>、<code>eof()</code>、<code>bad</code>。</p>
<ul>
<li>good: ready for read/write.</li>
<li>fail: previous operation failed, all future operation frozen.</li>
<li>eof: previous operation reached the end of buffer content.</li>
<li>bad: external error, likely irrecoverable.</li>
</ul>
<p><code>iss.good()</code> 就会返回一个 bool 表示该 stream 是否出错。类似：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">iss</span><span class="p">.</span><span class="n">fail</span><span class="p">())</span>  <span class="k">throw</span> <span class="n">domain_error</span><span class="p">(...);</span></span></span></code></pre></div></div>
<p>还有一种隐式转换成 bool 的写法会更简短，二者是等价的：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-c">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">ch</span><span class="p">))</span>  <span class="n">throw</span> <span class="nf">domain_error</span><span class="p">(...);</span></span></span></code></pre></div></div>
<p>比如一个将 string 转为 int 的函数可以这么写：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">stringToInteger</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">istringstream</span> <span class="n">iss</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">result</span><span class="p">;</span> <span class="kt">char</span> <span class="n">remain</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">)</span> <span class="o">||</span> <span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">remain</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="n">domain_error</span><span class="p">(...);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>什么时候应该使用 string stream</p>
<ul>
<li>处理字符串的时候</li>
<li>格式化输出或输入（一些 stream manipulators，比如 endl, hex, uppercase 之类的）</li>
<li>解析成不同的类型</li>
</ul>
<h2 id="input-stream--output-steam">Input stream &amp; Output steam</h2>
<ul>
<li>cin, standard input stream</li>
<li>cout, standard output stream (buffered)</li>
<li>cerr, standard error stream (unbuffered)</li>
<li>clog, standard error stream (buffered)</li>
</ul>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">home</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;What is your name?&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;What is your age?&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Where are you from?&#34;</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">home</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello, &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; (age &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; from &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">home</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;)&#34;</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></div></div>
<p>对于上面这段代码，如果你输入 Avery Wang，程序会直接走到终点：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ g++ -std<span class="o">=</span>c++17 -Wall test.cpp -o <span class="nb">test</span>
</span></span><span class="line"><span class="cl">$ ./test
</span></span><span class="line"><span class="cl">What is your name ?
</span></span><span class="line"><span class="cl">Avery Wang
</span></span><span class="line"><span class="cl">What is your age ?
</span></span><span class="line"><span class="cl">Where are you from ?
</span></span><span class="line"><span class="cl">Hello, Avery <span class="o">(</span>age <span class="m">0</span> from <span class="o">)</span></span></span></code></pre></div></div>
<p><code>cin</code> 会读到下一个空白符，所以第一个 <code>cin</code> 只会把 <code>Avery</code> 读进去，并且指针更新到了那个空白符的位置，之后 <code>cin &gt;&gt; age</code> 的时候，由于 buffer 不为空，所以会直接尝试把 <code>Wang</code> 读成 int，但是失败了，这时候 fail bit 打开，之后的 <code>cin</code> 也不会进行了。</p>
<p>这就是<code>cin</code>带来的问题了：</p>
<ol>
<li><code>cin</code> 会读一整行到 buufer 中，但是会用空格符分隔开递出。</li>
<li>buffer 中可能会有残余的数据导致用户无法及时地被提示应该输入</li>
<li><code>cin</code> fail 了之后就再也不会执行 <code>cin</code> 了</li>
</ol>
<p>如果使用<code>getline()</code>，就可以避免这个问题。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span></span></span></code></pre></div></div>
<p>第三个参数就是一个标记，<code>getline()</code> 会读到这个字符之前（也就是不包括这个字符），并把指针更新到这个字符之后。但如果你把第三个 <code>home</code> 变量的读取也改成了 <code>getline()</code> 读取，程序运行的时候会跳过它，因为 <code>cin &gt;&gt; age</code> 把指针更新到了 <code>\n</code> 之前，而 <code>getline()</code> 会直接读到 <code>\n</code> 之前（也就是空数据）。就像这样：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">A</td>
          <td style="text-align: center">v</td>
          <td style="text-align: center">e</td>
          <td style="text-align: center">r</td>
          <td style="text-align: center">y</td>
          <td style="text-align: center">_</td>
          <td style="text-align: center">W</td>
          <td style="text-align: center">a</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">g</td>
          <td style="text-align: center">\n</td>
          <td style="text-align: center">2</td>
          <td style="text-align: center">0</td>
          <td style="text-align: center">\n</td>
          <td></td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>这里的<code>_</code>指的是空格符。</p>
<p>可以在第二个 <code>getline()</code> 之前加上一句 <code>cin.ignore()</code> 跳过一个字符（也就是<code>\n</code>）来解决这个问题。</p>
<p><code>std::cout</code> 是 <code>std::ostream</code> 定义的全局的 constant 对象，<code>std::ostream</code> 会将输入的数据类型都转成 string 并发送到 stream，而 <code>std::cout</code> 是会将这个 output stream 发送到 console 上。</p>
<p><code>std::cin</code> 是 <code>std::istream</code> 定义的全局 constant 对象。这里的 <code>&gt;&gt;</code> 会一直读取用户的输入直到 <em>whitespace</em>，这里的 whitespace 是指 Tab, space, newline。</p>
<h2 id="file-stream">File Stream</h2>
<p><code>std::ofstream</code>，只能用 <code>&lt;&lt;</code> 操作符传递数据，它会将数据类型转成 string 并发送到 file stream 上。</p>
<p><code>std::ifstream</code>，只能用 <code>&gt;&gt;</code> 操作符传递数据。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">out</span><span class="p">(</span><span class="s">&#34;out.txt&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// out is now an ofstream that outputs to out.txt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// out.txt contains 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">in</span><span class="p">(</span><span class="s">&#34;out.txt&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// in is now an ifstream that reads from out.txt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">in</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">;</span> <span class="c1">// first word in out.txt goes into str
</span></span></span></code></pre></div></div>
<hr>
<p>Uniform initialization: 使用大括号来初始化变量，适用于所有类型</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">numSuffix1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="s">&#34;st&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Student</span> <span class="n">s</span><span class="p">{</span><span class="s">&#34;Frankie&#34;</span><span class="p">,</span> <span class="s">&#34;MN&#34;</span><span class="p">,</span> <span class="mi">21</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">possible</span><span class="o">!</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span><span class="p">{</span><span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">f</span><span class="p">{</span><span class="s">&#34;Frankie&#34;</span><span class="p">};</span></span></span></code></pre></div></div>
<p>但要注意对 vector 大括号和括号之间的区别：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec1</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// makes {5, 5, 5}, not {3, 5}!
</span></span></span><span class="line"><span class="cl"><span class="c1">//uses a std::initializer_list (more later)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec2</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// makes {3, 5}
</span></span></span></code></pre></div></div>
<hr>
<h1 id="type">Type</h1>
<h2 id="type-alias">Type alias</h2>
<p>类型别名是一个很有用的东西，比如对于下边这样的代码：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">forward_list</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">unordered_set</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">studentMap</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">forward_list</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">unordered_set</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">end</span> <span class="o">=</span> <span class="n">studentMap</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span></span></span></code></pre></div></div>
<p>可以使用别名简化</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">map_iterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">forward_list</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">unordered_set</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">map_iterator</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">studentMap</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">map_iterator</span> <span class="n">end</span> <span class="o">=</span> <span class="n">studentMap</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span></span></span></code></pre></div></div>
<p>C++引入了 <code>auto</code> 关键字，<code>auto</code> 的本质是要让编译器找出这个类型。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">studentMap</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">studentMap</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span></span></span></code></pre></div></div>
<p>又比如这样：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">};</span></span></span></code></pre></div></div>
<p>这是一个 lamdba 函数，你并不知道这是什么类型，编译器会自动为此创建一个类的实例，由于开发者不知道编译器会为这个类起什么名字，所以需要用 <code>auto</code>。</p>
<h2 id="when-auto-should-be-used">When <code>auto</code> should be used</h2>
<p>AAA 原则： almost always auto</p>
<ul>
<li>在代码上下文清晰的时候使用<code>auto</code></li>
<li>当用确切的类型定义不重要的时候使用<code>auto</code></li>
<li>当严重破坏了可读性的时候不要使用<code>auto</code></li>
</ul>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">findPriceRange</span><span class="p">(</span><span class="kt">int</span> <span class="n">dist</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dist</span> <span class="o">*</span> <span class="mf">0.08</span> <span class="o">+</span> <span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dist</span> <span class="o">*</span> <span class="mf">0.36</span> <span class="o">+</span> <span class="mi">750</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">make_pair</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="mi">6452</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="p">[</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">]</span> <span class="o">=</span> <span class="n">findPriceRange</span><span class="p">(</span><span class="n">dist</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;You can find price between: &#34;</span>
</span></span><span class="line"><span class="cl">         <span class="o">&lt;&lt;</span> <span class="n">min</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; and &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">max</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>
<p>这样的代码更加的现代一些，<code>findPriceRange()</code> 函数只需要传一个参数<code>dist</code>，返回 <code>min</code> 和 <code>max</code> 的 pair，这样也更加自然（对比传入三个参数：dist, min, max）。</p>
<p>像上面这个代码寻找区间的代码写成库函数给开发者调用的话是很不友好的，因为返回值没有做出更好的区分表明到底谁是 min，谁是 max，这时候可以使用结构体来对返回值进行一层抽象。不过在 C++中，结构体定义变量的时候 <code>struct</code> 关键字是可选的，比如：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Student</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Student</span> <span class="n">st</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;age: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, number: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span></span></code></pre></div></div>
<p>在 C 中，这需要<code>typedef</code>才能实现</p>
<p>Structured binding：一次性将复合类型变量的元素取值操作完成</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="err">“</span><span class="n">s</span><span class="err">”</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">second</span><span class="p">;</span></span></span></code></pre></div></div>
<p>使用了 Structured binding 就可以写成下边这样：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="err">“</span><span class="n">s</span><span class="err">”</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span></span></span></code></pre></div></div>
<p>C++ 默认赋值是 copy 的，如果函数传参涉及修改原数据应该用 <code>&amp;</code> 引用，如果在其函数内部会出现对这种参数的赋值，也需要加 <code>&amp;</code> ：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-cpp">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">shift</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">num1</span><span class="p">,</span> <span class="n">num2</span><span class="p">]</span><span class="o">:</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">num1</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">num2</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>]]></description>
</item>
<item>
    <title>Xv6 book: File system</title>
    <link>http://localhost:1313/posts/xv6_book_chapter_8/</link>
    <pubDate>Sat, 22 Apr 2023 03:42:51 &#43;0000</pubDate>
    <author>suo yuan</author>
    <guid>http://localhost:1313/posts/xv6_book_chapter_8/</guid>
    <description><![CDATA[<p>Xv6 book 的第八章节</p>
<h1 id="file-system">File system</h1>
<p>文件系统的目的是组织和存储数据。文件系统通常支持在用户和应用程序之间共享数据，以及持久性，以便在重新启动后数据仍然可用。</p>
<p>Xv6文件系统提供类似于Unix的文件、目录和路径名（参见第1章），并将其数据存储在virtio磁盘上以实现持久性。文件系统解决了以下几个问题：</p>
<ul>
<li>文件系统需要在磁盘上使用数据结构来表示命名目录和文件的树形结构，记录每个文件内容所在块的标识，并记录磁盘上哪些区域是空闲的。</li>
<li>文件系统必须支持崩溃恢复。也就是说，如果发生崩溃（例如断电），文件系统在重新启动后必须仍然正确工作。风险在于崩溃可能会中断一系列更新，导致不一致的磁盘上数据结构（例如，一个既在文件中使用又被标记为空闲的block）。</li>
<li>不同的进程可能同时操作文件系统，因此文件系统代码必须协调以维护不变性。</li>
<li>访问磁盘比访问内存慢几个数量级，因此文件系统必须维护一个内存中的高速缓存以存储常用的block。</li>
</ul>
<p>本章的剩下的部分将解释xv6如何应对这些挑战。</p>
<h2 id="overview">Overview</h2>
<p></p>
<p>Xv6文件系统实现分为七个层次，如图8.1所示。Disk层读取和写入virtio硬盘上的块。Buﬀer cache层缓存磁盘块并同步对它们的访问，确保每次只有一个内核进程可以修改任何特定块中存储的数据。Logging层允许更高层将对多个块的更新包装在<em>transaction</em>中，并确保在发生崩溃时原子地更新这些块（即它们要么全部更新，要么一个也不更新）。Inode层提供了单个文件，每个文件都表示为一个具有唯一编号i和一些包含文件数据的块的inode。Directory层将每个目录实现为一种特殊类型的inode，其内容是一系列目录条目，每个目录条目包含文件的名称和i编号。Pathname层提供类似于<code>/usr/rtm/xv6/fs.c</code>的分层路径名，并使用递归查找解析它们。File descriptor层使用文件系统接口抽象了许多Unix资源（例如，管道、设备、文件等），简化了应用程序程序员的工作。</p>
<p>传统上，磁盘硬件将磁盘上的数据表示为一系列编号的512字节块（也称为扇区， <em>sectors</em>）：扇区0是前512字节，扇区1是接下来的，依此类推。操作系统用于文件系统的块（block）大小可能与磁盘使用的扇区大小不同，但通常block的大小是sector大小的倍数。Xv6将其读入内存的块的副本存储在<code>struct buf</code>类型的对象中（<strong>kernel/buf.h</strong>）。该结构中存储的数据有时与磁盘不同步：它可能尚未从磁盘读取（磁盘正在处理，但尚未返回扇区的内容），或者它可能已被软件更新，但尚未写入磁盘。</p>
<p>文件系统必须有一个计划，确定在磁盘上存储inode和content blocks的位置。为此，xv6将磁盘划分为几个部分，如图8.2所示。文件系统不使用块0（它保存引导扇区）。块1称为<em>superblock</em>；它包含有关文件系统的元数据（文件系统大小、数据块数、inode数和日志中的块数）。从块2开始保存日志。在日志之后是inodes，每个块包含多个inode。在它们之后是用于跟踪哪些数据块正在使用的bitmap block。其余的块是数据块；每个数据块在bitmap block中标记为free，或者保存文件或目录的内容。<em>superblock</em>由一个名为<code>mkfs</code>的单独的程序填充，该程序构建初始文件系统。</p>
<p></p>
<p>本章的其余部分将讨论文件系统的每一层，从buffer cache开始。请注意在较低层次选择得当的抽象如何简化较高层次的设计。</p>
<h2 id="buffer-cache-layer">Buffer cache layer</h2>
<p>缓冲区缓存有两个任务：(1) 同步对磁盘块的访问，以确保内存中只有一个块的副本，并且每次只有一个内核线程使用该副本；(2) 缓存常用块，以便它们无需从慢速磁盘重新读取。相关代码在<strong>bio.c</strong>中。</p>
<p>Buﬀer cache主要提供的接口包括<code>bread()</code>和<code>bwrite()</code>；前者获取一个包含块副本的<code>buf</code>，可以在内存中读取或修改，而后者将修改后的缓冲区写入磁盘上的相应的block。内核线程在完成对缓冲区的使用后必须通过调用<code>brelse()</code>来释放缓冲区。Buﬀer cache通过使用每个缓冲区的sleep-lock确保了每次只有一个线程使用该缓冲区；<code>bread()</code>返回一个已锁定的缓冲区，而<code>brelse()</code>释放锁。</p>
<p>Buffer cache有固定数量的缓冲区来保存磁盘块，这意味着如果文件系统请求一个尚未在缓存中的块，缓冲区缓存必须回收当前保存其他块的缓冲区。缓冲区缓存为新块回收最近最少使用的缓冲区。这个假设是最近最少使用的缓冲区最不可能很快再次被使用。</p>
<h2 id="code-buffer-cache">Code: Buffer cache</h2>
<p>Buffer cache是一个双向链表，由<code>NBUF</code>个缓冲区的静态数组<code>buf</code>（<strong>kernel/bio.c</strong>）初始化。由<code>main()</code>调用的函数<code>binit()</code>负责初始化这个链表。所有对buffer cache的访问都通过<code>bcache.head</code>引用链表，而不是<code>buf</code>数组。</p>
<p>每个cache都有两个与之相关的状态字段。<code>valid</code>字段指示缓冲区包含块的副本。<code>disk</code>字段指示缓冲区内容已经交给磁盘，这可能会改变缓冲区（例如，从磁盘写入数据）。</p>
<p><code>bread()</code>调用<code>bget()</code>以获取给定扇区的缓冲区。如果需要从磁盘读取缓冲区，<code>bread()</code>调用<code>virtio_disk_rw()</code>执行读取操作，然后返回缓冲区。</p>
<p><code>bget()</code>扫描缓冲区列表，查找具有给定设备和扇区号的缓冲区。如果存在这样的缓冲区，<code>bget()</code>获取缓冲区的sleep-lock。然后，<code>bget()</code>返回锁定的缓冲区。</p>
<p>如果给定扇区没有缓存的缓冲区，<code>bget()</code>必须创建一个，可能会重用曾经包含不同扇区的缓冲区。它再次扫描缓冲区列表，寻找未使用的缓冲区（<code>b-&gt;refcnt = 0</code>）；任何这样的缓冲区都可以使用。<code>bget()</code>编辑buffer的metadata以记录新的设备和扇区号，并获取其sleep-lock。请注意，赋值<code>b-&gt;valid = 0</code>确保<code>bread()</code>将从磁盘读取块数据，而不会错误地使用缓冲区的先前内容。</p>
<p>为了确保读取者能够看到写入的内容和文件系统在cache上使用锁进行同步，必须确保每个磁盘扇区最多只有一个buffer cache。<code>bget()</code>通过在第一个循环检查块是否已缓存时持续持有<code>bache.lock</code>，直到第二个循环声明块现在已缓存（通过设置<code>dev</code>、<code>blockno</code>和<code>refcnt</code>）来确保这个不变式。这导致对block存在性的检查（如果不存在，则指定用于保存块的缓冲区）是原子的。</p>
<p><code>bget()</code>在<code>bcache.lock</code>关键部分之外获取缓冲区的sleep-lock是安全的，因为非零的<code>b-&gt;refcnt</code>阻止重用缓冲区用于不同的磁盘块。Sleep-lock保护对块缓冲内容的读取和写入，而<code>bcache.lock</code>保护有关哪些块已被缓存的信息。</p>
<p>如果所有的缓冲区都是busy的，说明有太多的进程同时执行文件系统调用；此时，<code>bget()</code>会产生 panic。一个更好的响应可能是等待到有一个缓冲区变为空闲，虽然这样可能导致死锁。</p>
<p>一旦<code>bread()</code>读取了磁盘并将缓冲区返回给调用者，调用者就独占了该缓冲区，并可以读取或写入数据字节。如果调用者修改了缓冲区，必须调用<code>bwrite()</code>将更改的数据写入磁盘，然后释放缓冲区。<code>bwrite()</code>调<code>virtio_disk_rw()</code>与磁盘硬件进行通信。</p>
<p>当调用者使用完缓冲区后，必须调用<code>brelse()</code>进行释放。<code>brelse()</code>的名字虽然有点神秘(<em>b-release</em>)，但值得学习：它起源于 Unix，并在 BSD、Linux 和 Solaris 中也被使用。<code>brelse()</code>释放了sleep-lock，并将缓冲区移动到链表的前面。移动缓冲区会导致链表按照缓冲区的最近使用时间排序：链表中的第一个缓冲区是最近使用过的，而最后一个是最久未使用的。<code>bget()</code>中的两个循环利用了这一点：在最坏的情况下，查找现有缓冲区必须处理整个链表，但首先检查最近使用的缓冲区（从<code>bcache.head</code>开始，按照<code>next</code>指针进行跟踪）将减少扫描时间，当引用局部性较好时。选择要重用的缓冲区的扫描通过向后扫描（按照<code>prev</code>指针进行跟踪）选择最久未使用的缓冲区。</p>
<h2 id="logging-layer">Logging layer</h2>
<p>文件系统设计中最有趣的问题之一是crash recovery。这个问题的出现是因为许多文件系统操作涉及对磁盘的多次写入，而在一些写入的子集之后发生的崩溃可能会导致磁盘上的文件系统处于不一致的状态。例如，假设在文件截断（将文件长度设置为零并释放其内容块）期间发生崩溃。根据磁盘写入的顺序，崩溃可能会使一个inode引用一个被标记为自由的内容块，或者它可能会留下一个分配但未引用的内容块。</p>
<p>后者相对无害，但是引用已释放块的inode在重启后可能会导致严重的问题。重启后，内核可能会将该块分配给另一个文件，现在我们有两个不同的文件无意中指向相同的块。如果xv6支持多个用户，这种情况可能是一个安全问题，因为旧文件的所有者将能够读取和写入由不同用户拥有的新文件中的块。</p>
<p>Xv6通过一种简单的日志形式解决了在文件系统操作期间发生崩溃的问题。在xv6中，一个系统调用不会直接写入磁盘上的文件系统数据结构。相反，它将希望进行的所有磁盘写入的描述放入磁盘上的一个日志中。一旦系统调用记录了所有的写入，它就会向磁盘写入一个特殊的<em>commit</em>记录，指示日志包含一个完整的操作。此时，系统调用将写入复制到磁盘上的文件系统数据结构中。在这些写入完成之后，系统调用会擦除磁盘上的日志。</p>
<p>如果系统崩溃并重新启动，文件系统代码将在运行任何进程之前按照以下步骤从崩溃中恢复。如果日志被标记为包含完整的操作，那么恢复代码将把写入复制到它们在磁盘上的正确位置。如果日志没有被标记为包含完整的操作，恢复代码将忽略该日志。恢复代码最后会擦除日志。</p>
<p>为什么xv6的日志解决了文件系统操作期间发生崩溃的问题呢？如果崩溃发生在操作提交之前，那么磁盘上的日志将不会被标记为完整，恢复代码将忽略它，磁盘的状态将好像操作甚至还没有开始。如果崩溃发生在操作提交之后，那么恢复将重新播放所有操作的写入，如果该操作已经开始将它们写入磁盘数据结构，则可能重复执行它们。在任一情况下，日志使操作在崩溃方面具有原子性：恢复后，要么所有操作的写入都出现在磁盘上，要么它们都不出现。</p>
<h2 id="log-design">Log design</h2>
<p>Log位于superblock中指定的已知固定位置。它由一个header block和一个更新块副本序列（“logged blocks”）组成。Header block包含一个用于记录扇区号的数组和log blocks的计数。磁盘上header block中的计数要么为零，表示日志中没有事务，要么为非零，表示日志包含一个完整的已提交事务，其中包含指定数量的logged blocks。Xv6在transaction提交时写入header block，但在此之前不写入，并在将logged blocks复制到文件系统后将计数设置为零。因此，在transaction中途发生崩溃将导致日志头块中的计数为零；在提交后发生崩溃将导致计数为非零。</p>
<p>每个系统调用的代码指示了必须在崩溃方面具有原子性的写入序列的开始和结束。为了允许不同进程之间并发执行文件系统操作，日志系统可以将多个系统调用的写入积累到一个transaction中。因此，一个单独的提交可能涉及多个完整系统调用的写入。为了避免将系统调用跨越多个transaction，日志系统仅在没有进行文件系统系统调用时才进行提交。</p>
<p>将多个事务一起提交的想法称为<em>group commit</em>。Group commit减少了磁盘操作的次数，因为它将提交的固定成本分摊到多个操作中。Group commit还一次性向磁盘系统提供了更多的并发写入，也许允许磁盘在单个磁盘旋转期间将它们全部写入。Xv6的virtio驱动程序不支持这种批处理方式，但xv6的文件系统设计允许这样做。</p>
<p>Xv6在磁盘上专门分配了一定数量的空间来保存日志。事务中由系统调用写入的块的总数必须适应该空间。这带来了两个后果。</p>
<ol>
<li>不允许单个系统调用写入的不同块的数量超过日志中的空间。对于大多数系统调用来说，这不是问题，但其中两个系统调用可能会写入许多块：<code>write()</code>和<code>unlink()</code>。大文件写入可能会写入许多data blocks和许多bitmap blocks以及一个inode块；取消链接大文件可能会写入许多bitmap blocks和一个inode。Xv6的<code>write()</code>系统调用将大写入拆分为适应日志的多个较小写入，而<code>unlink()</code>不会引起问题，因为实际上xv6文件系统只使用一个bitmap block。</li>
<li>有限的日志空间的另一个后果是，除非确定系统调用的写入将适应日志中剩余的空间，否则日志系统不能允许系统调用启动。</li>
</ol>
<h2 id="code-logging">Code: logging</h2>
<p>在系统调用中，一个典型的log的使用如下所示：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-c">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">begin_op</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">bp</span> <span class="o">=</span> <span class="nf">bread</span><span class="p">(...);</span>
</span></span><span class="line"><span class="cl"><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[...]</span> <span class="o">=</span> <span class="p">...;</span>
</span></span><span class="line"><span class="cl"><span class="nf">log_write</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="nf">end_op</span><span class="p">();</span></span></span></code></pre></div></div>
<p><code>begin_op()</code>（<strong>kernel/log.c</strong>）会等待，直到日志系统当前没有进行提交，并且有足够的未保留的日志空间来容纳此调用的写入。<code>log.outstanding</code>计算已经保留了日志空间的系统调用数量；总的保留空间是<code>log.outstanding</code>乘以<code>MAXOPBLOCKS</code>。增加<code>log.outstanding</code>既保留空间又防止在此系统调用期间发生提交。该代码保守地假设每个系统调用可能写入多达<code>MAXOPBLOCKS</code>个不同的块。</p>
<p><code>log_write()</code>替代了<code>bwrite</code>。它在内存中记录块的扇区号，在磁盘上为其保留一个槽，并将缓冲区锁定在块缓存中，以防止块缓存将其逐出。块必须保留在缓存中直到提交为止：在那之前，缓存的副本是修改的唯一记录；在提交之前，不能将其写入磁盘上的位置；同一事务中的其他读取必须看到修改。<code>log_write()</code>在单个transaction中多次写入块时会注意到，并在日志中为该块分配相同的槽。这种优化通常称为<em>absorption</em>。例如，在单个transaction中可能多次写入包含多个文件的inode的磁盘块。通过将多个磁盘写入吸收为一个，文件系统可以节省日志空间，并且因为只需要将磁盘块的一个副本写入磁盘，所以可以实现更好的性能。</p>
<p><code>end_op()</code>首先递减未完成的系统调用计数。如果计数现在为零，则通过调用<code>commit()</code>提交当前事务。该过程分为四个阶段。<code>write_log()</code>将transaction中修改的每个块从缓冲区复制到磁盘上的日志槽中。<code>write_head()</code>将header block写入磁盘：这是commit point，如果在写入后发生崩溃，恢复将从日志中重新执行transaction的写入。<code>install_trans()</code>从日志中读取每个块并将其写入文件系统中的适当位置。最后，<code>end_op()</code>写入带有计数零的log header；这必须在下一个transaction开始写入logged blocks之前发生，以便在崩溃时恢复不会使用一个transaction的头以及后续transaction的logged blocks。</p>
<p><code>recover_from_log()</code>是从<code>initlog()</code>调用的，而<code>initlog()</code>是在引导过程中，在第一个用户进程运行之前从<code>fsinit()</code>被调用。它读取log header，并在header指示日志包含一个已提交transaction时模仿<code>end_op()</code>的操作。</p>
<p>日志的一个示例用法出现在<code>filewrite()</code>中。该transaction如下：</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-c">
        <span class="code-title"><i class="arrow fas fa-angle-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">begin_op</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nf">ilock</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">r</span> <span class="o">=</span> <span class="nf">writei</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span> <span class="p">...);</span>
</span></span><span class="line"><span class="cl"><span class="nf">iunlock</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">end_op</span><span class="p">();</span></span></span></code></pre></div></div>
<p>此代码被包装在一个循环中，将大型写操作分解为仅包含几个扇区的单独transaction，以避免日志溢出。<code>writei()</code>的调用在此transaction中写入许多块：文件的 inode，一个或多个bitmap blocks以及一些data blocks。</p>
<h2 id="code-block-allocator">Code: Block allocator</h2>
<p>文件和目录内容存储在磁盘块中，这些块必须从一个空闲的pool中分配。Xv6 的block allocator在磁盘上维护一个free bitmap，每个块对应一个位。零位表示相应的块是空闲的；一位表示它正在使用中。<code>mkfs</code>程序设置与boot sector、superblock、log blocks、inode 块和bitmap blocks对应的位。</p>
<p>Block allocator提供两个功能：<code>balloc()</code>用于分配新的磁盘块，<code>bfree()</code>用于释放块。<code>balloc()</code>中的循环（<strong>kernel/fs.c</strong>）考虑每个块，从块 0 到 <code>sb.size</code>（文件系统中的块数）。它查找bitmap位为零的块，表示它是空闲的。如果找到这样的块，<code>balloc()</code>就会更新bitmap并返回该块。为了提高效率，循环分为两个部分。外部循环读取每个bitmap位的块。内部循环检查单个bitmap block中的所有Bits-Per-Block（BPB）。如果两个进程尝试同时分配块，可能发生的竞争由于缓冲区缓存一次只允许一个进程使用任何一个bitmap block而被阻止。</p>
<p><code>bfree()</code>找到正确的bitmap block并清除正确的位。同样，由<code>bread()</code>和<code>brelse()</code>隐含的独占使用避免了对显式锁定的需求。</p>
<p>与本章剩余部分描述的大部分代码一样，<code>balloc()</code>和<code>bfree()</code>必须在一个transaction内调用。</p>
<h2 id="inode-layer">Inode layer</h2>
<p>术语 &ldquo;inode&rdquo; 可以有两个相关的含义。它可能指的是包含文件大小和数据块编号列表的磁盘上的数据结构。或者 &ldquo;inode&rdquo; 可能指的是内存中的 inode，其中包含磁盘上 inode 的副本以及内核内部所需的额外信息。</p>
<p>磁盘上的 inodes 被紧密地打包成一个称为 inode 块的连续磁盘区域。每个 inode 的大小相同，因此，根据给定的编号 n，可以轻松找到磁盘上的第 n 个 inode。实际上，这个编号 n，称为 inode 编号或 i-number，是实现中用于标识 inodes 的方式。</p>
<p>磁盘上的 inode 由<code>struct dinode</code>定义。<code>type</code> 字段区分文件、目录和特殊文件（设备）。类型为零表示磁盘上的 <code>inode</code> 是空闲的。<code>nlink</code> 字段计算引用此 <code>inode</code> 的目录条目数量，以便在应该释放磁盘上的 <code>inode</code> 及其数据块时识别。<code>size</code> 字段记录文件内容的字节数。<code>addrs</code> 数组记录持有文件内容的磁盘块的块编号。</p>
<p>内核将active的 inodes 集合保存在内存中的一个称为 <code>itable</code> 的表中；<code>struct inode</code>是磁盘上 <code>struct dinode</code> 的内存副本。内核仅在有 C 指针引用该 inode 时才将 inode 保存在内存中。<code>ref</code> 字段计算引用该内存中的 inode 的 C 指针数量，如果引用计数降至零，内核将从内存中丢弃该 <code>inode</code>。<code>iget()</code> 和 <code>iput()</code> 函数获取和释放对 inode 的指针，同时修改引用计数。指向 inode 的指针可以来自文件描述符、当前工作目录和transient kernel code（如 exec）。</p>
<p>xv6 的 inode 代码中有四个锁或类似锁的机制。<code>itable.lock</code> 保护 inode 最多只在 inode 表中出现一次的不变性，以及内存中的 inode 的 <code>ref</code> 字段计算指向该 inode 的内存指针的数量的不变性。每个内存中的 inode 都有一个 <code>lock</code> 字段，其中包含一个 <code>sleep-lock</code>，确保对 inode 的字段（如文件长度）以及 inode 的文件或目录内容块的独占访问。如果 inode 的 <code>ref</code> 大于零，则系统会在表中维护该 inode，并且不会重用表条目以用于不同的 inode。最后，每个 inode 包含一个 <code>nlink</code> 字段（在磁盘上和在内存中复制），计算引用文件的目录条目数量；如果 inode 的链接计数大于零，xv6 将不会释放该 inode。</p>
<p><code>iget()</code> 返回的 <code>struct inode</code> 指针在对应的 <code>iput()</code> 调用之前是有效的；该 inode 不会被删除，指针引用的内存也不会被重用于不同的 inode。<code>iget()</code> 提供对 inode 的非独占访问，因此可以有多个指向相同 inode 的指针。文件系统代码的许多部分都依赖于 <code>iget()</code> 的这种行为，既用于保持对 inodes 的长期引用（如打开的文件和当前目录），又用于在处理多个 inodes 的代码中避免竞争而避免死锁（如路径名查找）。</p>
<p><code>iget()</code> 返回的 <code>struct inode</code> 可能没有任何有用的内容。为了确保它包含磁盘上 inode 的副本，代码必须调用 <code>ilock</code>。这将锁定 inode（以便其他进程无法锁定它），并从磁盘读取 inode，如果尚未读取。<code>iunlock</code> 释放 inode 上的锁。将获取 inode 指针与锁定分开有助于在某些情况下避免死锁，例如在目录查找期间。多个进程可以持有 <code>iget()</code> 返回的指向 inode 的 C 指针，但一次只能有一个进程锁定 inode。</p>
<p>inode表仅存储内核代码或数据结构持有 C 指针的 inodes。其主要工作是同步多个进程的访问。inode表也恰好缓存了频繁使用的 inodes，但缓存是次要的；如果 inode 频繁使用，缓冲区缓存可能会保持它在内存中。修改内存中的 inode 的代码使用 <code>iupdate()</code> 将其写入磁盘。</p>
<h2 id="code-inodes">Code: Inodes</h2>
<p>为了分配一个新的 inode（例如，创建文件时），xv6 调用 <code>ialloc()</code>（<strong>kernel/fs.c</strong>）。<code>ialloc()</code> 类似于 <code>balloc()</code>：它循环遍历磁盘上的 inode 结构，逐个块查找标记为 free 的 inode。当找到一个时，它通过将新的类型写入磁盘来声明它，然后通过调用 <code>iget()</code> 返回 inode 表中的一个条目。<code>ialloc()</code> 的正确操作依赖于一个事实，即一次只能有一个进程持有对 <code>bp</code> 的引用：<code>ialloc()</code> 可以确信没有其他进程同时看到 inode 可用并尝试声明它。</p>
<p><code>iget()</code> 在 inode 表中查找一个具有所需设备和 inode 编号的活动条目（<code>ip-&gt;ref &gt; 0</code>）。如果找到一个，它将返回对该 inode 的新引用。在扫描时，<code>iget</code> 记录了第一个空槽的位置，如果需要分配表条目，它将使用该位置。</p>
<p>代码在读取或写入 inode 的metadata或内容之前必须使用 <code>ilock()</code> 锁定 inode。<code>ilock()</code>为此目的使用了一个 sleep-lock。一旦 ilock 具有对 inode 的独占访问权，它将根据需要从磁盘（更可能是缓冲区缓存）读取 inode。<code>iunlock()</code> 函数释放了 sleep-lock，这可能导致正在休眠的任何进程被唤醒。</p>
<p><code>iput()</code> 通过减少引用计数释放对 inode 的 C 指针。如果这是最后一个引用，那么 inode 表中的该 inode 位置现在空闲，可以用于不同的 inode。</p>
<p>如果 <code>iput()</code> 发现没有 C 指针引用一个 inode，并且该 inode 没有指向它的链接（在任何目录中都没有），那么这个 inode 及其data block必须被释放。<code>iput()</code> 调用 <code>itrunc()</code> 将文件截断为零字节，释放数据块；将 inode 类型设置为 0（未分配）；并将 inode 写入磁盘。</p>
<p><code>iput()</code> 在释放 inode 的情况下的锁定协议值得仔细研究。一个危险是，一个并发线程可能正在 <code>ilock()</code> 中等待使用此 inode（例如，读取文件或列出目录），并且还没准备好发现该 inode 不再分配。这不会发生，因为系统调用无法在它没有对其进行链接的情况下获取指向内存中 inode 的指针，而 <code>ip-&gt;ref</code> 为 1。这一个引用是调用 <code>iput()</code> 的线程拥有的引用。<code>iput()</code> 确实在 <code>itable.lock</code> 临界区外检查引用计数是否为 1，但在那时，链接计数已知为零，因此没有线程会尝试获取新引用。另一个主要的危险是，一个并发的 <code>ialloc()</code> 调用可能选择 <code>iput()</code> 正在释放的相同 inode。这只能在 <code>iupdate()</code> 写入磁盘后，inode 具有类型零的情况下发生。这种竞争是无害的；分配线程将在读取或写入 inode 之前礼貌地等待获取 inode 的 sleep-lock，在那时 iput 已经完成了对它的使用。</p>
<p><code>iput()</code> 可以写入磁盘。这意味着任何使用文件系统的系统调用都可能写入磁盘，因为该系统调用可能是对文件的最后一个引用。即使像 <code>read()</code> 这样表面上是只读的调用，也可能最终调用 <code>iput()</code>。这反过来意味着即使是只读系统调用，如果它们使用文件系统，也必须包装在transaction中。</p>
<p><code>iput()</code> 和crash之间存在一个复杂的交互。<code>iput()</code> 在文件的链接计数降至零时并不立即截断文件，因为某些进程可能仍然在内存中持有对 inode 的引用：进程可能仍然在读取和写入文件，因为它成功打开了文件。但是，如果在最后一个进程关闭文件描述符之前发生崩溃，那么文件将在磁盘上标记为已分配，但没有目录项指向它。</p>
<p>文件系统处理这种情况的方式有两种。简单的解决方案是在重启后的恢复过程中，文件系统扫描整个文件系统，查找已标记为分配但没有目录项指向它们的文件。如果存在这样的文件，它们就可以被释放。</p>
<p>第二种解决方案则无需扫描整个文件系统。在这种解决方案中，文件系统在磁盘上记录（例如，在super block中）链接计数降至零但引用计数不为零的文件的 inode 编号。如果文件系统在引用计数达到 0 时删除文件，那么它会通过从列表中删除该 inode 来更新磁盘上的列表。在恢复时，文件系统会释放列表中的任何文件。</p>
<p>Xv6 没有实现这两种解决方案，这意味着即使 inode 不再使用，它们可能仍然在磁盘上标记为已分配。这意味着随着时间的推移，xv6 有可能会耗尽磁盘空间。</p>
<h2 id="code-inode-content">Code: Inode content</h2>
<p>磁盘上的 inode 结构 <code>struct dinode</code> 包含一个大小（size）和一个block numbers数组（见图 8.3）。inode 数据位于列在 <code>dinode</code> 的 <code>addrs</code> 数组中的块中。前 <code>NDIRECT</code> 个数据块列在数组的前 <code>NDIRECT</code> 个条目中；这些块称为直接块（<em>direct blocks</em>）。接下来的 <code>NINDIRECT</code> 个数据块的位置不在 inode 中，而是在一个称为间接块（<em>indirect block</em>）的数据块中。<code>addrs</code> 数组中的最后一个条目给出了间接块的地址。因此，文件的前 12 kB（<code>NDIRECT x BSIZE</code>）字节可以从 inode 中列出的块中加载，而接下来的 256 kB（<code>NINDIRECT x BSIZE</code>）字节只能在查阅间接块后加载。这是一种适合磁盘的表示，但对客户端而言过于复杂。函数 <code>bmap()</code> 管理这种表示，以便higher-level routines，例如后面将要看到的 <code>readi()</code> 和 <code>writei()</code>，不需要处理这种复杂性。<code>bmap()</code> 返回 inode <code>ip</code> 的第 <code>bn</code> 个数据块的磁盘块号。如果 <code>ip</code> 还没有这样的块，<code>bmap</code> 会分配一个。</p>
<p></p>
<p>函数 <code>bmap()</code>首先处理简单的情况：前 <code>NDIRECT</code> 个块列在 inode 本身中。接下来的 <code>NINDIRECT</code> 个块列在 <code>ip-&gt;addrs[NDIRECT]</code> 处的间接块中。<code>bmap</code> 读取间接块，然后从块内的正确位置读取块号。如果块号超过<code>NDIRECT+NINDIRECT</code>，<code>bmap()</code> 会引发 panic；<code>writei()</code> 包含了防止这种情况发生的检查。</p>
<p><code>bmap()</code> 根据需要分配块。<code>ip-&gt;addrs[]</code> 或间接项为零表示未分配块。当 <code>bmap()</code> 遇到零时，它将其替换为新块的编号，由用户按需分配。</p>
<p><code>itrunc()</code> 释放文件的块，将 inode 的大小重置为零。<code>itrunc()</code>首先释放direct blocks，然后释放indirect block中列出的块，最后释放indirect block本身。</p>
<p><code>bmap()</code> 使得 <code>readi()</code> 和 <code>writei()</code> 能够轻松获取到 inode 的数据。<code>readi()</code>首先确保偏移量和计数不超出文件的末尾。从文件末尾开始的读取返回错误，而从文件末尾开始或横跨文件末尾的读取返回比请求的字节数少。主循环处理文件的每个块，将数据从缓冲区复制到 <code>dst</code>。<code>writei()</code> 与 <code>readi()</code> 相同，有三个例外：从文件末尾开始或横跨文件末尾的写入将增加文件的大小，最多增长到<code>MAXFILE*BSIZE</code>；循环将数据复制到缓冲区而不是从中复制；如果写入扩展了文件，则 <code>writei()</code> 必须更新其大小。</p>
<p><code>stati()</code> 函数将 inode 元数据复制到 <code>stat</code> 结构中，通过 <code>stat()</code> 系统调用向用户程序公开。</p>
<h2 id="code-directory-layer">Code: directory layer</h2>
<p>一个目录在内部的实现方式与文件非常相似。它的 inode 的类型是 <code>T_DIR</code>，其数据是目录项的序列。每个目录项是一个 <code>struct dirent</code>（<strong>kernel/fs.h</strong>），其中包含一个名称和一个 inode 号。名称最多为 <code>DIRSIZ</code>（14）个字符；如果较短，它以 NULL（0）字节终止。inode 号为零的目录项是空闲的。</p>
<p>函数 <code>dirlookup()</code>（<strong>kernel/fs.c</strong>）在目录中搜索具有给定名称的条目。如果找到，则返回指向相应 inode 的指针（未锁定），并将 <code>*poff</code> 设置为目录内条目的字节偏移量，以便调用者希望对其进行编辑。如果 <code>dirlookup()</code> 找到具有正确名称的条目，它将更新 <code>*poff</code> 并返回通过 <code>iget()</code> 获得的未锁定 inode。<code>dirlookup()</code> 是 <code>iget()</code> 返回未锁定 inode 的原因。调用者已锁定 <code>dp</code>，因此如果查找是为了 <code>.</code>（表示当前目录的别名），在返回之前尝试锁定 inode 将尝试重新锁定 <code>dp</code> 并导致死锁。（涉及多个进程和 <code>..</code>，表示父目录的别名，有更复杂的死锁场景；<code>.</code> 不是唯一的问题。）调用者可以解锁 <code>dp</code> 然后锁定 <code>ip</code>，确保一次只持有一个锁。</p>
<p>函数 <code>dirlink()</code>向目录 <code>dp</code> 写入具有给定名称和 inode 号的新目录项。如果名称已经存在，<code>dirlink()</code> 返回错误。主循环读取目录条目，寻找未分配的条目。当找到一个时，它提前结束循环，<code>off</code> 设置为可用条目的偏移量。否则，循环以 <code>dp-&gt;size</code> 为结束，<code>dirlink()</code> 然后通过在偏移量 <code>off</code> 处写入新条目将新条目添加到目录中。</p>
<h2 id="code-path-names">Code: Path names</h2>
<p>Path names查找涉及对 <code>dirlookup()</code> 的一系列调用，每个调用对应路径的一个组成部分。<code>namei()</code>评估路径并返回相应的 inode。函数 <code>nameiparent()</code> 是一个变体：它在最后一个元素之前停止，返回父目录的 inode 并将最后一个元素复制到 <code>name</code> 中。这两个函数都调用了执行实际工作的通用函数 <code>namex()</code>。</p>
<p><code>namex()</code> 首先决定路径评估从哪里开始。如果路径以斜杠开头，评估将从根目录开始；否则，从当前目录开始。然后使用 <code>skipelem()</code> 逐个考虑路径的每个元素。循环的每次迭代都必须在当前 inode <code>ip</code> 中查找 <code>name</code>。迭代从锁定 <code>ip</code> 并检查其是否为目录开始。如果不是，则查找失败。（锁定 <code>ip</code> 是必要的，不是因为 <code>ip-&gt;type</code> 可能在底层发生变化，而是因为在运行 <code>ilock</code> 之前，不能保证已从磁盘加载 <code>ip-&gt;type</code>。）如果调用了<code>nameiparent</code> 并且这是最后一个路径元素，则循环提前停止，根据 <code>nameiparent()</code> 的定义；最后的路径元素已经复制到 <code>name</code> 中，因此 <code>namex</code> 只需返回未锁定的 <code>ip</code>。最后，循环使用 <code>dirlookup()</code> 查找路径元素并准备进行下一次迭代，设置 <code>ip = next</code>。当循环耗尽路径元素时，返回 <code>ip</code>。</p>
<p><code>namex()</code> 过程可能需要很长时间才能完成：它可能涉及多个磁盘操作，用于读取路径名中遍历的目录的 inode 和目录块（如果它们不在缓冲区中）。Xv6 被精心设计以便于在一个内核线程的 <code>namex()</code> 调用由于磁盘 I/O 而被阻塞的情况下，另一个内核线程查找不同的路径名可以同时进行。<code>namex()</code> 单独锁定路径中的每个目录，以便在不同的目录中进行的查找可以并行进行。</p>
<p>这种并发性带来了一些麻烦。例如，当一个内核线程正在查找路径名时，另一个内核线程可能正在通过取消链接目录来更改目录树。潜在的风险是，查找可能正在搜索已被另一个内核线程删除的目录，其块已被重新用于另一个目录或文件。</p>
<p>Xv6避免了这样的竞争情况。例如，在<code>namex()</code>中执行<code>dirlookup()</code>时，查找线程持有目录的锁，<code>dirlookup()</code>返回一个使用<code>iget()</code>获得的inode。<code>iget()</code>增加了inode的引用计数。只有在从<code>dirlookup()</code>接收到inode后，<code>namex()</code>才释放对目录的锁。现在，另一个线程可以从目录中取消链接inode，但是xv6不会立即删除inode，因为inode的引用计数仍然大于零。</p>
<p>另一个风险是死锁。例如，当查找&quot;.&ldquo;时，<code>next</code>指向与<code>ip</code>相同的inode。在释放<code>ip</code>的锁之前锁定<code>next</code>将导致死锁。为了避免这种死锁，<code>namex()</code>在获取对<code>next</code>的锁之前释放目录的锁。在这里我们再次看到<code>iget()</code>和<code>ilock()</code>之间的分离的重要。</p>
<h2 id="file-descriptor-layer">File descriptor layer</h2>
<p>Unix接口的一个很酷的方面是，Unix中的大多数资源都被表示为文件，包括console、pipe，当然还有真实的文件。File descriptor层是实现这种一致性的层。</p>
<p>Xv6为每个进程提供了其自己的打开文件表，或者称为文件描述符，正如我们在第一章中看到的那样。每个打开的文件由一个<code>struct file</code>表示，它是一个围绕inode或pipe的包装器，还有一个I/O偏移量。每次调用<code>open()</code>都会创建一个新的打开文件（一个新的<code>struct file</code>）：如果多个进程独立地打开同一个文件，不同的实例将具有不同的I/O偏移量。另一方面，一个单独的打开文件（相同的<code>struct file</code>）可以在一个进程的文件表中和多个进程的文件表中出现多次。如果一个进程使用<code>open()</code>打开文件，然后使用<code>dup()</code>创建别名或者使用<code>fork()</code>与子进程共享文件，就会发生这种情况。引用计数跟踪对特定打开文件的引用次数。文件可以以读、写或两者的方式打开，<code>readable</code>和<code>writable</code>字段跟踪这一点。</p>
<p>系统中所有打开的文件都保存在全局文件表<code>ftable</code>中。文件表具有分配文件（<code>filealloc</code>）、创建副本引用（<code>filedup</code>）、释放引用（<code>fileclose</code>）以及读取和写入数据（<code>fileread</code>和<code>filewrite</code>）的功能。</p>
<p>前三者遵循我们已经熟悉的形式。<code>filealloc()</code>扫描文件表以查找未引用的文件（<code>f-&gt;ref == 0</code>）并返回一个新的引用；<code>filedup</code>增加引用计数；<code>fileclose</code>减小引用计数。当文件的引用计数达到零时，<code>fileclose()</code>释放底层的pipe或inode，根据类型而定。</p>
<p><code>filestat()</code>、<code>fileread()</code>和<code>filewrite()</code>函数实现了对文件的<code>stat</code>、<code>read</code>和<code>write</code>操作。<code>filestat()</code>只允许在inodes上调用，并调用<code>stati()</code>。<code>fileread()</code>和<code>filewrite()</code>检查打开模式是否允许该操作，然后将调用传递给pipe或inode的实现。如果文件表示inode，<code>fileread()</code>和<code>filewrite()</code>使用I/O偏移作为操作的偏移，然后将其递增。Pipe没有偏移的概念。回想一下，inode函数要求调用者处理锁定。inode锁定的方便之处在于读写偏移是原子更新的，因此同时对同一文件进行多次写入不能覆盖彼此的数据，尽管它们的写入可能交织在一起。</p>
<h2 id="code-system-calls">Code: System calls</h2>
<p>具有较低层提供的功能，大多数系统调用的实现都很简单（见(<strong>kernel/sysfile.c</strong>)）。有一些调用值得仔细研究。</p>
<p>函数<code>sys_link</code>和<code>sys_unlink</code>编辑目录，创建或删除对inodes的引用。它们是使用transaction的强大功能的另一个很好的例子。<code>sys_link</code>开始通过获取其参数，两个字符串<code>old</code>和<code>new</code>。假设<code>old</code>存在且不是目录，<code>sys_link</code>增加了它的<code>ip-&gt;nlink</code>计数。然后，<code>sys_link</code>调用<code>nameiparent()</code>来找到<code>new</code>的父目录和最终路径元素，并创建一个指向<code>old</code>的inode的新目录项。新的父目录必须存在，并且在相同的设备上：inode号仅在单个磁盘上有唯一的含义。如果发生此类错误，<code>sys_link</code>必须返回并减少<code>ip-&gt;nlink</code>。</p>
<p>transaction简化了实现，因为它需要更新多个磁盘块，但我们不必担心执行它们的顺序。它们要么全部成功，要么全部不成功。例如，如果没有transaction，先更新<code>ip-&gt;nlink</code>再创建链接会使文件系统暂时处于不安全状态，而在两者之间崩溃可能导致混乱。有了transaction，我们就不必担心这个问题。</p>
<p><code>sys_link</code>为现有的inode创建一个新名称。函数<code>create()</code>为新的inode创建一个新名称。它是三个文件创建系统调用的泛化：使用<code>O_CREATE</code>标志的<code>open()</code>创建一个新的普通文件，<code>mkdir()</code>创建一个新目录，<code>mkdev()</code>创建一个新设备文件。与<code>sys_link()</code>一样，<code>create()</code>开始时通过调用<code>nameiparent()</code>获取父目录的<code>inode</code>。然后，它调用<code>dirlookup()</code>来检查名称是否已经存在。如果名称已经存在，则<code>create()</code>的行为取决于它是为哪个系统调用而使用的：<code>open()</code>的语义与<code>mkdir()</code>和<code>mkdev()</code>不同。如果<code>create()</code>是代表<code>open(type == T_FILE)</code>使用的，且已存在的名称本身是一个普通文件，则<code>open()</code>将其视为成功，因此<code>create()</code>也是如此。否则，它是一个错误。如果名称尚不存在，则<code>create()</code>现在使用<code>ialloc()</code>分配一个新的inode。如果新的inode是一个目录，<code>create()</code>将其初始化为包含<code>.</code>和<code>..</code>条目。最后，现在数据已正确初始化，<code>create()</code>可以将其链接到父目录中。与<code>sys_link()</code>一样，<code>create()</code>同时持有两个inode锁：<code>ip</code>和<code>dp</code>。没有死锁的可能性，因为inode <code>ip</code>是新分配的：系统中没有其他进程会持有<code>ip</code>的锁，然后尝试锁定<code>dp</code>。</p>
<p>使用<code>create()</code>，很容易实现<code>sys_open()</code>、<code>sys_mkdir()</code>和<code>sys_mknod()</code>。<code>sys_open()</code>是最复杂的，因为创建新文件只是它可以做的一小部分。如果<code>open()</code>传递了<code>O_CREATE</code> flag，它调用<code>create()</code>。否则，它调用<code>namei()</code>。<code>create()</code>返回一个锁定的inode，但<code>namei()</code>没有，所以<code>sys_open()</code>必须自己锁定inode。这提供了一个方便的机制来检查目录是否只能以读方式打开，而不能以写方式打开。假设inode以某种方式获取，<code>sys_open()</code>分配一个文件和一个文件描述符，然后填充文件。请注意，由于它只在当前进程的表中，因此没有其他进程可以访问部分初始化的文件。</p>
<p>第7章在我们甚至没有文件系统之前就研究了pipe的实现。<code>sys_pipe()</code>函数通过提供一种创建pipe对的方式将其连接到文件系统。它的参数是指向两个整数空间的指针，它将记录两个新文件描述符。然后，它分配pipe并安装文件描述符。</p>
<h2 id="real-world">Real world</h2>
<p>实际操作系统中的buffer cache比xv6的复杂得多，但它具有相同的两个目的：缓存和同步对磁盘的访问。xv6的buffer cache，就像xv6的一样，使用了简单的最近最少使用（LRU）淘汰策略；有许多更复杂的策略可以实现，每个都对某些工作负载有效，对其他工作负载则不太有效。一个更有效的LRU缓存会消除链表，而是使用哈希表进行查找和用于LRU淘汰的堆。现代buffer cache通常与虚拟内存系统集成，以支持内存映射文件。</p>
<p>xv6的日志系统效率较低。在文件系统系统调用期间，不能同时发生提交。该系统记录整个块，即使块中只更改了少量字节。它执行同步的日志写入，每次写入一个块，每次写入很可能需要整个磁盘旋转时间。真实的日志系统解决了所有这些问题。</p>
<p>日志记录不是提供崩溃恢复的唯一方法。早期的文件系统在重新启动时使用清理程序（例如UNIX的<code>fsck</code>程序）来检查每个文件和目录以及块和inode空闲列表，查找并解决不一致。对于大型文件系统，清理可能需要几个小时，并且存在无法以使原始系统调用成为原子操作的方式解决不一致的情况。从日志中恢复要快得多，并且在面临崩溃时使系统调用成为原子操作。</p>
<p>Xv6使用与早期UNIX相同的基本磁盘上的inode和目录布局；这种方案多年来一直非常持久。BSD的UFS/FFS和Linux的ext2/ext3基本上使用相同的数据结构。文件系统布局中最低效的部分是目录，在每次查找时需要在所有磁盘块上进行线性扫描。当目录只占用几个磁盘块时，这是合理的，但对于包含许多文件的目录而言，这是昂贵的。Microsoft Windows的NTFS，macOS的HFS和Solaris的ZFS等实现目录为磁盘上的均衡块树。这很复杂，但保证了对数时间的目录查找。</p>
<p>Xv6对磁盘故障的处理比较简单：如果磁盘操作失败，xv6就会崩溃。这是否合理取决于硬件：如果操作系统位于使用冗余来掩盖磁盘故障的特殊硬件之上，也许操作系统很少见到故障，那么崩溃可能是可以接受的。另一方面，使用普通磁盘的操作系统应该预期到发生故障，并更优雅地处理它们，以便一个文件中的一个块的丢失不会影响文件系统的其余部分的使用。</p>
<p>Xv6要求文件系统适应一个磁盘设备并且大小不会改变。随着大型数据库和多媒体文件推动存储需求不断增加，操作系统正在开发消除“one disk per file system”的瓶颈的方法。基本的方法是将多个磁盘组合成一个单一的逻辑磁盘。硬件解决方案，如RAID，仍然是最流行的，但目前的趋势是朝着尽可能在软件中实现这些逻辑的方向发展。这些软件实现通常允许丰富的功能，如通过添加或删除磁盘来动态调整逻辑设备的大小。当然，一个可以动态增长或缩小的存储层需要一个可以执行相同操作的文件系统：xv6使用的固定大小的inode块数组在这样的环境中效果不佳。将磁盘管理与文件系统分离可能是最清晰的设计，但两者之间复杂的接口导致一些系统（如Sun的ZFS）将它们合并起来。</p>
<p>Xv6的文件系统缺乏现代文件系统的许多其他功能；例如，它不支持快照和增量备份。</p>
<p>现代Unix系统允许使用与磁盘存储相同的系统调用访问许多种类的资源：named pipes、网络连接、远程访问的网络文件系统以及监控和控制接口，如<code>/proc</code>。与xv6在<code>fileread()</code>和<code>filewrite()</code>中的<code>if</code>语句不同，这些系统通常为每个打开的文件提供一个函数指针表，每个操作一个函数指针，并调用函数指针来调用该inode对调用的实现。网络文件系统和用户级文件系统提供将这些调用转换为网络RPC并在返回之前等待响应的函数。</p>]]></description>
</item>
</channel>
</rss>
